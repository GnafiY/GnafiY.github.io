{"meta":{"title":"一方の笔记本","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-01-19T16:13:58.985Z","updated":"2022-09-13T15:51:27.682Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2023-01-19T16:13:59.001Z","updated":"2022-09-20T11:37:10.433Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":".form-center { width: auto; display: table; margin-left: auto; margin-right: auto; } 关于我 曾经的 FPS 爱好者，主要是因为太菜了于是弃游了（其实另一部分是玩的游戏关服了），喜欢玩的游戏也不算太多，现在主要推 GalGame 养生以及碧蓝航线养老。 大学在学计算机，对数学比较感兴趣；现在的状态是专业课一塌糊涂，算法学的一般，工程能力近乎为零，对计算机前沿也几乎是一无所知，基本上是混日子人。 欢迎大家和我讨论，一起学习进步！如需联系我请用邮箱。 关于本站 本站基于 Hexo 框架，使用 Volantis-5.7.6 主题搭建，环境组件参数如下所示。 组件 版本及说明 npm 8.5.4 git 2.34.1.windows.1 Fira Code 代码字体 giscuss 评论系统 LeanCloud 数据统计服务 Github Page 部署 Hexo 的组件版本如下所示。 12345678910111213+-- hexo-deployer-git@3.0.0+-- hexo-generator-archive@1.0.0+-- hexo-generator-category@1.0.0+-- hexo-generator-index@2.0.0+-- hexo-generator-json-content@4.2.3+-- hexo-generator-tag@1.0.0+-- hexo-helper-qrcode@1.0.2+-- hexo-renderer-ejs@1.0.0+-- hexo-renderer-marked@4.1.0+-- hexo-renderer-stylus@2.1.0+-- hexo-server@2.0.0+-- hexo-theme-landscape@0.0.3`-- hexo@5.4.2 声明 本网站的所有原创内容均受 CC BY-NC-SA 4.0 许可协议的保护，不得用作商业用途，若转载请保留出处； 在浏览网站、或进行评论、交流等相关活动时，请遵守中华人民共和国宪法和法律，文明上网； 请您自觉遵守以上声明，否则，因浏览本站导致的任何问题，本站概不负责。"},{"title":"所有分类","date":"2023-01-19T16:13:59.002Z","updated":"2022-09-12T14:18:31.774Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-01-19T16:13:59.004Z","updated":"2022-11-14T01:27:44.326Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这是我的朋友们，欢迎朋友们互加友链！","text":"这是我的朋友们，欢迎朋友们互加友链！ 我的友链信息 123456789- title: 一方の笔记本 author: 一方 avatar: https://s3.bmp.ovh/imgs/2022/10/17/af2550d8b437ce18.webp url: https://gnafiy.github.io/ keywords: - ACGN - Math - CS description: 睡觉真的是太舒服了"},{"title":"","date":"2023-01-19T16:13:59.005Z","updated":"2022-09-12T14:21:42.198Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2023-01-19T16:13:59.090Z","updated":"2022-09-14T01:25:01.386Z","comments":true,"path":"static/css/atom-one-dark.min.css","permalink":"http://example.com/static/css/atom-one-dark.min.css","excerpt":"","text":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}"},{"title":"","date":"2023-01-19T16:13:59.435Z","updated":"2023-01-04T12:19:54.106Z","comments":true,"path":"static/images/分布.html","permalink":"http://example.com/static/images/%E5%88%86%E5%B8%83.html","excerpt":"","text":"分布名称 分布记号 分布律/概率密度函数 期望 方差 Bernoulli(0-1) Distribution \\(B(1,p)\\) \\(P\\{X=k\\}=p,k\\in\\{0,1\\}\\) \\(p\\) \\(p(1-p)\\) Bionomiol Distribution \\(B(n,p)\\) \\(P\\{X = k\\} = C_{n}^{k}p^k(1-p)^{n-k},k \\in \\{0,1,\\cdots,n\\}\\) \\(np\\) \\(np(1-p)\\) Pascal Distribution \\(NB(r,p)\\) \\(P\\{X = k\\} = C^{r-1}_{k-1}p^r(1-p)^{k-r},k\\geq r\\) \\(\\displaystyle \\frac{r}{p}\\) \\(\\displaystyle\\frac{r(1-p)}{p^2}\\) Geometric Distribution \\(GE(p)\\) \\(P\\{X = k\\} = p(1-p)^{k-1}, k \\in \\N\\) \\(\\displaystyle\\frac{1}{p}\\) \\(\\displaystyle\\frac{1-p}{p^2}\\) Hypergeomotric Distribution \\(H(N,n,M)\\) \\(P\\{X=k\\} = \\displaystyle \\frac{C_{M}^{k}C_{N-M}^{n-k}}{C_{N}^{n}}, k \\in\\{0,1,\\cdots,\\min\\{n,M\\}\\}\\) \\(\\displaystyle \\frac{nM}{N}\\) \\(\\displaystyle (1-\\frac{M}{N})\\frac{N-n}{N-1}E(X)\\) Poisson Distribution \\(P(\\lambda)\\) \\(P\\{ X = k\\} = \\displaystyle \\frac{\\lambda^k}{k!}e^{-\\lambda}, k \\in \\N\\) \\(\\lambda\\) \\(\\lambda\\) Exponential Distribution \\(E(\\lambda)\\) \\(f_{X}(x)=\\lambda e^{-\\lambda}, x &gt; 0\\) \\(\\displaystyle \\frac{1}{\\lambda}\\) \\(\\displaystyle \\frac{1}{\\lambda^2}\\) Normal Distribution \\(N(\\mu, \\sigma^2)\\) \\(\\displaystyle f_{X}(x) = \\frac{1}{\\sqrt{2 \\pi} \\sigma} e ^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}, x \\in \\R\\) \\(\\mu\\) \\(\\sigma^2\\) Uniform Distribution \\(U(a,b)\\) \\(f_{X}(x) = \\displaystyle \\frac{1}{b-a}, x \\in [a,b], b \\neq a\\) \\(\\displaystyle \\frac{a+b}{2}\\) \\(\\displaystyle \\frac{(b-a)^2}{12}\\) Rayleigh Distribution \\(R(\\sigma)\\) \\(\\displaystyle f_{X}(x) = \\frac{x}{\\sigma^2}e^{-\\frac{x^2}{2\\sigma^2}},x &gt; 0\\) \\(\\displaystyle \\sqrt{\\frac{\\pi}{2}}\\sigma\\) \\(\\displaystyle \\frac{4-\\pi}{2}\\sigma^2\\) Cauchy Distribution \\(C(\\gamma,x_0)\\) \\(\\displaystyle f_{X}(x) = \\frac{1}{\\pi} \\frac{1}{\\gamma((\\frac{x - x_0}{\\gamma})^2+1)}\\) 不存在 不存在"},{"title":"所有标签","date":"2023-01-19T16:13:59.477Z","updated":"2022-09-12T14:18:17.131Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-01-19T16:13:59.463Z","updated":"2022-09-13T12:52:35.577Z","comments":true,"path":"static/js/font_awesome.js","permalink":"http://example.com/static/js/font_awesome.js","excerpt":"","text":"window.FontAwesomeKitConfig = {\"asyncLoading\":{\"enabled\":false},\"autoA11y\":{\"enabled\":true},\"baseUrl\":\"https://ka-f.fontawesome.com\",\"baseUrlKit\":\"https://kit.fontawesome.com\",\"detectConflictsUntil\":null,\"iconUploads\":{},\"id\":83503769,\"license\":\"free\",\"method\":\"css\",\"minify\":{\"enabled\":true},\"token\":\"907ec27a36\",\"v4FontFaceShim\":{\"enabled\":true},\"v4shim\":{\"enabled\":true},\"v5FontFaceShim\":{\"enabled\":true},\"version\":\"6.2.0\"}; !function(t){\"function\"==typeof define&&define.amd?define(\"kit-loader\",t):t()}((function(){\"use strict\";function t(e){return(t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(e)}function e(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function n(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function o(t){for(var o=1;ot.length)&&(e=t.length);for(var n=0,o=new Array(e);n"}],"posts":[{"title":"积分题目3","slug":"积分题目3","date":"2023-01-09T14:57:07.000Z","updated":"2023-01-09T15:41:22.707Z","comments":true,"path":"2023-01-09-积分题目3/","link":"","permalink":"http://example.com/2023-01-09-%E7%A7%AF%E5%88%86%E9%A2%98%E7%9B%AE3/","excerpt":"这篇博客用于记录一些比较有趣的积分问题。","text":"这篇博客用于记录一些比较有趣的积分问题。 求\\(\\displaystyle I = \\int \\sin(101x)(\\sin x)^{99} dx\\) \\[\\displaystyle I = \\int \\sin(101x)(\\sin x)^{99} dx = \\int (\\sin(100x)\\cos x + \\sin x \\cos (100x) )(\\sin x)^{99}dx\\] \\[=\\frac{1}{100}\\int \\sin(100x) d(\\sin x)^{100} + \\int (\\sin x)^{100} \\cos(100x) dx = \\sin(100x) (\\sin x)^{100} + C \\] 求\\(\\displaystyle I = \\int \\frac{1+\\sin x}{1 + \\cos x}e^x dx\\) \\[\\displaystyle I = \\int \\frac{e^x}{1+ \\cos x} dx + \\int \\frac{\\sin x (1 - \\cos x)}{(1+\\cos x)(1- \\cos x)} e^x dx = \\int \\frac{e^x}{1+ \\cos x} dx + \\int \\frac{1 - \\cos x}{\\sin x} e^x dx\\] 又有： \\[\\int \\frac{1 - \\cos x}{\\sin x} e^x dx = \\int \\frac{2 \\sin^2 \\frac{x}{2}}{2 \\sin\\ \\frac{x}{2} \\cos \\frac{x}{2}} e^x dx = \\int e^x \\tan\\frac{x}{2} dx = e^x \\tan \\frac{x}{2} - \\int \\frac{e^x}{1+ \\cos x} dx\\] 因此\\(I \\displaystyle = e^x\\tan\\frac{x}{2} + C\\)。 求\\(\\displaystyle I = \\int_{0}^{+\\infty} \\frac{\\sin^3 x}{x^3} dx\\) \\[\\displaystyle \\sin 3x = 3\\sin x - 4\\sin^3 x \\Rightarrow \\sin^3 x = \\frac{3\\sin x - \\sin 3x}{4}\\] \\[I = \\frac{\\sin^3 x}{x^3}dx = \\frac{1}{4} \\int_{0}^{+\\infty} \\frac{3\\sin x - \\sin 3x}{x^3}dx = \\frac{1}{4} \\int_{0}^{+\\infty} (3\\sin x - \\sin 3x) d(-\\frac{1}{2x^2}) \\] \\[= \\frac{3}{8} \\int_{0}^{+\\infty} \\frac{\\cos x - \\cos3x}{x^2} dx = \\frac{3}{8} \\int_{0}^{+\\infty} (\\cos x - \\cos3x) d(-\\frac{1}{x^2}) = \\frac{3}{8} \\int_{0}^{+\\infty} \\frac{3 \\sin 3x -\\sin x}{x} dx \\] 迪利克雷积分的结果为： \\[\\int_{-\\infty}^{+\\infty}\\frac{\\sin x}{x}dx = \\pi\\] 最终求出\\(\\displaystyle I = \\frac{3}{8}\\pi\\)。 求\\(\\displaystyle I = \\int \\frac{x^5 - x}{x^8+1} dx\\) \\[I = \\int \\frac{x - \\frac{1}{x^3}}{x^4 + \\frac{1}{x^4}}dx = \\frac{1}{2} \\int \\frac{1}{x^4 + \\frac{1}{x^4}} d(x^2 + \\frac{1}{x^2}) \\xlongequal{t = x^2 + \\frac{1}{x^2}} \\frac{1}{2} \\int \\frac{1}{t^2 - 2}dt = \\frac{1}{4\\sqrt{2}} \\ln | \\frac{t - \\sqrt{2}}{t + \\sqrt{2}} | + C\\] 因此\\(\\displaystyle I = \\frac{1}{4\\sqrt{2}} \\ln |\\frac{x^2+\\frac{1}{x^2} - \\sqrt{2}}{x^2+ \\frac{1}{x^2} + \\sqrt{2}}| + C = \\frac{1}{4\\sqrt{2}}\\ln |\\frac{x^4 - \\sqrt{2}x^2 + 1}{x^4 + \\sqrt{2}x^2 + 1}| + C\\)。 求\\(\\displaystyle \\int \\frac{x + \\ln(1 - x)}{x^2} dx\\) \\[I = \\int \\frac{1}{x^2}dx + \\int \\ln(1-x)d(-\\frac{1}{x}) = \\int \\frac{1}{x} dx -\\frac{1}{x}\\ln(1-x) + \\int\\frac{1}{x(x-1)}dx \\] \\[= -\\frac{1}{x} \\ln(1-x) + \\int \\frac{dx}{x-1} = \\frac{x-1}{x}\\ln(1-x)dx + C\\] 这里特别需要注意求解\\(\\displaystyle \\int \\frac{dx}{x-1}\\)的结果，事实上结果是\\(\\displaystyle \\ln|x-1| + C\\)，然而被积函数的定义域为\\(x \\in (-\\infty, 0) \\bigcup (0,1)\\)，因此正确的结果是\\(\\ln (1-x) + C\\)。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"动态规划学习笔记","slug":"动态规划学习笔记","date":"2023-01-07T08:59:21.000Z","updated":"2023-01-14T12:25:38.349Z","comments":true,"path":"2023-01-07-动态规划学习笔记/","link":"","permalink":"http://example.com/2023-01-07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本篇博客为一些动态规划学习的笔记。","text":"本篇博客为一些动态规划学习的笔记。 前言 一个问题能用动态规划解决需要满足三个条件：有边界条件、有递推方程且具有最优子结构性质。 递推地求解斐波那契数列是最朴素的动态规划问题之一，下面三个函数的求解效率从上到下依次递增。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;// 0 &lt;= n &lt;= 25const int N = 30;int n, mem[N];// 朴素的暴力搜索int fib_by_dfs(int n) &#123; if (n == 0 || n == 1) return 1; else return fib_by_dfs(n - 1) + fib_by_dfs(n - 2);&#125;// 记忆化搜索int fib_by_dfs_mem_opt(int n) &#123; if (~mem[n]) return mem[n]; else return mem[n] = (mem[n - 1] = fib_by_dfs(n - 1)) + (mem[n - 2] = fib_by_dfs(n - 2));&#125;// 动态规划int fib_by_dp_opt(int n) &#123; int dp[N]; dp[0] = 1, dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;int main() &#123; int n; cin &gt;&gt; n; // 将备忘录数组初始化为不在计算过程出现的数据即可，这里选用-1 memset(mem, -1, sizeof mem); cout &lt;&lt; fib_by_dp_opt(n) &lt;&lt; endl; return 0;&#125; 从上述例子不难看出，动态规划算法是对暴力搜索算法的优化。下面再以最低通行费为例，不难写出如下的暴力搜索算法。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N = 104;int g[N][N], n;// 朴素的暴力搜索算法，没有任何优化，有重复枚举需要重新计算int dfs(int x, int y) &#123; if(x == n &amp;&amp; y == n) return g[n][n]; if(x &gt; n || y &gt; n) return 1e9; return min(dfs(x + 1, y), dfs(x, y + 1)) + g[x][y];&#125;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; &#125; &#125; cout &lt;&lt; dfs(1, 1) &lt;&lt; endl; return 0;&#125; 注意到搜索过程中某些位置会被多次遍历，并且这些位置的结果是固定的，因此使用记忆化搜索进行如下优化，即记录下已遍历位置的答案。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 104;int g[N][N], n;int f[N][N];// 记忆化搜索优化，用-1代表位置并未被搜索过，减少大量不必要的重复计算后代码不会TLEint dfs(int x, int y) &#123; if(~f[x][y]) return f[x][y]; if(x == n &amp;&amp; y == n) return g[n][n]; if(x &gt; n || y &gt; n) return 1e9; return f[x][y] = min(f[x + 1][y] = dfs(x + 1, y), f[x][y + 1] = dfs(x, y + 1)) + g[x][y];&#125;int main() &#123; memset(f, -1, sizeof f); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; &#125; &#125; cout &lt;&lt; dfs(1, 1) &lt;&lt; endl; return 0;&#125; 最终，在记忆化搜索代码的基础上，可以写出最终的动态规划代码，对于求解最小值的问题，需要注意边界条件和动态规划数组的初始化。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 103;int n;int g[N][N], dp[N][N];int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; &#125; &#125; memset(dp, 0x3f, sizeof dp); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; // 注意边界条件 if(i == 1 &amp;&amp; j == 1) dp[i][j] = 0; else dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]); dp[i][j] += g[i][j]; &#125; &#125; cout &lt;&lt; dp[n][n] &lt;&lt; endl; return 0;&#125; 明白以上原理后可以在AcWing算法提高课中进行进一步的练习。 其他示例代码 最大连续子序列之和 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define INF 10000009using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int tmpSum = 0, maxSum = 0; for (auto i : nums) &#123; tmpSum = max(tmpSum + i, i); maxSum = max(tmpSum, maxSum); &#125; cout &lt;&lt; maxSum &lt;&lt; endl; return 0;&#125; 矩阵连乘问题 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define INF 1000000009using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; mSize(n + 1); mSize[0] = pair&lt;int, int&gt;(-1, -1); for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; mSize[i].first &gt;&gt; mSize[i].second; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, INF)); for (int i = 1; i &lt;= n; i++) &#123; dp[i][i] = 0; &#125; for (int len = 2; len &lt;= n; len++) &#123; //计算长度为len的矩阵链最优值 for (int i = 1; i &lt;= n - len + 1; i++) &#123; //矩阵链的开始矩阵下标 int j = i + len - 1; //矩阵链的结束矩阵下标 for (int k = i; k &lt; j; k++) &#123; //枚举划分位置 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + mSize[i].first * mSize[k].second * mSize[j].second); &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl; /*测试数据 6 30 35 35 15 15 5 5 10 10 20 20 25 ans:15125 */ return 0;&#125; 集合划分 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;int main() &#123;//集合划分 int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); //dp[i][j]代表i个元素时划分为j个集合有多少种方法 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i &gt;= j) &#123; if (j == 1) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j] * j + dp[i - 1][j - 1]; &#125; &#125; &#125; &#125; ll ans = 0;//注意结果是否溢出 for (int i = 1; i &lt;= n; i++) &#123; ans += dp[n][i]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 数字三角形模型 AcWing 1015 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 101;const int dx[2] = &#123;0, 1&#125;, dy[2] = &#123;1, 0&#125;;int g[N][N], f[N][N];int n, m;void solve() &#123; cin &gt;&gt; n &gt;&gt; m; memset(f, 0, sizeof f); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; g[i][j]; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]) + g[i][j]; &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl;&#125;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; solve(); &#125; return 0;&#125; AcWing 1018 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 101;int g[N][N], dp[N][N];int n;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; &#125; &#125; memset(dp, 0x3f, sizeof dp); for(int i = 0; i &lt;= n; i++) dp[i][0] = dp[0][i] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(i &gt; 1 &amp;&amp; j &gt; 1) dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]); else if(i == 1) dp[i][j] = dp[i][j - 1]; else dp[i][j] = dp[i - 1][j]; dp[i][j] += g[i][j]; &#125; &#125; cout &lt;&lt; dp[n][n] &lt;&lt; endl; return 0;&#125; AcWing 1027 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;// 符合题意的任何(1,1) -&gt; (n,n)路径长度相同，所以可以同时走const int N = 11;int g[N][N], f[2 * N][N][N];int n;bool valid(int x, int y) &#123; return x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n;&#125;int main() &#123; cin &gt;&gt; n; int a, b, c; while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &amp;&amp; (a + b + c)) &#123; g[a][b] = c; &#125; for(int len = 2; len &lt;= 2 * n; len++) &#123; for(int i1 = 1; i1 &lt;= n; i1++) &#123; for(int i2 = 1; i2 &lt;= n; i2++) &#123; int j1 = len - i1, j2 = len - i2; if(valid(j1, j2)) &#123; int t = g[i1][j1]; if(i1 != i2) t += g[i2][j2]; for(int i = 0; i &lt; 4; i++) &#123; f[len][i1][i2] = max(f[len][i1][i2], f[len - 1][i1 -(i &amp; 1)][i2 - ((i &gt;&gt; 1) &amp; 1)] + t); &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; f[n * 2][n][n] &lt;&lt; endl; return 0;&#125; AcWing 275 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;// 符合题意的任何(1,1) -&gt; (n,m)路径长度相同，所以可以同时走const int N = 55;int g[N][N], f[2 * N][N][N];int n, m;bool valid(int y) &#123; return y &gt;= 1 &amp;&amp; y &lt;= m;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; int a, b, c; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; g[i][j]; &#125; &#125; for(int len = 2; len &lt;= m + n; len++) &#123; for(int i1 = 1; i1 &lt;= n; i1++) &#123; for(int i2 = 1; i2 &lt;= n; i2++) &#123; int j1 = len - i1, j2 = len - i2; if(valid(j1) &amp;&amp; valid(j2)) &#123; int t = g[i1][j1]; if(i1 != i2 || j1 != j2) t += g[i2][j2]; for(int i = 0; i &lt; 4; i++) &#123; f[len][i1][i2] = max(f[len][i1][i2], f[len - 1][i1 -(i &amp; 1)][i2 - ((i &gt;&gt; 1) &amp; 1)] + t); &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; f[n + m][n][n] &lt;&lt; endl; return 0;&#125; 最长上升子序列模型 AcWing 1017 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N = 110;int arr[N], dp_inc[N], dp_dec[N];int ans = -1, n;void solve() &#123; ans = -1; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; dp_inc[i] = dp_dec[i] = 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt; i; j++) &#123; if(arr[i] &gt; arr[j]) dp_inc[i] = max(dp_inc[i], dp_inc[j] + 1); if(arr[i] &lt; arr[j]) dp_dec[i] = max(dp_dec[i], dp_dec[j] + 1); &#125; ans = max(ans, max(dp_inc[i], dp_dec[i])); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; solve(); &#125; return 0;&#125; AcWing 1014 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 1010;int arr[N], dp_inc[N], dp_dec[N], n;int main() &#123; int ans = -1; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; dp_inc[i] = dp_dec[i] = 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt; i; j++) &#123; if(arr[i] &gt; arr[j]) dp_inc[i] = max(dp_inc[i], dp_inc[j] + 1); &#125; &#125; for(int i = n; i &gt;= 1; i--) &#123; for(int j = n; j &gt; i; j--) &#123; if(arr[i] &gt; arr[j]) dp_dec[i] = max(dp_dec[i], dp_dec[j] + 1); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; ans = max(ans, dp_dec[i] + dp_inc[i] - 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; AcWing 482 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int N = 1010;int arr[N], dp_inc[N], dp_dec[N], n;int main() &#123; int ans = -1; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; dp_inc[i] = dp_dec[i] = 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt; i; j++) &#123; if(arr[i] &gt; arr[j]) dp_inc[i] = max(dp_inc[i], dp_inc[j] + 1); &#125; &#125; for(int i = n; i &gt;= 1; i--) &#123; for(int j = n; j &gt; i; j--) &#123; if(arr[i] &gt; arr[j]) dp_dec[i] = max(dp_dec[i], dp_dec[j] + 1); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; ans = max(ans, dp_dec[i] + dp_inc[i] - 1); &#125; // compared to 1014, the only difference is the output cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125; 背包模型 AcWing 423 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;#define MAX_N 101#define MAX_V 1010int costs[MAX_N], values[MAX_N], dp[MAX_V];int main() &#123; int v, n; cin &gt;&gt; v &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; costs[i] &gt;&gt; values[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = v; j &gt;= costs[i]; j--) &#123; dp[j] = max(dp[j], dp[j - costs[i]] + values[i]); &#125; &#125; cout &lt;&lt; dp[v] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"机器学习自学笔记","slug":"机器学习自学笔记","date":"2023-01-03T05:29:33.000Z","updated":"2023-01-03T05:30:14.428Z","comments":true,"path":"2023-01-03-机器学习自学笔记/","link":"","permalink":"http://example.com/2023-01-03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"信号与系统自学笔记","slug":"信号与系统自学笔记","date":"2023-01-03T05:29:16.000Z","updated":"2023-01-03T05:30:01.013Z","comments":true,"path":"2023-01-03-信号与系统自学笔记/","link":"","permalink":"http://example.com/2023-01-03-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"上海交通大学计算机考研复试上机题题解","slug":"上海交通大学计算机考研复试上机题题解","date":"2023-01-01T19:40:11.000Z","updated":"2023-01-07T09:07:58.421Z","comments":true,"path":"2023-01-02-上海交通大学计算机考研复试上机题题解/","link":"","permalink":"http://example.com/2023-01-02-%E4%B8%8A%E6%B5%B7%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"之前在准备夏令营机试时做过不少题目，现将牛客网上的部分题目的代码进行整理，以供参考。","text":"之前在准备夏令营机试时做过不少题目，现将牛客网上的部分题目的代码进行整理，以供参考。 String Matching 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std; const int N = 1e6 + 10;char s[N], p[N];int ne[N]; int main() &#123; scanf(&quot;%s %s&quot;, s + 1, p + 1); int n = strlen(p + 1), m = strlen(s + 1); for(int i = 2, j = 0; i &lt;= n; i++) &#123; while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j++; ne[i] = j; &#125; int ans = 0; for(int i = 1, j = 0; i &lt;= m; i++) &#123; while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j++; if(j == n) ans++; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 二次方程计算器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std; //ax^2+bx+c=0int a = 0, b = 0, c = 0; void process(string&amp; src) &#123; int t = 0; bool neg = false, left = true; for (int i = 0; i &lt; src.size(); i++) &#123; if (src[i] == &#x27;=&#x27; || src[i] == &#x27;+&#x27;) &#123; if ((left ^ neg) == false) t *= -1; c += t; t = 0; if (src[i] == &#x27;=&#x27;) left = false; continue; &#125; else &#123; //-, +, x ^ if (src[i] == &#x27;x&#x27;) &#123; if (t == 0) t = 1; if ((left ^ neg) == false) t *= -1; if (src.substr(i, 3) == &quot;x^2&quot;) &#123; i += 2; a += t; &#125; else &#123; b += t; &#125; neg = false; t = 0; &#125; else if (src[i] == &#x27;-&#x27;) &#123; if ((left ^ neg) == false) t *= -1; c += t; t = 0; neg = true; &#125; else &#123; t = t * 10 + src[i] - &#x27;0&#x27;; &#125; &#125; &#125; if (t) &#123; if ((left ^ neg) == false) t *= -1; c += t; t = 0; &#125;&#125; void solve() &#123; int delta = b * b - 4 * a * c; if (delta &lt; 0) cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; else if (delta == 0) cout &lt;&lt; -double(b) / (2 * a) &lt;&lt; endl; else &#123; double x1, x2; x1 = (-(double)b + sqrt(delta)) / (2 * a); x2 = (-(double)b - sqrt(delta)) / (2 * a); if (x1 &gt; x2) swap(x1, x2); cout &lt;&lt; x1 &lt;&lt; &#x27; &#x27; &lt;&lt; x2 &lt;&lt; endl; &#125;&#125; int main() &#123; string src; cin &gt;&gt; src; process(src); cout &lt;&lt; fixed &lt;&lt; setprecision(2); solve(); return 0;&#125; WERTYU 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std; int main() &#123; string src; getline(cin, src); const vector&lt;string&gt; tbl = &#123; &quot;`1234567890-=&quot;, &quot;QWERTYUIOP[]\\\\&quot;, &quot;ASDFGHJKL;\\&#x27;&quot;, &quot;ZXCVBNM,./&quot;, &#125;; for(int i = 0; i &lt; src.size(); i++) &#123; bool find = false; for(int j = 0; j &lt; 4 &amp;&amp; !find; j++) &#123; auto t = tbl[j].find(src[i]); if(t == string::npos) continue; else &#123; if(t &gt; 0) src[i] = tbl[j][t - 1]; find = true; &#125; &#125; &#125; cout &lt;&lt; src &lt;&lt; endl; return 0;&#125; Simple Sorting 1234567891011121314151617#include &lt;iostream&gt;#include &lt;set&gt;using namespace std; int main() &#123; int n; cin &gt;&gt; n; set&lt;int&gt; S; while(n--) &#123; int a; cin &gt;&gt; a; S.insert(a); &#125; for(auto &amp;it: S) cout &lt;&lt; it &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; Old Bill 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main() &#123; int n, x, y, z; while (cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; z) &#123; int middle = x * 100 + y * 10 + z; bool not_found = true; for (int i = 9; i &gt;= 1 &amp;&amp; not_found; i--) &#123; for (int j = 9; j &gt;= 0; j--) &#123; int total = middle * 10 + i * 10000 + j; if (total % n == 0) &#123; cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; total / n &lt;&lt; endl; not_found = false; break; &#125; &#125; &#125; if(not_found) cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125; Fibonacci 1234567891011121314151617#include &lt;iostream&gt;using namespace std; const int N = 31; int fib[N]; int main() &#123; fib[0] = 0, fib[1] = 1; int n; cin &gt;&gt; n; for(int i = 2; i &lt;= n; i++) &#123; fib[i] = fib[i - 1] + fib[i - 2]; &#125; cout &lt;&lt; fib[n] &lt;&lt; endl; return 0;&#125; 2的幂次方 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std; string dfs(int n) &#123; if(n == 1) return &quot;2(0)&quot;; if(n == 2) return &quot;2&quot;; vector&lt;int&gt; division; for(int i = 0; i &lt; 30; i++) &#123; if(n &amp; (1 &lt;&lt; i)) division.emplace_back(i); &#125; if(division.size() == 1) return &quot;2(&quot; + dfs(division.back()) + &quot;)&quot;; string ans(dfs(1 &lt;&lt; division.back())); for(int i = division.size() - 2; i &gt;= 0; i--) &#123; ans += &quot;+&quot; + dfs(1 &lt;&lt; division[i]); &#125; return ans;&#125; int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; dfs(n) &lt;&lt; endl; return 0;&#125; 路径打印 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;vector&lt;string&gt; split(const string src, char splitter) &#123; vector&lt;string&gt; ans; string buffer; for (auto&amp; c : src) &#123; if (c == splitter) &#123; if (buffer.size()) ans.push_back(buffer); buffer.clear(); &#125; else buffer.push_back(c); &#125; if (buffer.size()) ans.push_back(buffer); return ans;&#125;class tree &#123;private: struct node &#123; string val; map&lt;string, node*&gt; children; node(const string init) : val(init) &#123;&#125; &#125; *root; void delete_tree(node* root) &#123; if (nullptr == root) return; for (auto&amp; [key, ptr] : root-&gt;children) &#123; delete_tree(ptr); &#125; delete root; root = nullptr; &#125; void _add_path_(node* root, const vector&lt;string&gt;&amp; splitted_line, int cur_depth) &#123; if (cur_depth == splitted_line.size()) return; auto exist = root-&gt;children.find(splitted_line[cur_depth]); if (exist != root-&gt;children.end()) &#123; _add_path_((*exist).second, splitted_line, cur_depth + 1); &#125; else &#123; node* new_node = new node(splitted_line[cur_depth]); root-&gt;children.insert(&#123; splitted_line[cur_depth], new_node &#125;); _add_path_(new_node, splitted_line, cur_depth + 1); &#125; &#125; void _print_tree_(node* root, int cur_depth) &#123; if (nullptr == root) return; if (root-&gt;val.size()) &#123; cout &lt;&lt; string(2 * (cur_depth - 1), &#x27; &#x27;) &lt;&lt; root-&gt;val &lt;&lt; endl; &#125; for (auto&amp; [key, ptr] : root-&gt;children) &#123; _print_tree_(ptr, cur_depth + 1); &#125; &#125;public: tree() &#123; root = new node(&quot;&quot;); &#125; ~tree() &#123; delete_tree(root); &#125; void add_path(const vector&lt;string&gt;&amp; splitted_line) &#123; _add_path_(root, splitted_line, 0); &#125; void print_tree() &#123; _print_tree_(root, 0); &#125;&#125;;int main() &#123; int n; while (cin &gt;&gt; n, n) &#123; cin.get(); string line; tree T; for (int i = 0; i &lt; n; i++) &#123; getline(cin, line); auto splitted_line = split(line, &#x27;\\\\&#x27;); T.add_path(splitted_line); &#125; T.print_tree(); cout &lt;&lt; endl; &#125; return 0;&#125; 整除问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; primes;bool is_prime(int n) &#123; if (n == 2) return true; if (n == 1 || n % 2 == 0) return false; for (int i = 3; i &lt;= n / i; i += 2) &#123; if (n % i == 0) return false; &#125; return true;&#125;void get_primes() &#123; for (int i = 2; i &lt;= 1000; i++) &#123; if (is_prime(i)) primes.push_back(i); &#125;&#125;int main() &#123; get_primes(); int n, a; cin &gt;&gt; n &gt;&gt; a; unordered_map&lt;int, int&gt; ma, mn; for (int i = 2; i &lt;= a / i; i++) &#123; while (a % i == 0) &#123; ma[i]++; a /= i; &#125; &#125; if (a &gt; 1) ma[a]++; for (auto&amp; prime : primes) &#123; int nn = n; if (nn / prime) &#123; while (nn) &#123; mn[prime] += nn / prime; nn /= prime; &#125; &#125; &#125; int k = 0; bool flag = true; while(flag) &#123; for (auto&amp; [x, y] : ma) &#123; if (mn.find(x) == mn.end() || mn[x] &lt; (k + 1) * y) &#123; flag = false; break; &#125; &#125; if (flag) k++; &#125; cout &lt;&lt; k &lt;&lt; endl; return 0;&#125; 计算表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;char, int&gt; pri_level&#123; &#123;&#x27;+&#x27;, 1&#125;, &#123;&#x27;-&#x27;, 1&#125;, &#123;&#x27;*&#x27;, 2&#125;, &#123;&#x27;/&#x27;, 2&#125; &#125;;void single_calaulation(stack&lt;double&gt;&amp; operands, stack&lt;char&gt;&amp; operators) &#123; double a = operands.top(); operands.pop(); double b = operands.top(); operands.pop(); char op = operators.top(); operators.pop(); switch (op) &#123; case &#x27;+&#x27;: operands.push(a + b); break; case &#x27;-&#x27;: operands.push(b - a); break; case &#x27;*&#x27;: operands.push(a * b); break; case &#x27;/&#x27;: operands.push(b / a); break; &#125;&#125;int calculation(const string&amp; src) &#123; stack&lt;double&gt; operands; stack&lt;char&gt; operators; for (int i = 0; i &lt; src.size(); i++) &#123; if (isdigit(src[i])) &#123; int num = 0, j = i; while (j &lt; src.size() &amp;&amp; isdigit(src[j])) &#123; num = num * 10 + src[j] - &#x27;0&#x27;; j++; &#125; i = j - 1; operands.push(num); &#125; else &#123; while (!operators.empty() &amp;&amp; pri_level[operators.top()] &gt;= pri_level[src[i]]) &#123; single_calaulation(operands, operators); &#125; operators.push(src[i]); &#125; &#125; while (!operators.empty()) single_calaulation(operands, operators); return (int)operands.top();&#125;int main() &#123; string line; while (getline(cin, line), line.size()) &#123; cout &lt;&lt; calculation(line) &lt;&lt; endl; &#125; return 0;&#125; Coincidence 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;constexpr int MAX_LEN = 105;string s1, s2;int f[MAX_LEN][MAX_LEN];int dp(int ptr1, int ptr2) &#123; if (ptr1 == s1.size() || ptr2 == s2.size()) return 0; if (~f[ptr1][ptr2]) return f[ptr1][ptr2]; int ans = 0; if (s1[ptr1] == s2[ptr2]) ans = dp(ptr1 + 1, ptr2 + 1) + 1; else ans = max(dp(ptr1 + 1, ptr2), dp(ptr1, ptr2 + 1)); return f[ptr1][ptr2] = ans;&#125;int main() &#123; cin &gt;&gt; s1 &gt;&gt; s2; memset(f, -1, sizeof f); cout &lt;&lt; dp(0, 0) &lt;&lt; endl; return 0;&#125; 最小面积子矩阵 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std; const int N = 1e2 + 10; int a[N][N]; int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; a[i][j] += a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1]; &#125; &#125; int ans = 1e7; for (int x1 = 1; x1 &lt;= n; x1++) &#123; for (int y1 = 1; y1 &lt;= m; y1++) &#123; for (int x2 = x1; x2 &lt;= n; x2++) &#123; for (int y2 = y1; y2 &lt;= m; y2++) &#123; int s = a[x2][y2] + a[x1 - 1][y1 - 1] - a[x2][y1 - 1] - a[x1 - 1][y2]; if (s &gt;= k) &#123; ans = min(ans, (x2 - x1 + 1) * (y2 - y1 + 1)); &#125; &#125; &#125; &#125; &#125; if (ans &gt; 1e4) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 最短路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std; const int N = 102, MOD = 1e5, INF = 0x3f3f3f3f; int n, m;int g[N][N], dist[N], p[N];bool st[N];int find(int x) &#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125; void dijkstra() &#123; memset(dist, 0x3f, sizeof dist); dist[0] = 0; for(int i = 0; i &lt; n; i++) &#123; int t = -1; for(int j = 0; j &lt; n; j++) &#123; if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; &#125; st[t] = true; for(int j = 0; j &lt; n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); &#125; &#125;&#125; int main() &#123; memset(g, 0x3f, sizeof g); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) p[i] = i; int cost = 1; while(m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; // 若城市之间已存在道路，则一定是选择代价小的道路（先输入的道路） if(find(a) != find(b))&#123; p[find(a)] = find(b); g[a][b] = g[b][a] = cost; &#125; cost = cost * 2 % MOD; &#125; dijkstra(); for(int i = 1; i &lt; n; i++) &#123; if(dist[i] &gt; INF / 2) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dist[i] % MOD &lt;&lt; endl; &#125; return 0;&#125; 统计图的连通分支数 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std; unordered_map&lt;int, int&gt; p; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125; void merge(int a, int b) &#123; p[find(a)] = find(b);&#125; int main() &#123; int s, e; while (cin &gt;&gt; s &gt;&gt; e) &#123; if (p.find(s) == p.end()) p[s] = s; if (p.find(e) == p.end()) p[e] = e; merge(s, e); &#125; int ans = 0; for (auto&amp; it : p) &#123; int i = it.first; if (find(i) == i) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Day of Week 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const vector&lt;string&gt; months&#123; &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;&#125;;const vector&lt;string&gt; weekdays&#123; &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;&#125;;int days_in_months[13] = &#123; 0,31,28,31,30,31,30,31,31,30,31,30,31 &#125;;int get_month_from_str(const string src) &#123; int i = 0; for (; i &lt; months.size(); i++) &#123; if (months[i] == src) return i + 1; &#125; return -1;&#125;bool is_leap(int year) &#123; return year % 400 == 0 || (year % 100 != 0 &amp;&amp; year % 4 == 0);&#125;int main() &#123; int day, year; string month_str; while (cin &gt;&gt; day &gt;&gt; month_str &gt;&gt; year) &#123; int month = get_month_from_str(month_str); int delta_day = 0; for (int i = 1000; i &lt; year; i++) &#123; delta_day += is_leap(i) + 365; &#125; days_in_months[2] = is_leap(year)? 29: 28; for (int start_month = 1, start_day = 1; ;) &#123; if (start_month != month) &#123; delta_day += days_in_months[start_month]; start_month++; &#125; else &#123; delta_day += day - 1; break; &#125; &#125; int res = (delta_day + 2) % 7; cout &lt;&lt; weekdays[res] &lt;&lt; endl; &#125; return 0;&#125; 日期差值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int days_in_months[13] = &#123; 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;;struct date &#123; int year, month, day;&#125;;date get_date(const string src) &#123; int year = 0, month = 0, day = 0; for (int i = 0; i &lt; 4; i++) &#123; year = year * 10 + src[i] - &#x27;0&#x27;; &#125; for (int i = 4; i &lt; 6; i++) &#123; month = month * 10 + src[i] - &#x27;0&#x27;; &#125; for (int i = 6; i &lt; 8; i++) &#123; day = day * 10 + src[i] - &#x27;0&#x27;; &#125; return &#123; year, month, day &#125;;&#125;bool is_leap(int year) &#123; return year % 400 == 0 || (year % 100 != 0 &amp;&amp; year % 4 == 0);&#125;int calculate(date date1, date date2) &#123; int ans = 0; // 处理最后一个月的问题 if (date1.day &gt; date2.day) &#123; ans += date2.day; date2.month--; if (date2.month == 0) &#123; date2.year--; date2.month = 12; &#125; days_in_months[2] = is_leap(date2.year) ? 29 : 28; date2.day = days_in_months[date2.month]; &#125; days_in_months[2] = is_leap(date2.year) ? 29 : 28; for (int i = date1.year; i &lt; date2.year; i++) &#123; ans += 365 + is_leap(i); &#125; for (int month = date1.month, day = date1.day;;) &#123; if (month &lt; date2.month) &#123; ans += days_in_months[month++]; &#125; else &#123; ans += date2.day - date1.day + 1; break; &#125; &#125; return ans;&#125;int main() &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; date date1 = get_date(s1), date2 = get_date(s2); // 当date1与date2先后顺序不定时需要以下代码 // //判断date1 &amp; date2 哪个日期靠后，返回date1 &lt; date2 // auto cmp = [](const date&amp; date1, const date&amp; date2) &#123; // return date1.year &lt; date2.year || // date1.year == date2.year &amp;&amp; date1.month &lt; date2.month || // date1.year == date2.year &amp;&amp; date1.month == date2.month &amp;&amp; date1.day &lt; date2.day; // &#125;; // if (!cmp(date1, date2)) swap(date1, date2); cout &lt;&lt; calculate(date1, date2) &lt;&lt; endl; return 0;&#125; 取中值 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int arr1[N], arr2[N], merged[N * 2], idx = 0;int a, b, c, d;int main() &#123; int l1, l2; cin &gt;&gt; l1 &gt;&gt; l2; for (int i = 1; i &lt;= l1; i++) cin &gt;&gt; arr1[i]; for (int i = 1; i &lt;= l2; i++) cin &gt;&gt; arr2[i]; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; for (int i = a; i &lt;= b; i++) merged[idx++] = arr1[i]; for (int i = c; i &lt;= d; i++) merged[idx++] = arr2[i]; // 如果有两个中间值，则取较小的 cout &lt;&lt; merged[(idx - 1) / 2] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"积分题目2","slug":"积分题目2","date":"2023-01-01T08:48:36.000Z","updated":"2023-01-08T15:50:25.657Z","comments":true,"path":"2023-01-01-积分题目2/","link":"","permalink":"http://example.com/2023-01-01-%E7%A7%AF%E5%88%86%E9%A2%98%E7%9B%AE2/","excerpt":"这篇博客用于总结概率论相关的积分计算问题。","text":"这篇博客用于总结概率论相关的积分计算问题。 求\\(Z=g(X,Y)\\)的概率密度函数 设有二维随机变量\\((X,Y)\\)以及其联合分布的概率密度函数\\(f(x,y)\\)，试求\\(Z=g(X,Y)\\)的概率密度函数。 求\\(Z=X+Y\\)的概率密度函数 \\(\\displaystyle F_{Z}(z)=P\\{Z \\leq z\\} = P\\{X+Y \\leq z\\} = \\iint_{x+y\\leq z} f(x,y)dxdy = \\int_{-\\infty}^{+\\infty}dx \\int_{-\\infty}^{z-x}f(x,y)dy\\) \\(\\displaystyle\\xlongequal{y+x=u}\\int_{-\\infty}^{+\\infty}dx\\int_{-\\infty}^{z}f(x,u-x)du=\\int_{-\\infty}^{z}du\\int_{-\\infty}^{+\\infty}f(x,u-x)dx\\) 事实上，\\(\\displaystyle \\int_{-\\infty}^{+\\infty}f(x,u-x)dx\\) 是关于\\(u\\)的函数，那么有： \\[\\displaystyle f_{Z}(z) = [F_{Z}(z)]_{z}&#39;=\\int_{-\\infty}^{+\\infty}f(x,z-x)dx=\\int_{-\\infty}^{+\\infty}f(z-y,y)dy\\] 此外，函数\\(f(t)\\)与\\(g(t)\\)的卷积\\(f * g\\)就被定义为\\(\\displaystyle(f * g)(t) = \\int_{-\\infty}^{+\\infty}f(t - \\tau)g(\\tau)d\\tau\\)。 求\\(Z=X-Y\\)的概率密度函数 习惯上，当\\(g(X,Y)\\)不关于\\(X,Y\\)对称时，先对\\(x\\)积分，有： \\(\\displaystyle F_{Z}(z)=P\\{Z \\leq z\\} = P\\{X-Y \\leq z\\} = \\iint_{x-y\\leq z} f(x,y)dxdy = \\int_{-\\infty}^{+\\infty}dy\\int_{-\\infty}^{y+z}f(x,y)dx\\) \\(\\displaystyle\\xlongequal{x-y=u}\\int_{-\\infty}^{+\\infty}dy\\int_{-\\infty}^{z}f(u+y,y)du=\\int_{-\\infty}^{z}du\\int_{-\\infty}^{+\\infty}f(u+y,y)dy\\) 同理有： \\[\\displaystyle f_{Z}(z) = [F_{Z}(z)]_{z}&#39;= \\int_{-\\infty}^{+\\infty}f(z+y,y)dy\\] 求\\(Z=XY\\)的概率密度函数 \\[\\displaystyle F_{Z}(z)=P\\{Z \\leq z\\} = P\\{XY \\leq z\\} = \\iint_{xy\\leq z} f(x,y)dxdy\\] 注意到上述积分需要分类讨论，不妨考虑\\(z&gt;0\\)的情况，那么有： \\(\\displaystyle F_{Z}(z) = \\int_{-\\infty}^{0}dx\\int_{\\frac{z}{x}}^{+\\infty}f(x,y)dy+\\int_{0}^{+\\infty}dx\\int_{-\\infty}^{\\frac{z}{x}}f(x,y)dy\\) \\(\\displaystyle=\\int_{-\\infty}^{0}dx\\int_{z}^{-\\infty}f(x,\\frac{u}{x})\\frac{1}{x}du + \\int_{0}^{+\\infty}dx\\int_{-\\infty}^{z}f(x,\\frac{u}{x})du=\\int_{-\\infty}^{z}du\\int_{-\\infty}^{+\\infty}f(x,\\frac{u}{x})\\frac{1}{|x|}dx\\) 上述积分在进行\\(u=xy\\)换元时，一定注意无穷积分限的正负。对于\\(z&lt;0\\)的情况同理，最终得到的结果为： \\[f_{Z}(z) = [F_{Z}(z)]_{z}&#39;= \\displaystyle \\int_{-\\infty}^{+\\infty}f(x,\\frac{z}{x})\\frac{1}{|x|}dx=\\int_{-\\infty}^{+\\infty}f(\\frac{z}{y},y)\\frac{1}{|y|}dy\\] 求\\(Z=\\displaystyle\\frac{X}{Y}\\)的概率密度函数 \\(\\displaystyle F_{Z}(z)=P\\{Z \\leq z\\} = P\\{\\frac{X}{Y} \\leq z\\} = \\iint_{\\frac{x}{y}\\leq z} f(x,y)dxdy\\) 注意到上述积分需要分类讨论，不妨考虑\\(z&gt;0\\)的情况，那么有： \\(\\displaystyle F_{Z}(z) = \\int_{-\\infty}^{0}dy\\int_{yz}^{+\\infty}f(x,y)dx+\\int_{0}^{+\\infty}dy\\int_{-\\infty}^{yz}f(x,y)dx\\) \\(\\displaystyle = \\int_{-\\infty}^{0}dy\\int_{z}^{-\\infty}f(uy,y)ydu+\\int_{0}^{+\\infty}dy\\int_{-\\infty}^{z}f(uy,y)ydu=\\int_{-\\infty}^{z}du\\int_{-\\infty}^{+\\infty}f(uy,y)|y|dy\\) 上述积分在进行\\(\\displaystyle u=\\frac{x}{y}\\)换元时，一定注意无穷积分限的正负。对于\\(z&lt;0\\)的情况同理，最终得到的结果为： \\[f_{Z}(z) = [F_{Z}(z)]_{z}&#39;= \\int_{-\\infty}^{+\\infty}f(yz,y)|y|dy\\] 通用方法 参考17分钟搞定卷积公式，可利用二重积分的换元法求解。 对\\(z = g(x,y)\\)等价变形为\\(x = x(y,z)\\)，作变换\\(\\left\\{\\begin{matrix} x = x(y,z) \\\\ y = y \\end{matrix}\\right.\\)，那么\\(xOy\\)平面上的区域\\(D\\)被变换为\\(yOz\\)平面上的区域\\(D&#39;\\)，则： \\[\\iint_{D} f(x,y) dxdy = \\iint_{D&#39;}f(x(y,z),y)|J|dydz\\] 其中，\\(J = \\left|\\begin{matrix} \\displaystyle \\frac{\\partial x}{\\partial y} \\frac{\\partial x}{\\partial z} \\\\ \\displaystyle \\frac{\\partial y}{\\partial y} \\frac{\\partial y}{\\partial z} \\end{matrix}\\right|\\)，为雅可比行列式。 此时令\\(D=R^2\\)有： \\[\\iint_{D&#39;}f(x(y,z),y)|\\frac{\\partial x}{\\partial z}|dydz=1\\] 可知\\(\\displaystyle f(x(y,z),y)|\\frac{\\partial x}{\\partial z}|\\)是二维随机变量\\((Y,Z)\\)的联合概率密度，那么： \\[\\displaystyle f_{Z}(z) = \\int_{-\\infty}^{+\\infty}f(x(y,z),y)|\\frac{\\partial x}{\\partial z}|dy\\] 常见一维随机变量分布的分布律/概率密度函数、期望和方差以及关系 上表中一维随机变量分布的期望和方差的计算过程 计算时善用常用积分值、裂项和方差定义\\(D(X) = E(X^2)-[E(X)]^2\\)。 伯努利分布 根据定义结论显然。 二项分布 设\\(X\\sim B(n,p)\\)，那么： \\(E(X) = \\displaystyle \\sum_{i}x_i P\\{X = x_i\\}=\\sum_{i=0}^{n}i C_{n}^{i}p^i(1-p)^{n-i} = \\sum_{i=1}^{n}i \\frac{n!}{i!(n-i)!} p^i(1-p)^{n-i}\\) \\(\\displaystyle= np\\sum_{i=1}^{n}\\frac{(n-1)!}{(i-1)!(n-i)!}p^{i-1}(1-p)^{n-i} \\xlongequal{j = i - 1} np\\sum_{j=0}^{n-1}C_{n-1}^{j}p^j(1-p)^{n-1-j}=np\\) 计算\\(E(X^2)\\)时，可以利用恒等式\\(i^2=i(i-1) + i\\)： \\(E(X^2) = \\displaystyle \\sum_{i}x_i P\\{X = x_i\\}=\\sum_{i=0}^{n}i^2 C_{n}^{i}p^i(1-p)^{n-i} = \\sum_{i=1}^{n}C_{n-1}^{i-1}p^{i-1}(1-p)^{n-i} + \\sum\\frac{i(i-1)n!}{i!(n-i)!}p^i(1-p)^{n-i}\\) \\(= E(X) + n(n-1)p^2\\) 那么\\(D(X) = E(X^2)-[E(X)]^2 = np(1-p)\\)。 事实上，还有另外一种求解方法。设随机变量\\(X_i=\\left\\{\\begin{matrix}1,\\text{第}i\\text{次实验成功} \\\\ 0,\\text{否则} \\end{matrix}\\right. ,i \\in \\{1,2,\\cdots,n\\}\\)，显然各\\(X_i\\)独立同分布且\\(X_1 \\sim B(1,p)\\)，由伯努利分布的性质及期望的性质显而易见：\\(E(X) = np,D(X)=np(1-p)\\)。 帕斯卡分布和几何分布 由于几何分布是帕斯卡分布的特例，因此可以直接求解帕斯卡分布的期望和方差，设\\(X\\sim NB(r,p)\\)，那么： \\[E(X) = \\displaystyle \\sum_{k=r}^{\\infty}kC_{k-1}^{r-1}p^r(1-p)^{k-r}=\\frac{r}{p}\\sum_{k=r+1}^{\\infty}C_{k-1}^{(r+1)-1}p^{r+1}(1-p)^{k-r}=\\frac{r}{p}\\] 仿照上式可以求解\\(E(X^2)\\)为： \\(E(X^2) = \\displaystyle \\sum_{k=r}^{\\infty}k^2C_{k-1}^{r-1}p^r(1-p)^{k-r}=\\sum_{k=r}^{\\infty}(k+1)kC_{k-1}^{r-1}p^r(1-p)^{k-r} - E(X)\\) \\(\\displaystyle =\\frac{r(r+2)}{p^2} \\sum_{k=r+2} C_{k-1}^{(r+2)-1}p^{r+2}(1-p)^{k-r} - E(X) =\\frac{r^2 + (1-p)r}{p^2} \\Rightarrow D(X) = \\frac{r(1-p)}{p^2}\\) 此外，还可以利用幂级数求解。 令\\(r=1\\)可知几何分布的期望和方差分别为\\(\\displaystyle \\frac{1}{p}\\)和\\(\\displaystyle \\frac{1-p}{p^2}\\)。 泊松分布 设\\(X\\sim P(\\lambda)\\)，那么： \\[E(X) = \\displaystyle\\sum_{n=0}^{\\infty}n\\frac{\\lambda^n}{n!}e^{-\\lambda}=\\lambda \\sum_{n-1=0}^{\\infty}\\frac{\\lambda^{n-1}}{(n-1)!}e^{-\\lambda}=\\lambda\\] \\[E(X^2)=\\displaystyle\\sum_{n=0}^{\\infty}n^2\\frac{\\lambda^n}{n!}e^{-\\lambda}=\\sum_{n-2=0}^{\\infty}\\frac{\\lambda^n}{(n-2)!}e^{-\\lambda}+E(X)=\\lambda^2+\\lambda \\Rightarrow D(X) = \\lambda\\] 均匀分布 设\\(X\\sim U(a,b)\\)，那么： \\[E(X) = \\displaystyle \\frac{1}{b-a}\\int_{a}^{b}xdx=\\frac{a+b}{2}\\] \\[E(X^2) = \\displaystyle \\frac{1}{b-a} \\int_{a}^{b}x^2dx=\\frac{a^2+ab+b^2}{3} \\] \\[D(X) = E(X^2)-[E(X)^2]=\\displaystyle \\frac{(b-a)^2}{12}\\] 正态分布 设\\(X\\sim N(\\mu,\\sigma^2)\\)，那么： \\[\\displaystyle E(X) = \\int_{-\\infty}^{+\\infty}xf_{X}(x)dx=\\int_{-\\infty}^{+\\infty}\\frac{x}{\\sqrt{2\\pi}\\sigma}e^{\\frac{(x-\\mu)^2}{2\\sigma^2}}dx\\xlongequal{t=\\frac{x-\\mu}{\\sigma}}\\int_{=\\infty}^{+\\infty}\\frac{\\mu+\\sigma t}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt=\\mu\\] 同理有： \\[\\displaystyle E(X^2) = \\int_{-\\infty}^{+\\infty}x^2f_{X}(x)dx=\\int_{-\\infty}^{+\\infty}\\frac{x}{\\sqrt{2\\pi}\\sigma}e^{\\frac{(x-\\mu)^2}{2\\sigma^2}}dx\\xlongequal{t=\\frac{x-\\mu}{\\sigma}}\\int_{=\\infty}^{+\\infty}\\frac{(\\mu+\\sigma t)^2}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt=\\mu^2+\\sigma^2\\] 最终有：\\(E(X)=\\mu,D(X)=\\sigma\\)。 求解正态分布相关的积分时，有如下常用结论。 \\(\\displaystyle \\int_{0}^{+\\infty}x^ne^{-\\lambda x}dx = \\frac{n!}{\\lambda^{n+1}}, n\\in \\text{N}, \\lambda &gt; 0\\) \\(\\displaystyle \\int_{-\\infty}^{+\\infty}\\frac{x^n}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}dx=\\left\\{\\begin{matrix}(n-1)!!,n\\text{为偶数} \\\\ 0,\\text{n为奇数} \\end{matrix}\\right.\\) 指数分布 设\\(X\\sim E(\\lambda)\\)，利用关于\\(e^{-x}\\)的反常积分的性质易得\\(\\displaystyle E(X) = \\frac{1}{\\lambda}, E(X^2)=\\frac{2}{\\lambda^2}\\Rightarrow D(X) = \\frac{1}{\\lambda^2}\\)。 瑞利分布 设\\(X\\sim R(\\lambda)\\)，利用标准正态分布的\\(n\\)阶原点矩的结果有： \\[E(X) = \\displaystyle \\sqrt{2\\pi} \\sigma \\int_{0}^{+\\infty}(\\frac{x}{\\sigma})^2\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{x}{\\sigma})^2}d(\\frac{x}{\\sigma}) = \\sqrt{\\frac{\\pi}{2}}\\sigma\\] 再利用关于\\(e^{-x}\\)的反常积分的性质得： \\[E(X^2)=\\displaystyle \\int_{0}^{+\\infty}\\frac{x^2}{\\sigma^2}e^{-\\frac{x^2}{2\\sigma^2}}d(\\frac{x^2}{2}) \\xlongequal{t=x^2}\\frac{1}{2\\sigma^2}\\int_{0}^{+\\infty}t e^{-\\frac{t}{2\\sigma^2}}dt=2\\sigma^2\\] 最终得到\\(D(X) = E(X^2)-[E(X)]^2 = \\displaystyle \\frac{4-\\pi}{2}\\sigma^2\\)。 一维随机变量分布之间的关系 显而易见，伯努利分布是二项分布的特例，二项分布是帕斯卡分布的特例。 若独立同分布的两个随机变量\\(X,Y\\)均服从\\(N(0,\\sigma^2)\\)，那么\\(U = \\displaystyle \\frac{X}{Y}\\)服从柯西分布，\\(V=\\displaystyle \\sqrt{X^2+Y^2}\\)服从瑞利分布，下面给出证明。 \\[f_{U}(u) = \\displaystyle \\int_{-\\infty}^{+\\infty}f(uy,y)|y|dy=\\int_{-\\infty}^{+\\infty}\\frac{1}{2\\pi \\sigma^2} e^{-\\frac{(1+u^2)y^2}{2\\sigma^2}} |y|dy \\xlongequal{t=\\frac{y}{\\frac{\\sigma}{\\sqrt{1+u^2}}}}\\frac{1}{\\pi} \\frac{1}{1+u^2}\\frac{1}{2}\\int_{-\\infty}^{+\\infty}|t|e^{-\\frac{t^2}{2}}dt=\\frac{1}{\\pi} \\frac{1}{1+u^2}\\] 由上式可知\\(U\\sim C(1,0)\\)。 \\(\\displaystyle F_{V}(v) = P\\{V \\leq v\\} = P\\{\\sqrt{X^2+Y^2} &lt; v\\} = \\iint_{\\sqrt{x^2+y^2} &lt; v}f(x,y)dxdy\\) 显然，当\\(v\\leq 0\\)时，\\(F_{V}(v) = 0\\)；当\\(v &gt; 0\\)时有： \\(\\displaystyle F_{V}(v) = \\frac{1}{2\\pi \\sigma^2} \\int_{0}^{2\\pi}d\\theta \\int_{0}^{v} e^{-\\frac{\\rho^2}{2}} \\rho d\\rho=\\frac{1}{\\sigma^2}\\int_{0}^{v}\\rho e^{-\\frac{\\rho^2}{2\\sigma^2}} d\\rho \\Rightarrow f_{V}(v) = \\frac{v}{\\sigma^2}e^{-\\frac{v^2}{2\\sigma^2}}\\) 因而\\(V\\sim R(\\sigma)\\)。 正态分布性质推导 一维正态分布的性质 设\\(X\\sim N(\\mu,\\sigma^2)\\)，那么\\(Y=aX+b\\sim N(a\\mu + b, (a\\sigma)^2),a \\neq 0\\)。这一性质很好证明，当\\(a&gt;0\\)时： \\[F_{Y}(y) = P\\{Y \\leq y\\} = P\\{aX + b \\leq y\\} = P\\{\\displaystyle X \\leq \\frac{y-b}{a} \\}=F_{X}(\\frac{y-b}{a})\\] 那么： \\[f_{Y}(y) = [F_{Y}(y)]&#39;_y = \\frac{1}{a}f_{X}(\\frac{y-b}{a}) = \\displaystyle \\frac{1}{\\sqrt{2\\pi}a\\sigma}e^{-\\frac{[y-(a\\mu+b)]^2}{2(a\\sigma)^2}}\\] 显然\\(Y\\sim N(a\\mu + b, a^2\\sigma^2)\\)，\\(a &lt; 0\\)时同理。 二维正态分布相关的性质 设二维随机变量\\((X,Y)\\sim N(\\mu_1,\\mu_2;\\sigma_1^2,\\sigma_2^2,\\rho)\\)，那么有： \\(X\\sim N(\\mu_1, \\sigma_1)\\)，\\(Y \\sim N(\\mu_2, \\sigma_2)\\)； \\(X\\)与\\(Y\\)不相关\\(\\Leftrightarrow X\\)与\\(Y\\)独立； \\(\\rho_{XY}=\\rho\\)； 设\\(Z = aX+bY+c\\)，那么\\(Z\\sim N(a\\mu_1+b\\mu_2+c, a^2\\sigma_1^2 + 2\\rho ab\\sigma_1\\sigma_2 + b^2\\sigma_2^2)\\)。 服从二维正态分布随机变量的概率密度函数如下所示。 \\[f(x,y)=\\displaystyle \\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}\\exp{\\{-\\frac{1}{2(1-\\rho^2)}[\\frac{(x-\\mu_1)^2}{\\sigma_1^2}-\\frac{2\\rho(x-\\mu_1)(y-\\mu_2)}{\\sigma_1\\sigma_2}+\\frac{(y-\\mu_2)^2}{\\sigma_2^2}]\\}}\\] 首先求解随机变量\\(X\\)的概率密度函数。 \\[\\displaystyle \\int_{-\\infty}^{+\\infty} f(x,y)dy=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\int_{-\\infty}^{+\\infty} \\frac{1}{\\sqrt{2\\pi(1-\\rho^2)}\\sigma_2}\\exp{\\displaystyle\\{-\\frac{1}{2(1-\\rho^2)}[(\\frac{y-\\mu_2}{\\sigma_2}-\\rho\\frac{x-\\mu_1}{\\sigma_1})^2]\\}}dy\\] 令\\(\\displaystyle\\frac{y-\\mu_2}{\\sigma_2}-\\rho\\frac{x-\\mu_1}{\\sigma_1}=t\\)，那么\\(dy=\\sigma_2dt\\)，有： \\[\\displaystyle \\int_{-\\infty}^{+\\infty} f(x,y)dy=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\int_{-\\infty}^{+\\infty}\\frac{1}{\\sqrt{2\\pi}\\sqrt{1-\\rho^2}}e^{-\\frac{t^2}{2(\\sqrt{1-\\rho^2})^2}}dt=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\] 故可得随机变量\\(X\\)的概率密度函数为\\(f_{X}(x)=\\displaystyle \\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\)，同理可得\\(\\displaystyle f_{Y}(y)=\\frac{1}{\\sqrt{2\\pi}\\sigma_2}e^{-\\frac{(y-\\mu_2)^2}{2\\sigma_2^2}}\\)，据此可知\\(f_X(x)\\cdot f_{Y}(y)=f(x,y) \\Leftrightarrow\\rho =0\\)。 此时不妨深入探究\\(\\rho\\)的性质，事实上\\(\\rho\\)是随机变量\\(X\\)与\\(Y\\)的相关系数。对于一般的随机变量而言，相关系数的公式为\\(\\rho=\\displaystyle\\frac{\\text{Cov}(X,Y)}{\\sqrt{D(X)D(Y)}}\\)，又\\(\\text{Cov}(X,Y)=E(XY)-E(X)E(Y)\\)，故可进行计算。 先证明二维随机变量\\((X,Y)\\sim N(\\mu_1,\\mu_2;\\sigma_1^2,\\sigma_2^2,\\rho)\\)时，\\(E(X)=\\mu_1,D(X)=\\sigma_1^2\\)。 \\(E(X)=\\displaystyle\\int_{R^2}xf(x,y)dxdy=\\int_{-\\infty}^{+\\infty}xdx\\int_{-\\infty}^{+\\infty}f(x,y)dy=\\int_{-\\infty}^{+\\infty}xf_{X}(x)dx=\\int_{-\\infty}^{+\\infty}x\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}dx\\) \\(\\xlongequal{t=\\frac{x-\\mu_1}{\\sigma_1}}\\displaystyle \\int_{-\\infty}^{+\\infty}\\frac{\\sigma_1t+\\mu_1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt=\\sigma_1\\int_{-\\infty}^{+\\infty} t\\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{t^2}{2}} dt+\\mu_1\\int_{-\\infty}^{+\\infty} \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{t^2}{2}} dt=\\mu_1\\) \\(E(X^2)=\\displaystyle\\int_{R^2}x^2f(x,y)dxdy=\\int_{-\\infty}^{+\\infty}x^2dx\\int_{-\\infty}^{+\\infty}f(x,y)dy=\\int_{-\\infty}^{+\\infty}x^2f_{X}(x)dx\\) \\(\\displaystyle=\\int_{-\\infty}^{+\\infty}x^2\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}dx\\xlongequal{t=\\frac{x-\\mu_1}{\\sigma_1}}\\displaystyle \\int_{-\\infty}^{+\\infty}\\frac{\\sigma_1^2t^2+2\\sigma_1\\mu_1t+\\mu_1^2}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt\\) \\(\\displaystyle=\\mu_1^2\\int_{-\\infty}^{+\\infty} \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{t^2}{2}} dt + 2\\sigma_1\\mu_1 \\int_{-\\infty}^{+\\infty} t \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{t^2}{2}} dt +\\sigma_1^2\\int_{-\\infty}^{+\\infty} t^2 \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{t^2}{2}} dt\\) 此时不妨求解标准正态分布的\\(n\\)阶原点矩。 \\(I_{2n}=\\displaystyle \\int_{-\\infty}^{+\\infty} t^{2n} \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{t^2}{2}} dt=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}t^{2n-1}d(-e^{-\\frac{t^2}{2}})\\) \\(\\displaystyle=\\frac{1}{\\sqrt{2\\pi}}[-e^{-\\frac{t^2}{2}}t^{2n-1}]_{-\\infty}^{+\\infty}+(2n-1)\\cdot\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}t^{2n-2}e^{-\\frac{t^2}{2}}dt=(2n-1)I_{2n-2}\\) 又\\(I_0=1\\)，故\\(I_{2n}=(2n-1)!!\\Rightarrow I_2=1\\)，最终得到如下结论： 若\\(X\\sim N(0,1)\\)，那么\\(E(X^n)= \\left\\{\\begin{matrix} 0, n \\text{为奇数} \\\\ (n-1)!!, n \\text{为偶数} \\end{matrix}\\right.\\) 所以\\(E(X^2)=\\mu_1^2+\\sigma_1^2\\Rightarrow D(X)=\\sigma_1^2\\)。 接下来需要求解\\(E(XY)\\)，计算可以仿照求解边缘分布密度函数的方法进行。 \\(E(XY)=\\displaystyle\\int_{R^2}xyf(x,y)dxdy=\\int_{-\\infty}^{+\\infty}dx\\int_{-\\infty}^{+\\infty} xy f(x,y)dy\\) 先计算\\(\\displaystyle \\int_{-\\infty}^{+\\infty} xy f(x,y)dy\\)。 \\(\\displaystyle \\int_{-\\infty}^{+\\infty} xy f(x,y)dy=\\frac{x}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\int_{-\\infty}^{+\\infty} \\frac{y}{\\sqrt{2\\pi(1-\\rho^2)}\\sigma_2}\\exp{\\displaystyle\\{-\\frac{1}{2(1-\\rho^2)}[(\\frac{y-\\mu_2}{\\sigma_2}-\\rho\\frac{x-\\mu_1}{\\sigma_1})^2]\\}}dy\\) 令\\(\\displaystyle\\frac{y-\\mu_2}{\\sigma_2}-\\rho\\frac{x-\\mu_1}{\\sigma_1}=t\\)，那么\\(dy=\\sigma_2dt\\)，\\(y=\\sigma_2\\displaystyle t+\\sigma_2\\rho\\frac{x-\\mu_1}{\\sigma_1}+\\mu_2\\)，那么： \\(\\displaystyle \\int_{-\\infty}^{+\\infty} xy f(x,y)dy=\\frac{x}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\int_{-\\infty}^{+\\infty}\\frac{\\sigma_2\\displaystyle t+\\sigma_2\\rho\\frac{x-\\mu_1}{\\sigma_1}+\\mu_2}{\\sqrt{2\\pi}\\sqrt{1-\\rho^2}}e^{-\\frac{t^2}{2(\\sqrt{1-\\rho^2})^2}}dt\\) 再令\\(\\displaystyle u=\\frac{t}{\\sqrt{1-\\rho^2}}\\)，那么： \\(\\displaystyle \\int_{-\\infty}^{+\\infty} xy f(x,y)dy=\\frac{x}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\int_{-\\infty}^{+\\infty}\\frac{\\sigma_2\\sqrt{1-\\rho^2} u+\\sigma_2\\rho\\frac{x-\\mu_1}{\\sigma_1}+\\mu_2}{\\sqrt{2\\pi}}e^{-\\frac{u^2}{2}}du\\) \\(\\displaystyle=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}[\\rho\\frac{\\sigma_2}{\\sigma_1}x^2+(\\mu_2-\\rho\\mu_1\\frac{\\sigma_2}{\\sigma_1})x]e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\) 令\\(v=\\displaystyle\\frac{x-\\mu_1}{\\sigma_1}\\)，那么\\(x=\\sigma_1v+\\mu_1\\)，有： \\(E(XY)=\\displaystyle\\int_{-\\infty}^{+\\infty}\\frac{1}{\\sqrt{2\\pi}\\sigma_1}[\\rho\\frac{\\sigma_2}{\\sigma_1}(\\sigma_1v+\\mu_1)^2+(\\mu_2-\\rho\\mu_1\\frac{\\sigma_2}{\\sigma_1})(\\sigma_1v+\\mu_1)]e^{-\\frac{v^2}{2}}dv=\\rho\\sigma_1\\sigma_2+\\mu_1\\mu_2\\) 上述积分直接计算十分复杂，善用对称性和积分的线性性质能很快得出答案。将\\(E(XY)\\)、\\(E(X)\\)、\\(E(Y)\\)、\\(D(X)\\)和\\(D(Y)\\)的值代入相关系数的计算公式中可知\\(\\rho_{XY}=\\rho\\)，得证。 设\\((X,Y)\\sim N(\\mu_1,\\mu_2;\\sigma_1^2,\\sigma_2^2,\\rho)\\)，那么\\(Z=aX+bY+c\\sim N(a\\mu_1+b\\mu_2+c,a^2\\sigma_1^2+b^2\\sigma_2^2+2\\rho ab\\sigma_1\\sigma_2)\\)，其中\\(\\rho\\)是\\(X,Y\\)的相关系数。该性质的证明过程思路不难，但是计算量极大。 首先进行如下变换： \\[\\displaystyle f_{Z}(z) = \\int_{-\\infty}^{+\\infty}f(x(y,z),y)|\\frac{\\partial x}{\\partial z}|dy=\\frac{1}{|a|}\\int_{-\\infty}^{+\\infty}f(\\frac{z-by-c}{a},y)dy\\] 上式中最复杂的部分是被积函数\\(\\displaystyle f(\\frac{z-by-c}{a},y)\\)，积分变量在函数的两个变量位均有出现。类比前面对二维正态分布边缘分布的概率密度函数求解思路。被积函数的指数部分具有如下形式： \\[\\displaystyle -\\frac{1}{2(1-\\rho^2)}T(y,z)\\] 其中，\\(T(y,z)=\\displaystyle\\frac{[z-by-(c+a\\mu_1)]^2}{(a\\sigma_1)^2}-\\frac{2\\rho}{a\\sigma_1\\sigma_2}[z-by-(c+a\\mu_1)](y-\\mu_2)+\\frac{(y-\\mu_2)^2}{\\sigma_2^2}\\)。下面是该性质证明中最繁琐的一部分，即对积分变量\\(y\\)进行配方，不妨设\\(T(y,z)\\)具有如下形式： \\[T(y,z) = Az^2 + By^2 + Cz + Dy + Eyz + F\\] 然后对\\(T(y,z)\\)进行形式配方，得到如下结果： \\[T(y,z) = \\displaystyle B(y+\\frac{D+Ez}{2B})^2 + (A - \\frac{E^2}{4B})(z+\\frac{2BC - DE}{4AB-E^2})^2+F-\\frac{(2BC-DE)^2}{4B(4AB-E^2)}-\\frac{D^2}{4B}\\] 将\\(T(y,z)\\)展开，得到如下系数表： 系数 值 \\(A\\) \\(\\displaystyle \\frac{1}{a^2\\sigma_1^2}\\) \\(B\\) \\(\\displaystyle \\frac{b^2}{a^2\\sigma_1^2}+\\frac{1}{\\sigma_2^2}+\\frac{2\\rho b}{a\\sigma_1\\sigma_2}\\) \\(C\\) \\(\\displaystyle 2(\\frac{\\rho \\mu_2}{a\\sigma_1\\sigma_2}-\\frac{c+a\\mu_1}{a^2\\sigma_1^2})\\) \\(D\\) \\(\\displaystyle 2[\\frac{\\rho(c+a\\mu_1)}{a\\sigma_1\\sigma_2}+\\frac{b(c+a\\mu_1)}{a^2\\sigma_1^2}-\\frac{\\mu_2}{\\sigma_2^2}-\\frac{\\rho b\\mu_2}{a\\sigma_1\\sigma_2}]\\) \\(E\\) \\(\\displaystyle -2 [\\frac{b}{a^2\\sigma_1^2}+\\frac{\\rho}{a\\sigma_1\\sigma_2}]\\) \\(F\\) \\(\\displaystyle \\frac{(c+a\\mu_1)^2}{a^2\\sigma_1^2}+\\frac{\\mu_2^2}{\\sigma_2^2}-\\frac{2\\rho\\mu_2(c+a\\mu_1)}{a\\sigma_1\\sigma_2}\\) 现在只需要将各项系数代入\\(T(y,z)\\)的表达式中并求解即可，不妨再列一个系数表： 系数 值 \\(\\displaystyle A-\\frac{E^2}{4B}\\) \\(\\displaystyle \\frac{1-\\rho^2}{a^2\\sigma_1^2+b^2\\sigma_2^2+2\\rho ab \\sigma_1\\sigma_2}\\) \\(2BC - DE\\) \\(\\displaystyle -4\\frac{(1-\\rho^2)(a\\mu_1+b\\mu_2+c)}{a^2\\sigma_1^2\\sigma_2^2}\\) \\(4AB-E^2\\) \\(\\displaystyle 4\\frac{(1-\\rho^2)}{a^2\\sigma_1^2\\sigma_2^2}\\) \\(\\displaystyle F-\\frac{(2BC-DE)^2}{4B(4AB-E^2)}-\\frac{D^2}{4B}\\) \\(0\\) \\(B\\) \\(\\displaystyle \\frac{a^2\\sigma_1^2+b^2\\sigma_2^2+2\\rho ab\\sigma_1\\sigma_2}{a^2\\sigma_1^2\\sigma_2^2}\\) 不妨记\\(\\sigma^2 = a^2\\sigma_1^2+b^2\\sigma_2^2+2\\rho ab\\sigma_1\\sigma_2\\)和\\(\\mu = a\\mu_1+b\\mu_2+c\\)，那么\\(B=\\displaystyle \\frac{\\sigma^2}{a^2\\sigma_1^2\\sigma_2^2}\\)，且： \\(\\displaystyle f_{Z}(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{(z-\\mu)^2}{2\\sigma^2}} \\int_{-\\infty}^{+\\infty}\\frac{1}{\\sqrt{2\\pi}\\frac{|a|\\sigma_1\\sigma_2}{\\sigma}\\sqrt{1-\\rho^2}}e^{-\\frac{B(y+\\frac{D+Ez}{2B})^2}{2(1-\\rho^2)}}d(y+\\frac{D+Ez}{2B})\\) \\(\\displaystyle\\xlongequal{t=\\frac{y+\\frac{D+Ez}{2B}}{\\sqrt{\\frac{1-\\rho^2}{B}}}}\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{(z-\\mu)^2}{2\\sigma^2}}\\int_{-\\infty}^{+\\infty}\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{(z-\\mu)^2}{2\\sigma^2}}\\) 原命题得证。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"智能语音技术入门","slug":"ASR入门","date":"2022-12-26T14:45:49.000Z","updated":"2023-01-03T05:23:13.769Z","comments":true,"path":"2022-12-26-ASR入门/","link":"","permalink":"http://example.com/2022-12-26-ASR%E5%85%A5%E9%97%A8/","excerpt":"研究生阶段的主要研究领域，近期在做本科开题报告时深感亟需补充该领域的相关知识，于是有了这篇概述智能语音技术以及近期工作总结的博客。","text":"研究生阶段的主要研究领域，近期在做本科开题报告时深感亟需补充该领域的相关知识，于是有了这篇概述智能语音技术以及近期工作总结的博客。 智能语音技术概述 研究方向 语音识别 唤醒词检测（语音唤醒） 论文阅读 经过师兄的推荐，我主要阅读了以下几篇论文。 环境配置 本地环境 Ubuntu虚拟机/双系统的安装方法 服务器端 服务器整体结构复杂，需要专员维护，作为用户需要了解操作规范以及服务器的环境变量配置和提交任务的方法。 module 的使用 slurm 的使用 WeKWS examples 试运行","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"机器学习/深度学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"语音识别","slug":"机器学习/深度学习/语音识别","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"}],"tags":[]},{"title":"Survive BJTU","slug":"survive-BJTU","date":"2022-11-26T01:08:37.000Z","updated":"2022-12-31T17:57:16.653Z","comments":true,"path":"2022-11-26-survive-BJTU/","link":"","permalink":"http://example.com/2022-11-26-survive-BJTU/","excerpt":"笔者在2022年经历了计算机专业的保研之战，经历了近九个月的精神内耗，期间对大学本科期间的学习、生活和心态等方面有了很多思考。恰逢近日学习效率格外低下，于是决定写一篇随笔，记录自己的所思所想，期望能对读者有些许启发。","text":"笔者在2022年经历了计算机专业的保研之战，经历了近九个月的精神内耗，期间对大学本科期间的学习、生活和心态等方面有了很多思考。恰逢近日学习效率格外低下，于是决定写一篇随笔，记录自己的所思所想，期望能对读者有些许启发。 欢迎来到北京交通大学 欢迎来到北京交通大学！在这里，西直门四通八达的交通和商圈以及海淀三环的便利条件任君享用！家住内蒙古的同学更可享受从东校区（主校区）步行十分钟（二十分钟）到达北京北高铁站之便利！学校中社团丰富，学习氛围浓厚，你可以在这里度过充实的四年。 北京交通大学地理位置 大学时代是人生中犯错成本最低的一段时间，是极其宝贵的一段时光，非常建议大家在本科阶段多尝试自己想做的事情，例如尝试到实验室打杂以接触科研，参与各种各样的学科竞赛，参加各种的学生活动或是学生工作中等等，寻找自己的兴趣所在，为自己的未来负责，在毕业时能有更多的选择。 在本科阶段该做什么 锻炼人际交往能力 人际交往能力是非常重要的：选课需要请教学长学姐；有专业知识问题需要请教老师；有需要合作的事情需要良好的组内沟通；保研过程中需要与院校、导师等各方取得联系……这些过程中都需要良好的人际交往能力；而在步入社会后，这更是一项不可或缺的能力。 好好学习 本科阶段的毕业去向大致为三类： 国内深造（考研、学习保研、工作保研）； 出国留学（专业选择、国家选择）； 就业求职（创业、公务员、国企、私企、自由职业）。 以上三条道路中都需要强大的学习能力和扎实的专业知识，因此我建议本科期间一定要把学习搞好，理由还包括但不限于如下几点： 年轻时期是人脑力的巅峰时期，并且其他方面的压力较小，可以较为专心地投入到学习中； 大学毕业出路大致包括继续深造和直接就业，前者要求本科有亮眼的成绩和一定的科研竞赛经历，后者则要求有丰富的实践经历及相对扎实的专业知识基础，不论哪条都对学习有着较高的要求； 多掌握一些知识对于塑造三观有着积极的促进作用，例如学习马原理可以从理论层面对社会有更加深入的认识，学习数学知识可以锻炼逻辑思维能力，学习专业课知识可以锻炼从本专业的角度思考问题的能力； 学习成绩优秀可以获得学习优秀奖学金和学习进步奖学金，据我所知，在获奖等级相同的前提下，学习优秀奖学金是本科生能获得的金额最高的单项奖学金，如果某一学年获评一等学习优秀奖学金，你甚至可以参与国家奖学金等专项奖学金的评选，这笔奖学金对大部分同学来说是非常可观的一笔收入，更是一种激励。 请格外注意：这里的以学业为重不是一味地卷绩点、加权，同时也要重视知识的掌握程度，掌握的知识技能才是毕业后安身立命之本。本科毕业后，绩点的作用也几乎仅限于敲门砖。 然而想要在本科四年时间充分地学习并非易事。本科教学中就存在各种各样的问题，本文标题名即取自上海交通大学生存手册，我也非常建议大家阅读这本电子书，以下这段话就取自该书的立志篇——欢迎来到上海交通大学。 各位同学们，在本书的开始，我不得不遗憾地告诉大家一个消息。国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。在此，我无意争论是否复旦、中科大，或者清华、北大是否比我们崩溃的更少一些——这种争论是没有意义的。我只是看到了无数充满求知欲、激情、与年轻梦想的同学们，将要把自己的四年青春，充满希望与信任地交给大学来塑造。这使我心中非常不安。 在当今流水线式的教育体制下，我们就像廉价的零件一样被生产出来。因为数量巨大，没人会对每一个人的教学质量负责。 每个人的情况各异，适合的学习方法也不尽相同，尽管如此，大学却对一群人采取了相同的培养方案，其结果可想而知；此外，教学方面的激励严重不足，这也是本科教学质量参差不齐的一个原因。在此强烈建议大家培养自己的自学能力，掌握收集信息、处理信息的能力，采用合理的方式应对课程中可能存在的不合理要求。 此外，如果学有余力强烈建议多参与本学科含金量较高的学科竞赛，以笔者所在的计算机专业为例，个人比较推荐参加算法竞赛，例如ICPC、CCPC等，可以尝试在学习C、STL以及数据结构之后参加校队试试水。另外，尝试参加大创体验下科研也是不错的选择，北交和计算所还有合作的计算菁英班，该班可以提供在计算所老师课题组实践的经历，可以提前了解到计算所的一些情况。 培养良好的心态 学业是本科期间非常重要的一项内容，而调整心态，以积极乐观的心态度过每一天则是另一项同等重要甚至更重要的事情。令我感受最深的一段时间大抵是今年6月中旬开始的夏令营报名直到9月28日在推免系统完成填报这段时间。 6月中旬夏令营报名时正赶上大三下学期的期末考试，摆烂式的学习更使得情况雪上加霜。面对期末考试和夏令营两头不能耽误的情况，我选择将需要做的事情按重要性、时效性两个维度进行了划分，依次处理各项事务，事实证明，有效地忙碌起来是缓解焦虑的最好方法。 期末考试结束后，我陆续收到了申请的几所大学的夏令营通知。由于前五个学期总体的学习效果尚可，外加第六学期期末考试复习也将平时的散漫补了回来，第一个夏令营开营之前的约两周时间我过得相对轻松，主要在进行专业课的查缺补漏和英语口语的准备。事实上，自这时起到八月底，我几乎一直都在焦虑，总是担心自己没能去到理想的学校，或是遇到其他问题。为此，我确实搜集了大量信息，在七月份中旬所有的夏令营结束后，笔者将知乎上近三年计算机专业的保研贴几乎看了个遍，并且向包括家人、老师、学长学姐、同学、朋友和学弟学妹请教了不少问题，在此非常感谢热心分享宝贵经验的网友，也感谢一路上鼎力相助的各位！然而，这个过程中，我几乎日日都因胡思乱想吃不好饭，睡不好觉，严重影响了生活的质量，甚至在夏令营结束后依然如此，几乎是煎熬着度过了七月中旬到八月底的这段时间。在人生的关键节点上对未来感到迷茫而焦虑是正常的，然而人生不光有未来，更重要的是当下，过好当下是展望未来的前提。事后看来我确实是虚度了这六个星期，就算学习学不进去，打会儿游戏放松一下也好，只能说追悔莫及。八月底基本确定院校后，通过九月份的积极联系，我最终得到了一位导师的认可，悬着的心终于放了下来。 对我来说，2022年六月份到九月份这四个月是决定近几年人生发展方向的重要时间节点，在这样的时间中保持紧张的心态是有好处的。然而，正如我前文所言，活好当下同样是一件大事，人活着一天就应当保持快乐的心情一天，有很多事情是主观行动难以改变的。倘若我能牢记谋事在人，成事在天，多做些自己能做的事情，尽量减少无谓的焦虑，今年的四个月或许会过得不那么痛苦。 随着步入社会，我们面临的压力大概率会越来越大，面对的事情越来越繁杂，并且难以改变大环境，因而在当下培养良好的心态是非常重要的。 我的本科生活 一言以蔽之，就是卷保研。 写在前面 这一节的内容并非劝大家都来卷成绩和加分。本科毕业的出路远不局限于国内深造，还可以选择出国留学（需要家里提供一定的经济支持，或者到留学开销较小的国家）、直接工作等等，每一条道路对个人的要求都是有很大不同的。希望大家对自己的未来负责，根据自身情况、学校平台的资源和时代发展需要等因素选择最适合自己的发展道路。这里的最之所以加了引号是因为，我们在人生道路的分叉口处不能以上帝视角做出选择，换言之：一个人的视野终究是局限的，一个人的需求总是动态变化的。我们能做的是立足当下，做好可及的未来的需求分析，罗列所有的可选项——前提是这些可选项真的可选，在其中选出最适合自己的一条路。举例而言，我在人生道路关键节点遵循的原则之一是选择能为未来留下更多可能性的道路。 此外还建议大家摆正心态，尽量不要抱着“高考发挥不好，在大学一定要卷赢”这种心态度过整个本科阶段。大学的评价指标比高中丰富了不少，学习成绩只是一个方面，不要用一个（些）数字定义自己，没有任何人能定义你自己，除了你自己。 本科学习 入学时我就对学生手册中保研政策进行了研究，确定了努力的大致方向。其次需要了解培养方案的要求，以2019级计算机科学与技术专业的培养方案为例，个人认为其中关键的课程是数学课、专业核心课与专业选修课，理由有如下几点： 这三部分的绩点很高； 数学课是计算机软件的基础，有能力者甚至可以多学几门，例如凸优化理论（机器学习中非常有用）、复变函数（信号与系统的先修课，对于语音处理研究方向很重要）等； 专业核心课是计算机专业的基础课程，对于从理论层面理解计算机有着不可替代的作用，必须学好； 专业选修课可以拓展视野，并且选课时需要谨慎选择。 在明确努力的方向后，剩下的就是持之以恒的努力以及丰富的信息获取渠道了。 此外，竞赛和大创等是锦上添花的项目，学有余力的同学可以根据自己的实际情况参与。 保研经历 笔者在2022年9月初就完成了一篇计算机专业的保研经验贴：2022年夏令营/2023届计算机专业保研相关经验教训分享。 在这里我不打算详细介绍心路历程的变化，笔者只想说明两点： 保研是一个不断怀疑自己的过程，这一过程充满曲折与各种各样意料之中、意料之外的困难，需要个人拥有良好的心态； 保研是一场信息战，选择和努力同样重要。 后记 推荐WYX大佬的重新规划大学低年级生活这篇博客，里面详细介绍了部分课程的重要性、学习方法以及注意事项。 总结 （本来计划着11月就把这篇随笔写完，结果硬生生拖到了12月31日……） 以上就是我在本科期间的一些经验之谈。请注意这些只是我的一家之言，如内容有偏颇或错误欢迎批评指出，也欢迎各种各样的交流讨论！ 祝2023年新年快乐！ 2022年12月31日","categories":[{"name":"essays","slug":"essays","permalink":"http://example.com/categories/essays/"}],"tags":[]},{"title":"PyTorch 框架入门","slug":"PyTorch框架入门","date":"2022-11-13T13:43:02.000Z","updated":"2023-01-03T05:30:33.271Z","comments":true,"path":"2022-11-13-PyTorch框架入门/","link":"","permalink":"http://example.com/2022-11-13-PyTorch%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/","excerpt":"记录一下入门 PyTorch 时所写的一些代码。","text":"记录一下入门 PyTorch 时所写的一些代码。 Anaconda 环境配置 VS Code 配置 工欲善其事，必先利其器。我最终选择 VS Code 作为开发环境，原因很简单，该开发环境需要自行配置，自由度高且占用存储空间小。 想让命令行启动时就激活指定的 Anaconda 环境，结果总是多启动一次环境，导致新建终端速度太慢。倒腾了半天发现查看默认配置有哪些选项是好文明。 1234567891011121314151617181920212223&#123; &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Command Prompt&quot;, &quot;terminal.integrated.profiles.windows&quot;: &#123; &quot;PowerShell&quot;: &#123; &quot;source&quot;: &quot;PowerShell&quot;, &quot;icon&quot;: &quot;terminal-powershell&quot; &#125;, &quot;Command Prompt&quot;: &#123; &quot;path&quot;: [ &quot;$&#123;env:windir&#125;\\\\System32\\\\cmd.exe&quot;, &quot;$&#123;env:windir&#125;\\\\Sysnative\\\\cmd.exe&quot; ], &quot;args&quot;: [&quot;/k&quot;, &quot;conda activate py37&quot;], &quot;icon&quot;: &quot;terminal-cmd&quot; &#125;, &quot;Git Bash&quot;: &#123; &quot;source&quot;: &quot;Git Bash&quot; &#125; &#125;, &quot;python.condaPath&quot;: &quot;D:\\\\Anaconda3\\\\Scripts\\\\conda.exe&quot;, &quot;editor.renderLineHighlight&quot;: &quot;all&quot;, &quot;python.terminal.activateEnvironment&quot;: false, // set this configuration to false&#125; 梯度下降法 以下代码是基于 NumPy 实现的梯度下降法使用四次函数拟合余弦函数的实例。 1234567891011121314151617181920212223242526272829303132import numpy as npimport matplotlib.pyplot as pltimport mathf = np.cosx = np.linspace(-math.pi / 4, math.pi / 4, 2000)y = f(x)a = 1b = -10c = 20learning_rate = 1e-3for _ in range(4000): y_pred = a + b * x ** 2 + c * x ** 4 loss = np.square(y_pred - y).sum() if _ % 100 == 99: print(f&#x27;Epoch &#123;_&#125;, MSE Loss: &#123;loss&#125;.&#x27;) grad_y_pred = 2 * (y_pred - y) grad_b = (grad_y_pred * x ** 2).sum() grad_c = (grad_y_pred * x ** 4).sum() b -= grad_b * learning_rate c -= grad_c * learning_ratey_pred = a + b * x ** 2 + c * x ** 4plt.plot(x, y, &#x27;g&#x27;)plt.plot(x, y_pred, &#x27;r&#x27;)plt.legend(labels=(&quot;y = cos x&quot;, f&quot;1+&#123;b&#125;x^2+&#123;c&#125;x^4&quot;))plt.show() 使用简单的神经网络在 MINST 数据集上进行训练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import matplotlib.pyplot as pltimport torchimport torch.nn as nnimport torchvisionfrom torch.utils.data import DataLoaderbatch_size = 64train_loss = []# two dataloader instancetrain_dataloader = DataLoader( torchvision.datasets.MNIST( &#x27;./data/&#x27;, train=True, download=False, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,) ) ]) ), batch_size=batch_size, shuffle=True)test_dataloader = DataLoader( torchvision.datasets.MNIST( &#x27;./data/&#x27;, train=False, download=False, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,) ) ]) ), batch_size=batch_size, shuffle=True)device = &quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;# remember to implement class torch.nn.Moduleclass NeuralNetwork(nn.Module): def __init__(self): super().__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10) ) def forward(self, x): x = self.flatten(x) return self.linear_relu_stack(x)model = NeuralNetwork().to(device)print(model)def train(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) model.train() for batch, (X, y) in enumerate(dataloader): X, y = X.to(device), y.to(device) &#x27;&#x27;&#x27; here model is called, see module.py(line 1124) for more detail about implementation of call &#x27;&#x27;&#x27; pred = model(X) loss = loss_fn(pred, y) optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: # .item() for those tensors with only one component loss, current = loss.item(), batch * len(X) train_loss.append(loss) print(f&quot;loss: &#123;loss:&gt;7f&#125; [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;)def test(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) model.eval() test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: X, y = X.to(device), y.to(device) pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;)loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)epochs = 5for t in range(epochs): print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;) train(train_dataloader, model, loss_fn, optimizer) test(test_dataloader, model, loss_fn)plt.plot([100 * (i + 1) for i in range(len(train_loss))], train_loss, &#x27;r&#x27;)plt.title(&#x27;Train Loss&#x27;)plt.show() 一些常见的神经网络的实现 参考资料 PyTorch","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"算法日常练习8","slug":"算法日常练习8","date":"2022-10-19T12:45:19.000Z","updated":"2022-10-19T13:35:28.670Z","comments":true,"path":"2022-10-19-算法日常练习8/","link":"","permalink":"http://example.com/2022-10-19-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A08/","excerpt":"2022年10月19日练习。","text":"2022年10月19日练习。 BJTU-ALGO 2148 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MOD = 1e9 + 7;vector&lt;vector&lt;int&gt;&gt; operator*(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123; int n = A.size(); vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; long long temp = (long long)A[i][j] * B[j][k] % MOD; ans[i][k] = (temp + ans[i][k]) % MOD; &#125; &#125; &#125; return ans;&#125;vector&lt;vector&lt;int&gt;&gt; fast_pow(vector&lt;vector&lt;int&gt;&gt; &amp;x, int y) &#123; vector&lt;vector&lt;int&gt;&gt; ans(x.size(), vector&lt;int&gt;(x.size(), 0)), xx(x); for (int i = 0; i &lt; x.size(); i++) ans[i][i] = 1; while (y) &#123; if (y &amp; 1) ans = ans * xx; xx = xx * xx; y &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; src(n, vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; src[i][j]; &#125; &#125; auto ans = fast_pow(src, m); for (auto&amp; arr : ans) &#123; for (auto&amp; i : arr) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; &#125; return 0;&#125; BJTU-ALGO 2095 实在没想到这个题暴搜就能过。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m;int ans = 0;vector&lt;vector&lt;int&gt;&gt; arr;int fast_pow(int x, int y) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) ans *= x; x *= x; y &gt;&gt;= 1; &#125; return ans;&#125;void dfs(int cur_depth, int cur_sum) &#123; if (cur_depth == n) &#123; if (cur_sum == 0) ans++; return; &#125; for (int i = 1; i &lt;= m; i++) &#123; dfs(cur_depth + 1, cur_sum + fast_pow(i, arr[cur_depth][1]) * arr[cur_depth][0]); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; arr.resize(n, vector&lt;int&gt;(2)); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i][0] &gt;&gt; arr[i][1]; &#125; dfs(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; BJTU-ALGO 2001 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n; while (cin &gt;&gt; n) &#123; if (n == 1) &#123; int a; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; continue; &#125; vector&lt;int&gt; arr(n + 1); for (auto&amp; i : arr) cin &gt;&gt; i; if (arr[0] == -1 || arr[0] == 1) &#123; if (arr[0] == -1) cout &lt;&lt; &#x27;-&#x27;; &#125; else cout &lt;&lt; arr[0]; if (n == 1) cout &lt;&lt; &#x27;x&#x27;; else cout &lt;&lt; &quot;x^&quot; &lt;&lt; n; for (int i = 1; i &lt;= n; i++) &#123; if (arr[i] == 0) continue; else if (arr[i] == 1 || arr[i] == -1) &#123; cout &lt;&lt; (arr[i] == -1 ? &#x27;-&#x27; : &#x27;+&#x27;); if (i == n) &#123; cout &lt;&lt; abs(arr[i]); continue; &#125; &#125; else &#123; if (arr[i] &lt; 0) cout &lt;&lt; arr[i]; else cout &lt;&lt; &#x27;+&#x27; &lt;&lt; arr[i]; if (i == n) continue; &#125; if (i == n - 1) cout &lt;&lt; &#x27;x&#x27;; else cout &lt;&lt; &quot;x^&quot; &lt;&lt; n - i; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; BJTU-ALGO 1024 比较坑的一点是需要先把 \\(n\\) 放到循环节判断的集合里面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;int get_digs(ll src) &#123; int ans = 0; do ans++; while (src /= 10); return ans;&#125;ll get_r(ll src, int digs) &#123; ll ans = 0; vector&lt;int&gt; nums; for (int i = 0; i &lt; digs; i++) &#123; nums.push_back(src % 10); src /= 10; &#125; ll base = 1; for (int i = nums.size() - 1; i &gt;= 0; i--, base *= 10) &#123; ans += nums[i] * base; &#125; return ans;&#125;ll get_l(ll src, int digs) &#123; ll ans = 0; vector&lt;int&gt; nums; for (int i = 0; i &lt; digs; i++) &#123; nums.push_back(src % 10); src /= 10; &#125; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); ll base = 1; for (int i = nums.size() - 1; i &gt;= 0; i--, base *= 10) &#123; ans += nums[i] * base; &#125; return ans;&#125;int main() &#123; ll n; while (cin &gt;&gt; n) &#123; int digs = get_digs(n); vector&lt;ll&gt; nums&#123;n&#125;; set &lt;ll&gt; s&#123;n&#125;; ll l = get_l(n, digs), r = get_r(l, digs), cur = l - r; while (!s.count(cur)) &#123; nums.push_back(cur); s.insert(cur); l = get_l(cur, digs), r = get_r(l, digs), cur = l - r; &#125; int i = 0; while (i &lt; nums.size() &amp;&amp; nums[i] != cur) i++; for (; i &lt; nums.size(); i++) &#123; cout &lt;&lt; nums[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"积分题目1","slug":"积分题目1","date":"2022-10-16T06:48:36.000Z","updated":"2023-01-03T08:45:42.517Z","comments":true,"path":"2022-10-16-积分题目1/","link":"","permalink":"http://example.com/2022-10-16-%E7%A7%AF%E5%88%86%E9%A2%98%E7%9B%AE1/","excerpt":"这篇博客用于记录一些比较有趣的积分问题。","text":"这篇博客用于记录一些比较有趣的积分问题。 求\\(\\displaystyle I = \\int \\frac{1-\\ln x}{(x- \\ln x)^2} dx\\) \\[I =\\displaystyle \\int \\frac{\\displaystyle \\frac{1-\\ln x}{x^2}}{(1 - \\displaystyle \\frac{\\ln x}{x})^2} = \\int- \\frac{ d(1 -\\displaystyle \\frac{\\ln x}{x})}{(1 - \\displaystyle \\frac{\\ln x}{x})^2} = \\frac{x}{x - \\ln x} + C \\] 使用类似的方法还可以求解有下面的三个积分。 求\\(I = \\displaystyle \\int \\frac{\\sin^2 x}{(x\\cos x -\\sin x)^2} dx\\) 注意到\\(\\displaystyle \\int x \\sin x dx = \\sin x - x \\cos x + C\\)。 \\[I = \\displaystyle \\int \\frac{\\sin x}{x} \\cdot \\frac{x \\sin x}{(x \\cos x - \\sin x)^2} dx = \\int \\frac{\\sin x}{x} d(\\frac{1}{x \\cos x - \\sin x}) = \\frac{\\cos x}{x \\cos x - \\sin x} + C\\] 求\\(I = \\displaystyle \\int \\frac{xe^x}{(1+x)^2} dx\\) \\[I = \\displaystyle \\int \\frac{\\displaystyle \\frac{x}{e^x}}{(\\displaystyle\\frac{1+x}{e^x})^2} dx = \\int - \\frac{d(\\displaystyle\\frac{1+x}{e^x})}{\\displaystyle(\\frac{1+x}{e^x})^2} = \\frac{e^x}{1+x} + C\\] 求\\(I = \\displaystyle \\int \\frac{\\cos x + x \\sin x}{(x + \\cos x) ^ 2}\\) \\[I = \\displaystyle \\int \\frac{\\displaystyle \\frac{\\cos x + x \\sin x}{x^2}}{(\\displaystyle 1 + \\frac{\\cos x}{x})^2}dx = \\int - \\frac{d(\\displaystyle 1 + \\frac{\\cos x}{x})}{(\\displaystyle 1 + \\frac{\\cos x}{x})^2} = \\frac{x}{x + \\cos x} + C\\] 求\\(\\displaystyle I = -\\frac{2}{3} \\int \\frac{dx}{\\sqrt[3]{(x+1)^2(x-1)^4}}\\) 注意到\\(\\displaystyle (\\sqrt[3]{\\frac{x+1}{x-1}})&#39; = \\frac{1}{\\sqrt[3]{(x+1)^2(x-1)^4}}\\)。 \\[I = \\displaystyle -\\frac{3}{2} \\sqrt[3]{\\frac{x+1}{x-1}} + C\\] 事实上，不难发现以下结果。 \\[\\displaystyle (\\sqrt[n]{\\frac{x+1}{x-1}})&#39; = -\\frac{2}{n} \\frac{1}{\\sqrt[n]{(x+1)^{n-1}(x-1)^{n+1}}}\\] \\[\\displaystyle (\\sqrt[n]{\\frac{x-1}{x+1}})&#39; = \\frac{2}{n} \\frac{1}{\\sqrt[n]{(x-1)^{n-1}(x+1)^{n+1}}}\\] 求\\(I = \\displaystyle \\int x^2 e^{\\frac{x^2}{2} - x}dx\\) \\[\\displaystyle I = \\int [(x-1)^2+2(x-1)+1]e^{\\frac{x^2}{2}-x}dx = \\int (x-1)d(e^{\\frac{x^2}{2}-x}) + 2e^{\\frac{x^2}{2}-x} + \\int e^{\\frac{x^2}{2}-x}dx = (x+1)e^{\\frac{x^2}{2}-x} + C\\] 求\\(I = \\displaystyle \\int e^{\\sin x}\\frac{x \\cos^3 x - \\sin x}{\\cos^2 x}\\) \\[I = \\displaystyle \\int e^{\\sin x} x\\cos x dx - \\int e^{\\sin x} \\frac{\\sin x}{\\cos^2 x} dx = \\int x d(e^{\\sin x}) - \\int e^{\\sin x}d(\\frac{1}{\\cos x}) = e^{\\sin x}(x - \\frac{1}{\\cos x}) + C\\] 求\\(I= \\displaystyle \\int_{0}^{1} \\ln x \\cdot \\ln (1-x) dx\\) 题目求解 根据\\(\\ln(1-x) = -\\displaystyle\\sum_{n=1}^{\\infty}\\frac{x^n}{n},x\\in(-1,1]\\)可得\\(I=\\displaystyle-\\int_0^1\\sum_{n=1}^{\\infty}\\frac{x^n}{n}\\ln x=-\\sum_{n=1}^{\\infty}\\frac{1}{n}\\int_0^1 x^n \\ln xdx\\)。 而\\(\\displaystyle \\int_0^1 x^n \\ln x dx {\\xlongequal{\\ln x = -t}}-\\int_0^{+\\infty} te^{-(n+1)t}dt=-\\frac{1}{(n+1)^2}\\)，故\\(I=\\displaystyle\\sum_{n=1}^{\\infty}\\frac{1}{n(n+1)^2}\\)。 对于最后一步的级数，可以使用有理函数的拆分得到\\(I=\\displaystyle\\sum_{n=1}^{\\infty}(\\frac{1}{n}-\\frac{1}{n+1})-\\sum_{n=1}^{\\infty}\\frac{1}{(n+1)^2}\\)，前者通过裂项相消可得\\(\\displaystyle\\sum_{n=1}^{\\infty}(\\frac{1}{n}-\\frac{1}{n+1})=1\\)，而后者可以通过巴塞尔级数求解，最终得到\\(I=2-\\displaystyle\\frac{\\pi^2}{6}\\)。 相关知识 Fubini's Theorem 若\\(\\displaystyle\\int_{A \\times B}|f(x,y)|d(x,y)&lt;\\infty\\)，其中积分是关于空间\\(A \\times B\\)的积测度，且\\(A\\)和\\(B\\)都是\\(\\sigma\\)-有限测度空间，那么有\\(\\displaystyle\\int_A(\\int_B f(x,y)dy)dx=\\int_B(\\int_A f(x,y)dx)dy=\\int_{A \\times B}|f(x,y)|d(x,y)\\)，前二者是在两个测度空间上的逐次积分, 但积分次序不同; 第三个是在乘积空间上关于乘积测度的积分。 特别地，如果\\(f(x,y)=h(x)g(x)\\)，那么\\(\\displaystyle \\int_A h(x)dx\\int_Bg(y)dy=\\int_{A \\times B}|f(x,y)|d(x,y)\\)。注意，如果条件中绝对值积分值不是有限，那么上述两个逐次积分的值可能不同。 巴塞尔级数 即\\(\\displaystyle \\sum_{n=1}^{\\infty}\\frac{1}{n^2}=\\frac{\\pi^2}{6}\\)，证明方法有很多种，在此不再赘述。 常见函数的幂级数 具体推导详见另一篇博客，这里只给出公式。 \\[\\sin x= \\displaystyle \\sum_{n=0}^{\\infty}(-1)^n\\frac{x^{2n+1}}{(2n+1)!},x\\in(-\\infty,+\\infty)\\] \\[\\cos x= \\displaystyle \\sum_{n=0}^{\\infty}(-1)^n\\frac{x^{2n}}{(2n)!},x\\in(-\\infty,+\\infty)\\] \\[e^x = \\displaystyle\\sum_{n=0}^{\\infty}\\frac{x^n}{n!},x\\in(-\\infty,+\\infty)\\] \\[\\displaystyle\\frac{1}{1-x}=\\sum_{n=0}^{\\infty}x^{n},|x|&lt;1\\] \\[(1+x)^{\\alpha}=1+\\alpha x +\\displaystyle \\frac{\\alpha(\\alpha-1)}{2!}x^2+\\cdots\\] 求\\(I = \\displaystyle \\int_{0}^{\\frac{\\pi}{2}} \\ln \\cos x dx\\) 使用区间再现可以得到如下结论。 \\[I \\xlongequal{t = \\frac{\\pi}{2} - x} \\displaystyle - \\int_{\\frac{\\pi}{2}}^{0} \\ln \\sin t dt = \\int_{0}^{\\frac{\\pi}{2}} \\ln \\sin x dx\\] 因此可得： \\[I = \\displaystyle \\frac{1}{2} \\int_{0}^{\\frac{\\pi}{2}} (\\ln \\sin x + \\ln \\cos x) dx = \\frac{1}{2} \\int_{0}^{\\frac{\\pi}{2}} \\ln \\sin 2x dx - \\frac{\\pi}{4}\\ln 2\\] 又因为： \\[\\displaystyle \\int_{0}^{\\frac{\\pi}{2}} \\ln \\sin 2x dx \\xlongequal{t = 2x} \\frac{1}{2} \\int_{0}^{\\pi} \\ln \\sin t dt = \\frac{1}{2}(\\int_{0}^{\\frac{\\pi}{2}} \\ln \\sin x dx + \\int_{\\frac{\\pi}{2}}^{\\pi} \\ln \\sin x dx) = I\\] 因此\\(I = \\displaystyle - \\frac{\\pi}{2} \\ln 2\\)。 求\\(I = \\displaystyle \\int_{0}^{+\\infty} \\frac{dx}{(1+x^2)(1+x^{\\alpha})}\\)，其中\\(\\alpha &gt; 0\\) \\[I = \\displaystyle \\int_{0}^{1} \\frac{dx}{(1+x^2)(1+x^{\\alpha})} + \\int_{1}^{+\\infty} \\frac{dx}{(1+x^2)(1+x^{\\alpha})}\\] \\[\\displaystyle \\int_{1}^{+\\infty} \\frac{dx}{(1+x^2)(1+x^{\\alpha})} \\xlongequal{t = \\frac{1}{x}} -\\int_{1}^{0} \\frac{\\displaystyle\\frac{1}{t^2}dt}{(1+t^{-2})(1+t^{-\\alpha})} = \\int_{0}^{1} \\frac{x^{\\alpha}dx}{(1+x^2)(1+x^{\\alpha})}\\] \\[I = \\displaystyle \\int_{0}^{1} \\frac{dx}{1+x^2} = \\frac{\\pi}{4}\\] 求\\(I=\\displaystyle\\int \\frac{\\ln (1+x) - \\ln x}{x(x+1)} dx\\) 观察可知\\(\\displaystyle \\frac{1}{x(x+1)} = \\frac{1}{x} - \\frac{1}{1+x} = [\\ln x - \\ln(1+x)]&#39;\\)，因此可得以下结果。 \\[I = \\displaystyle -\\frac{1}{2}[\\ln x - \\ln(1+x)]^2 +C\\] 求\\(I=\\displaystyle \\int \\sec^3 x dx\\) \\[\\displaystyle I= \\int \\sec^3 x dx = \\int \\sec x (1+\\tan^2 x) dx = \\int \\sec x dx + \\int \\tan x d(\\sec x) = \\ln|\\sec x + \\tan x| + \\tan x\\sec x - I \\] \\[I = \\displaystyle \\frac{1}{2}(\\ln|\\sec x +\\tan x| + \\tan x \\sec x) + C\\] 求\\(I=\\displaystyle \\frac{\\ln x}{\\sqrt{x^3(1-x)}} dx\\) 注意到\\(\\displaystyle \\int \\frac{dx}{\\sqrt{x^3(1-x)}} = \\int \\frac{\\displaystyle \\frac{1}{x^2}dx}{\\sqrt{\\displaystyle \\frac{1}{x} - 1}} = -2\\sqrt{\\frac{1}{x} - 1} + C\\)。 \\[I = \\displaystyle -2 \\int \\ln x d(\\sqrt{\\frac{1-x}{x}}) = -2\\sqrt{\\frac{1-x}{x}} \\cdot \\ln x + 2\\int \\frac{1}{x} \\sqrt{\\frac{1-x}{x}} dx\\] \\[\\int \\frac{1}{x} \\sqrt{\\frac{1 - x}{x}} dx \\xlongequal{\\sqrt{\\displaystyle \\frac{1-x}{x}} = t} - 2\\int \\frac{t^2}{t^+1} dt = 2\\arctan t - 2t + C = 2\\arctan \\sqrt{\\displaystyle \\frac{1-x}{x}} - 2\\sqrt{\\displaystyle \\frac{1-x}{x}} + C\\] \\[I = -2\\sqrt{\\frac{1-x}{x}} \\cdot \\ln x + 4\\arctan \\sqrt{\\displaystyle \\frac{1-x}{x}} - 4\\sqrt{\\displaystyle \\frac{1-x}{x}} + C\\] 求\\(I=\\displaystyle \\int_{0}^{2\\pi} \\sin(\\sin x - x) dx\\) \\[I = \\displaystyle \\int_{0}^{2\\pi} \\sin (\\sin x) \\cos x dx - \\int_{0}^{2\\pi} \\sin x \\cos (\\sin x) dx = [-\\cos(\\sin x)]^{2\\pi}_{0} + \\int_{0}^{2\\pi} \\sin x \\cos (\\sin x) dx = \\int_{0}^{2\\pi} \\sin x \\cos (\\sin x) dx\\] \\[\\int_{0}^{2\\pi} \\sin x \\cos (\\sin x) dx \\xlongequal{t = x - \\pi} - \\int_{-\\pi}^{\\pi}\\sin t \\cos(\\sin t) dt = 0\\] \\[\\therefore I = 0\\] 求\\(\\displaystyle \\int e^{2x} (1+\\tan x)^2 dx\\) 不妨观察\\(\\displaystyle \\int e^{2x} \\tan x dx\\)。 \\[\\displaystyle \\int e^{2x} \\tan x dx = \\frac{1}{2} \\int \\tan x d(e^{2x})=\\frac{1}{2}e^{2x}\\tan x - \\frac{1}{2}\\int e^{2x} \\sec^2x dx\\] 而\\(\\displaystyle \\int e^{2x} \\sec^2x dx = \\int e^{2x}(1+\\tan^2 x)dx\\)， 故\\(\\displaystyle \\int e^{2x} (1+\\tan x)^2 dx = e^{2x} \\tan x + C\\)。 求\\(\\displaystyle \\int \\frac{e^{\\sin 2x}\\sin^2x}{e^{2x}}dx\\) \\(\\displaystyle \\int \\frac{e^{\\sin 2x}\\sin^2x}{e^{2x}}dx=\\int \\frac{e^{\\sin 2x} \\frac{1-\\cos 2x}{2}}{e^{2x}} dx=\\frac{1}{2}\\int \\frac{e^{\\sin 2x}}{e^{2x}}dx-\\frac{1}{4}\\int e^{-2x}d(e^{\\sin2x})=-\\frac{1}{4}e^{\\sin2x-2x}+C\\) 求\\(\\displaystyle \\int \\frac{x+\\cos x \\sin x}{(\\cos x-x\\sin x)^2}dx\\) \\(\\displaystyle \\int \\frac{x+\\cos x \\sin x}{(\\cos x-x\\sin x)^2}dx=\\int \\frac{x\\sec^2x+\\tan x}{(1-x\\tan x)^2} dx =- \\int \\frac{d(1-x \\tan x)}{(1-x\\tan x)^2} = \\frac{1}{1-x\\tan x} + C\\) 求 \\(I=\\displaystyle \\int_{0}^{1}dx\\int_0^{x}\\frac{e^y}{\\sqrt{(1-x)(x-y)}}dy\\) 注意到\\(I=\\displaystyle \\int_{0}^{1}\\frac{1}{\\sqrt{1-x}}dx\\int_{0}^{x}\\frac{e^y}{\\sqrt{x-y}}dy\\)，不妨考虑对\\(\\displaystyle\\int_{0}^{x}\\frac{e^y}{\\sqrt{x-y}}dy\\)进行换元。 \\(\\displaystyle\\int_{0}^{x}\\frac{e^y}{\\sqrt{x-y}}dy\\xlongequal{\\sqrt{x-y}=t}2\\int_{0}^{\\sqrt{x}}e^{x-t^2}dt=2e^x\\int_0^{\\sqrt{x}}e^{-t^2}dt\\) 那么原积分转化为\\(I=2\\displaystyle \\int_{0}^{1}\\frac{e^x}{\\sqrt{1-x}}dx\\int_0^{\\sqrt{x}}e^{-t^2}dt\\)。 类似地有\\(\\displaystyle \\int_{0}^{1}\\frac{e^x}{\\sqrt{1-x}}dx=2\\int_0^{1}e^{1-u^2}du\\)，其中 \\(x=1-u^2\\)。 那么\\(I=4e\\displaystyle \\int_{0}^{1}e^{-u^2}du\\int_0^{\\sqrt{1-u^2}}e^{-t^2}dt\\)。 显然上式用极坐标计算较为方便，积分区域为单位圆的第一象限部分。 \\(I=4e\\displaystyle \\int_{0}^{1}e^{-u^2}du\\int_0^{\\sqrt{1-u^2}}e^{-t^2}dt=4e\\int_0^{\\frac{\\pi}{2}}d \\theta\\int_{0}^{1}\\rho e^{-\\rho^2}d\\rho =\\pi e(1-\\frac{1}{e})=\\pi(e-1)\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"复变函数与积分变换自学笔记","slug":"复变函数与积分变换自学笔记","date":"2022-10-09T01:31:12.000Z","updated":"2023-01-19T15:49:13.034Z","comments":true,"path":"2022-10-09-复变函数与积分变换自学笔记/","link":"","permalink":"http://example.com/2022-10-09-%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"复变函数与积分变换能为积分求解、信号处理等问题提供新的方法，值得学习。","text":"复变函数与积分变换能为积分求解、信号处理等问题提供新的方法，值得学习。 前言 这篇博客是学习复变函数与积分变换（华中科技大学）时所作的笔记，适合快速入门或者期末考试做题家速成，如果希望深入学习复变函数则建议学习上海交大姚卫红老师的复变函数与概率。 本文将非负下标的无穷级数的求和\\(\\displaystyle \\sum_{n=0}^{+\\infty}\\)简记为\\(\\displaystyle \\sum_{n=0}^{\\infty}\\)。 复变函数 复数的一些性质 \\[\\displaystyle z+\\bar{z} = 2\\text{Re}(z) \\Rightarrow \\text{Re}(z) = \\frac{(z+\\bar{z})}{2}\\] \\[\\displaystyle z-\\bar{z} = 2i\\text{Im}(z) \\Rightarrow \\text{Im}(z) = \\frac{z-\\bar{z}}{2i}=\\frac{i(\\bar{z} - z)}{2}\\] \\[\\bar{z}z=z\\bar{z}=|z^2|=|z|^2\\] \\[|\\bar{z_1}z_2|=|z_1\\bar{z_2}|=|z_1||z_2|\\] \\[z_1\\bar{z_2}+\\bar{z_1}z_2=2\\text{Re}(z_1z_2)\\] 棣莫弗定理 由\\(z=x+iy=re^{i\\theta}=r(\\cos \\theta + i\\sin \\theta),\\theta = \\arg{z} \\in (-\\pi, \\pi]\\)，有下式。 \\[\\displaystyle |\\prod_{j} z_j| = \\prod_{j} |z_j|, \\text{Arg}({\\prod_{j} z_j}) = \\sum_{j}\\arg{z_j}\\]， 上式可用数学归纳法证明。 同理有\\(\\displaystyle |\\frac{z_1}{z_2}| = \\frac{|z_1|}{|z_2|}, \\text{Arg}(\\frac{z_1}{z_2}) = \\text{Arg}{z_1} - \\text{Arg}{z_2}\\)。 利用棣莫弗定理可以求解复数的\\(n\\)次方根。 已知\\(w^n=z\\)，不妨作如下假设。 \\[z=r(\\cos \\theta + i \\sin \\theta),w=\\rho(\\cos \\phi + i \\sin \\phi)\\] 根据棣莫弗定理有：\\(\\rho^n(\\cos {n\\phi} + i \\sin {n\\phi}) = r(\\cos \\theta + i \\sin \\theta)\\)，由复数相等的充要条件有： \\[r = \\rho^n, n\\phi = \\theta + 2k \\pi\\] 因此有\\(\\rho = \\sqrt[n]{r},\\displaystyle \\phi = \\frac{\\theta + 2k \\pi}{n}\\)，当\\(k\\)取遍\\(\\{0,1,\\cdots,n-1\\}\\)，即可取得所有的\\(n\\)次方根。 事实上，对于\\(xOy\\)平面上的点\\(z = x + iy\\)，那么： \\[\\text{arg}z = \\left\\{\\begin{matrix} \\displaystyle\\arctan \\frac{y}{x}, x &gt; 0, y \\neq 0 \\\\ \\displaystyle\\arctan \\frac{y}{x} - \\pi, x &lt; 0, y &lt; 0 \\\\ \\displaystyle\\arctan \\frac{y}{x} + \\pi , x &lt; 0, y &gt; 0 \\\\ \\pi, x &lt; 0, y = 0 \\end{matrix}\\right.\\] 区域 设\\(G\\)为一平面点集，\\(z_0\\)为\\(G\\)中任意一点。如果存在\\(z_0\\)的一个邻域，该邻域中的所有点都属于\\(G\\)，那么称\\(z_0\\)为\\(G\\)的内点。如果\\(G\\)内的每个点都是它的内点，那么称\\(G\\)为开集。对于平面点集\\(D\\)，若其中任意两点都可以用完全属于\\(D\\)的一条折线连接起来，那么称点集\\(D\\)为连通的。对于平面点集\\(D\\)，如果\\(D\\)是连通的开集，那么称之为区域。区域和其边界共同构成闭区域，记作\\(\\bar{D}\\)。 设\\(D\\)为复平面内的一个区域，如果点\\(P \\notin D\\)，但是在\\(P\\)的任意小邻域中总包含\\(D\\)中的点，则称\\(P\\)为\\(D\\)的边界点。\\(D\\)的所有边界点组成\\(D\\)的边界。区域的边界可能是由几条曲线和一些孤立的点组成。区域\\(D\\)与它的边界一起构成闭区域或闭域，称作\\(\\bar{D}\\)。 如果一个区域\\(D\\)可以被包含在某一个以原点为中心的圆中，即存在正数\\(M\\)，使得\\(D\\)中的每个点\\(z\\)都满足\\(|z|&lt;M\\)，那么称\\(D\\)为有界的，否则为无界的。 为介绍单连通域和多连通域，现介绍光滑曲线的相关概念。两个连续实变函数可以表示出一条连续的平面曲线，其复数形式可以是\\(z(t)=x(t)+iy(t)\\)。若\\(x(t)\\)和\\(y(t)\\)在\\([a,b]\\)都有连续的一阶导数，并且\\([x&#39;(t)]^2+[y&#39;(t)]^2 \\neq 0, \\forall t \\in [a,b]\\)，那么称这段曲线为光滑曲线，由几段光滑曲线所组成的曲线称为按段光滑曲线。没有重点的连续曲线被称为简单曲线（与离散数学中关于简单路径的定义相同）或者 Jordan 曲线。对于一个区域，如果其中的任意简单闭曲线的内部都完全包含于区域中，那么该区域被称为单连通区域，否则是多（复）连通区域。单连通区域内的简单闭曲线可以通过连续的变形缩为一点，这是多连通域所不具有的拓扑性质。 平面曲线实数形式和复数形式之间的转换 善用以下公式即可： \\(|z|^2 = z\\bar{z}\\)； \\(x = \\displaystyle \\frac{z + \\bar{z}}{2}\\) \\(\\displaystyle y = \\frac{z - \\bar{z}}{2i}\\)； \\(z = x + yi\\)。 复变函数 复变函数的导数、微分与解析性 设\\(f(z)\\)为一复变函数，若极限\\(\\displaystyle\\lim_\\limits{\\Delta z \\to 0}\\frac{f(z + \\Delta z) - f(z)}{\\Delta z}=A \\in \\text{C}\\)，那么\\(f&#39;(z)=A\\)，并且有\\(f(z + \\Delta z)- f(z) = f&#39;(z)\\Delta + \\rho(z), \\rho(z) \\to 0\\)，值得注意的是\\(\\Delta z \\to 0\\)的方式必须是任意的。复变性质与单元实函数基本一致，即可导\\(\\Leftrightarrow\\)可微。 若\\(f(z)\\)在\\(z_0\\)的某个邻域均可导，则称\\(f(z)\\)在\\(z_0\\)解析。\\(f(z)=u(x,y)+iv(x,y)\\)在一点（区域）解析的充要条件是\\(u(x,y)\\)和\\(v(x,y)\\)均可微且满足 Cauchy-Riemann 方程： \\[\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y}, \\frac{\\partial u}{\\partial y} = - \\frac{\\partial v}{\\partial x}\\] 复变函数解析定理非常重要，下面给出证明。 首先证明必要性。不妨令\\(\\Delta z = \\Delta x + i \\Delta y,\\rho(z) = \\rho_1 + i\\rho_2, f&#39;(z) = a + bi\\)，那么有： \\(f(z + \\Delta z)- f(z) = f&#39;(z)\\Delta + \\rho(z) \\Delta z = (a+bi)(\\Delta x + i \\Delta y) + \\rho_1 + i\\rho_2\\) \\(= (a\\Delta x - b \\Delta y + \\rho_1) + i(b\\Delta x + a\\Delta y + \\rho_2)\\) 可以发现\\(\\Delta u = a\\Delta x - b \\Delta y + \\rho_1\\)和\\(\\Delta v = b\\Delta x + a\\Delta y + \\rho_2\\)，结合\\(\\rho(\\Delta z) = \\rho_1 + i\\rho_2\\)可知两函数都可微，并且有： \\[\\frac{\\partial u}{\\partial x} = a = \\frac{\\partial v}{\\partial y}, -\\frac{\\partial u}{\\partial y} = b = \\frac{\\partial v}{\\partial x}\\] 再证明充分性。由\\(u(x,y)\\)和\\(v(x,y)\\)可微有以下二式： \\[\\Delta u = \\frac{\\partial u}{\\partial x} \\Delta x + \\frac{\\partial u}{\\partial y} \\Delta y + \\alpha_1(\\Delta z)\\] \\[\\Delta v = \\frac{\\partial v}{\\partial x} \\Delta x + \\frac{\\partial v}{\\partial y} \\Delta y + \\alpha_2(\\Delta z)\\] 那么利用 Cauchy-Riemann 方程可得： \\[f(z + \\Delta z) - f(z) = \\Delta u + i\\Delta v = (\\frac{\\partial u}{\\partial x} + i\\frac{\\partial v}{\\partial x})(\\Delta x + i\\Delta y) + \\eta|z|\\] 其中\\(\\eta = \\alpha_1 + i\\alpha_2,\\displaystyle \\lim_\\limits{\\Delta z \\to 0} \\eta = 0\\)，则有\\(f&#39;(z) = \\displaystyle \\frac{\\partial u}{\\partial x} + i\\frac{\\partial v}{\\partial x}\\)。 另外，解析函数的导数依然是解析函数，这一定理此处不做证明。 若二元实函数\\(\\phi(x,y)\\)在区域\\(D\\)内有二阶连续偏导数，且满足 Laplace 方程，即\\(\\displaystyle \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = 0\\)，那么称\\(\\phi(x,y)\\)在区域\\(D\\)内调和或在\\(D\\)上的调和函数。若\\(f(z) = u + iv\\)在区域\\(D\\)内解析，那么\\(u\\)和\\(v\\)都是调和函数。解析函数的实部和虚部的任意阶偏导都是调和的。此外还可以定义共轭调和函数，记\\(\\phi(x,y)\\)和\\(\\psi(x,y)\\)都是区域\\(D\\)上的调和函数且满足 Cauchy-Riemann 方程： \\[\\frac{\\partial \\phi}{\\partial x} = \\frac{\\partial \\psi}{\\partial y}, \\frac{\\partial \\psi}{\\partial x} = -\\frac{\\partial \\phi}{\\partial y}\\] 那么称\\(\\psi(x,y)\\)是\\(\\phi(x,y)\\)的共轭调和函数。注意共轭调和性不具有对称性。基于共轭调和函数的定义，复变函数是解析函数的另一个充要条件是虚部是实部的共轭调和。 常见的复变函数及其定义 指数函数被定义为\\(f(z) = e^{z} = \\exp z = e^{x} (\\cos x + i \\sin x),x,y \\in R\\)，具有的性质有： \\(|e^{z}| = e^{x}, \\text{Arg}e^{z} = y + 2k\\pi, k \\in \\text{Z}\\); 单值函数； \\(\\forall z \\in \\text{C}, e^{z} \\neq 0\\)； \\(e^{z_1}e^{z_2} = e{z_1+z_2}\\)； 以\\(2\\pi i\\)为基本周期； 在复平面上处处解析，并且有\\((e^z)&#39; = e^{z}\\)。 对数函数的定义依赖于指数函数，若\\(\\exp w = z\\)，则称\\(w\\)为\\(z\\)的对数函数，记作\\(w = \\text{Ln} z\\)，注意这里的对数符号的首字母需要大写，与实变函数中的对数函数加以区分，具有的性质有： 多值性，\\(w = \\text{Ln}z = \\ln r + i\\text{Arg}z\\)，主枝被定义为\\(w_0 = \\ln z = \\ln|z| + i\\arg z\\)，当\\(z = x(x &gt; 0)\\)时，\\(\\text{Ln}z = \\ln x\\)； \\(\\displaystyle\\text{Ln}\\frac{z_1}{z_2} = \\text{Ln}z_1 - \\text{Ln}z_2, \\text{Ln}z_1z_2 = \\text{Ln}z_1 + \\text{Ln}z_2\\)，这两个公式应该理解为等式左右两边的值构成的集合相同； \\(\\text{Ln}e^z = z + 2k\\pi i\\)； 主枝\\(\\ln z\\)在除去原点和负实轴的平面内解析，并且\\(\\text{Ln}z\\)在除去原点和负实轴的平面内解析且具有相同的导数值，并且注意对数函数求导数应当使用反函数求道法则： \\[w = \\ln z \\Rightarrow \\frac{dw}{dz} = \\frac{1}{\\displaystyle \\frac{dz}{dw}} = \\frac{1}{e^w} = \\frac{1}{z}\\] 幂函数的定义依赖于对数函数，\\(w = z^{\\alpha} = e^{\\alpha \\text{Ln} z} = e^{\\alpha(\\ln z + 2k\\pi i)}, z\\neq 0\\)，其中\\(\\alpha\\)为复常数，并且规定\\(\\alpha \\in \\text{R}^+ \\wedge z = 0 \\Rightarrow z^{\\alpha} = 0\\)。由于对数函数的多值性，幂函数一般也是多值的。幂函数的多值性取决于\\(\\alpha\\)的取值范围： 当 \\(\\alpha = n \\in \\text{N}^+\\)时，\\(w = z^{\\alpha} = e^{n \\ln z}\\)，是复平面上的单值解析函数； 当\\(\\alpha = \\displaystyle \\frac{p}{q}\\)，其中\\(p,q \\in Z \\wedge (p,q)=1\\)时，\\(w = (e^{2k\\pi pi})^{\\frac{1}{q}}\\)，是\\(q\\)值函数； 当\\(\\alpha\\)为无理数或虚部不为零的复数时，\\(z^{\\alpha}\\)是无穷多值函数。 正弦函数和余弦函数都需要利用指数函数进行定义： \\[\\cos z = \\frac{e^{iz} + e^{-iz}}{2}, \\sin z = \\frac{e^{iz} - e^{-iz}}{2i}\\] 不难发现，两个三角函数具有如下性质： 当\\(z = x\\)时，其与实函数定义一致； 在复平面内解析，并且两函数导数在形式上与实函数保持一致； 奇偶性与实函数一致； 以\\(2\\pi\\)为周期； 无界性； 实函数中的三角恒等式仍成立。 其他三角函数可以利用正弦函数和余弦函数进行定义。 双曲函数也是利用指数函数进行定义的： \\[\\cosh z = \\frac{e^{z} + e^{-z}}{2}, \\sinh z = \\frac{e^{z} - e^{-z}}{2}, \\tanh z = \\frac{\\sinh z}{\\cosh z}\\] 不难发现，双曲正弦函数和双曲余弦函数分别具有如下性质： \\(\\sinh z = -i \\sin iz, \\cosh z = \\cos iz, \\tanh z = -i\\tan iz\\)，\\(\\sinh z\\)和\\(\\cosh x\\)都是复平面上处处解析的，\\((\\sinh z)&#39; = \\cosh z, (\\cosh z)&#39; = \\sinh z\\)，而\\(\\tanh z\\)在复平面上除去\\(z = \\displaystyle (k\\pi + \\frac{\\pi}{2})i, k \\in \\text{Z}\\)外处处解析，\\((\\tanh z)&#39; = \\displaystyle\\frac{1}{\\cosh^2 z}\\)； 双曲正弦函数和双曲余弦函数以\\(2\\pi i\\)为周期，双曲正切函数以\\(\\pi i\\)为周期。 复积分 复积分的定义和性质 与实积分类似，复积分的定义也需要划分、近似求和以及取极限三个步骤进行。设\\(C\\)为简单光滑的有向曲线，其方向为从\\(a\\)到\\(b\\)，并且\\(f(z)\\)在\\(C\\)上有定义： 任意划分：\\(z_ 0 = a, z_1,z_2,\\cdots, z_n = b\\)，令\\(\\Delta z_k = z_k - z_{k - 1}, \\lambda = \\max_\\limits{1\\leq k \\leq n}|\\Delta z_k|\\)； 近似求和：在每个弧线段\\(\\mathop{z_{k - 1}z_k}\\)上任取一点\\(\\zeta_k \\in \\mathop{z_{k - 1}z_k}\\)，近似求和结果为\\(\\displaystyle \\sum_{k=1}^{n}f(\\zeta_k)\\Delta z_k\\)； 取极限：若极限\\(\\displaystyle \\lim_\\limits{\\lambda \\to 0}\\sum_{k=1}^{n}f(\\zeta_k)\\Delta z_k\\)存在，即极限的结果不依赖于\\(C\\)的划分方式和\\(\\zeta_k\\)的选取，那么称和式的极限为\\(f(z)\\)沿\\(C\\)的积分，记作\\(\\displaystyle \\int_{C}f(z) dz\\)，另外，一般用\\(\\displaystyle \\oint_{\\Gamma}f(z)dz\\)表示沿闭曲线逆时针方向的积分。 复积分的性质与第二类曲线积分的性质类似： \\(\\displaystyle \\int_{C}[\\alpha f(z) + \\beta g(z)]dz = \\alpha \\int_{C}f(z)dz + \\beta \\int_{C}g(z)dz\\)； \\(\\displaystyle \\int_{C}f(z)dz = -\\int_{C^-}f(z)dz\\)； \\(\\displaystyle \\int_{C}f(z)dz = \\int_{C_1}f(z)dz + \\int_{C_2}f(z)dz, C = C_1 + C_2\\)； \\(\\displaystyle \\bigg\\lvert \\int_{C}f(z)dz\\bigg\\rvert \\leq \\int_{C}|f(z)||dz| = \\int_{C}|f(z)|ds \\leq ML\\)，其中\\(M = \\max_\\limits{z \\in C}|f(z)|\\)，\\(L\\)为\\(C\\)的弧长。 复积分的计算方法 复积分的计算可以使用曲线积分或是直接化为定积分计算，此外，还可以利用原函数、Cauchy 积分公式、高阶导公式以及留数计算。 Cauchy 积分定理和公式 设函数\\(f(z)\\)在单连通域内解析，\\(\\Gamma\\)为\\(D\\)内的任意一条简单闭曲线，那么\\(\\displaystyle \\oint_{\\Gamma}f(z)dz = 0\\)，该定理又被称为 Cauchy-Goursat 基本定理，证明如下： \\(\\displaystyle\\oint_{\\Gamma}f(z)dz = \\oint_{\\Gamma} (udx - vdy) + i\\oint_{\\Gamma} (vdx + udy)\\) \\(\\displaystyle\\xlongequal{Green} -\\iint_{G}(\\frac{\\partial v}{\\partial x} + \\frac{\\partial u}{\\partial y})dxdy + i\\iint_{G}(\\frac{\\partial u}{\\partial x} - \\frac{\\partial v}{\\partial y})dxdy \\xlongequal{C-R}0\\) 设单连通域的边界为\\(C\\)，函数\\(f(z)\\)在\\(D\\)内解析，在\\(\\bar{D} = D + C\\)上连续，那么\\(\\displaystyle \\oint_{C}f(z)dz = 0\\)。 闭路变形原理的内容为：设二连通域的边界为\\(C = C_1 + C_2^-\\)，函数\\(f(z)\\)在\\(D\\)内解析，在\\(\\bar{D}\\)上连续，那么\\(\\displaystyle \\oint_{C}f(z)dz = 0\\)，或\\(\\displaystyle \\int_{C_1}f(z)dz = \\int_{C_2}f(z)dz\\)。该定理的证明只需要引入连接\\(C_1\\)和\\(C_2\\)的双向曲线，将双连通域转化为单连通域即可。如果无法理解双连通如何通过连一条线就变成单连通域，不妨采用拓扑变形的方法。 下面计算一个重要积分。求\\(\\displaystyle \\oint_{C}\\frac{dz}{(z - z_0)^{n+1}}\\)，其中\\(C\\)为曲线\\(z = z_0 + re^{i\\theta}, 0\\leq \\theta \\leq 2\\pi\\)，\\(n\\)为整数。 \\[\\oint_{C}\\frac{dz}{(z - z_0)^{n+1}} = \\frac{i}{r^n}\\int_{0}^{2\\pi}e^{-in\\theta}d\\theta\\] 当\\(n = 0\\)时，结果为\\(i\\displaystyle\\int_{0}^{2\\pi}d\\theta=2\\pi i\\)，否则结果为\\(i\\displaystyle \\int_{0}^{2\\pi}(cos n\\theta - i\\sin n\\theta)d\\theta = 0\\)，综上所述： \\[\\oint_{C}\\frac{dz}{(z - z_0)^{n+1}} = \\left\\{\\begin{matrix} 0, n\\neq 0 \\\\ 2\\pi i, n = 0 \\end{matrix}\\right.\\] 上说结论说明该积分的值与圆周的中心和半径无关，非常重要，应记住。 利用上述积分的结果可以计算\\(I=\\displaystyle \\oint_{\\Gamma}\\frac{dz}{(z-z_0)^n}, n \\in \\text{Z}\\)，其中\\(\\Gamma\\)为包含\\(z_0\\)的一条闭曲线。 在区域内部引入曲线\\(C:|z-z_0|=r \\Rightarrow z = z_0 + re^{i\\theta}\\)，那么函数\\(f(z)\\)在\\(\\bar{D} = D + \\Gamma + C^{-}\\)上解析，因此： \\[\\displaystyle I = \\oint_{\\Gamma}\\frac{dz}{(z-z_0)^n} = \\oint_{C}\\frac{dz}{(z-z_0)^n} = \\left\\{\\begin{matrix} 0, n \\neq 1 \\\\ 2\\pi i, n = 1 \\end{matrix}\\right.\\] 事实上，还将柯西积分定理推广到多连域情况。设多连通域的边界为\\(C = C_0 + \\displaystyle \\sum_{k=1}^{n}C^{-}_{k}\\)，函数\\(f(z)\\)在\\(D\\)内解析，在\\(\\bar{D}\\)上连续，那么\\(\\displaystyle \\oint_{C}f(z)dz = 0\\)，或\\(\\displaystyle \\oint_{C_0}f(z)dz = \\sum_{k=1}^{n}\\oint_{C_k}f(z)dz\\)。 若函数在区域\\(D\\)内解析，在\\(D\\)的闭包上连续，\\(z_0 \\in D\\)，那么\\(f(z_0) = \\displaystyle \\frac{1}{2\\pi i}\\oint_{C}\\frac{f(z)}{z - z_0}dz\\)，其中\\(C=\\partial D\\)。这说明解析函数在其解析区域内的值完全由边界上的值确定，换言之，解析函数可以用其解析区域边界上的值以一种特定的积分形式表达出来。这个公式被称为 Cauchy 积分公式，可以用于积分的计算。 若函数在\\(|z - z_0|&lt;R\\)内解析，在\\(|z - z_0|\\)上连续，那么\\(\\displaystyle f(z_0) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi}f(z_0+Re^{i\\theta})d\\theta\\)，该公式被称为平均值公式，可以由 Cauchy 积分公式证明： \\[f(z_0) = \\frac{1}{2\\pi i}\\oint_{|z - z_0| = R}\\frac{f(z)}{z - z_0}dz = \\frac{1}{2\\pi i}\\int_{0}^{2\\pi}\\frac{f(z_0 + Re^{i\\theta})}{Re^{i\\theta}}Re^{i\\theta}id\\theta = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}f(z_0 + Re^{i\\theta})d\\theta\\] 如果\\(f(z)\\)在\\(D\\)内解析，且不为常数，那么\\(D\\)内\\(|f(z)|\\)没有最大值，这被称为最大模原理。由平均值公式可知：函数\\(f(z)\\)在解析区域\\(D\\)内任意一点\\(z_0\\)的函数值是以该点为圆心的圆周上所有点的平均值。因此\\(|f(z_0)|\\)不能达到最大，除非\\(f(z)\\)为常数。由最大模原理可知： 在区域\\(D\\)内解析的函数，如果其模在\\(D\\)内达到最大值，那么该函数一定是常数； 若\\(f(z)\\)在有界区域\\(D\\)内解析，在\\(\\bar{D}\\)上连续，那么\\(|f(z)|\\)在\\(D\\)的边界上一定能达到最大值。 原函数 利用 Cauchy-Goursat 定理可知，若函数\\(f(z)\\)在单连通域内解析，并且\\(C_1\\)和\\(C_2\\)都是区域\\(D\\)内的以\\(z_0\\)为起点、\\(z_1\\)为终点的简单曲线，那么\\(\\displaystyle \\oint_{C_1}f(z)dz = \\oint_{C_2}f(z)dz\\)，这说明解析函数在单连通域内的积分只和起点、终点有关，在计算时可以根据实际情况选择计算量更小的路径。 不难联想第二类曲线积分中的相关性质：设\\(D\\)为\\(xOy\\)平面上的单连通闭区域，函数\\(P(x,y)\\)和\\(Q(x,y)\\)在\\(D\\)上有一阶连续偏导数，那么以下性质两两等价： 沿\\(D\\)内任何光滑闭曲线\\(C\\)，总有\\(\\displaystyle \\oint_{C} Pdx + Qdy = 0\\)； 积分\\(\\displaystyle \\oint_{C} Pdx + Qdy\\)的值只与起点、终点有关，而与路径无关； \\(Pdx + Qdy\\)为\\(D\\)内的某个函数\\(u(x,y)\\)的全微分，即\\(du=Pdx + Qdy\\)； 在\\(D\\)内的每一点总有\\(\\displaystyle \\frac{\\partial Q}{\\partial x} = \\frac{\\partial P}{\\partial y}\\)。 对于复变函数，同样可以提出原函数的概念：设在单连通域\\(D\\)中，\\(F(z)\\)总满足\\(F&#39;(z) = f(z)\\)，那么称\\(F(z)\\)为\\(f(z)\\)在\\(D\\)上的一个原函数，原函数的集合被称为\\(f(z)\\)的不定积分。\\(f(z)\\)的任何两个原函数之间只相差一个常数。对于解析函数而言，其原函数必定解析。 解析函数在单连通域内沿简单曲线的积分可以使用 Newton-Leibniz 公式计算。设\\(F(z)\\)为\\(f(z)\\)的原函数，那么\\(\\displaystyle \\int_{z_0}^{z_1}f(z)dz = F(z_1) - F(z_0)\\)，其中\\(z_0,z_1 \\in D\\)。 解析函数的高阶导数 如果函数\\(f(z)\\)在区域\\(D\\)内解析，在\\(\\bar{D} = D + C\\)上连续，那么由 Cauchy 积分公式有： \\[f(z) = \\displaystyle \\frac{1}{2\\pi i}\\oint_{C}\\frac{f(\\zeta)}{\\zeta - z}d\\zeta, z \\in D\\] 对上式求导有：\\(\\displaystyle f(z)^{(n)}(z) = \\frac{n!}{2\\pi i}\\oint_{C} \\frac{f(\\zeta)}{(\\zeta - z)^{n+1}}d\\zeta, z \\in D\\)，这说明了解析函数的导数依然解析。上式还可以像 Cauchy 积分公式一样用于求解特定形式的积分值。利用高阶导数还可以得到以下两条定理： 设函数\\(f(z)\\)在\\(|z - z_0| &lt; R\\)内解析，且\\(|f(z)| &lt; M\\)，那么\\(|f^{(n)}(z_0)| \\leq \\displaystyle \\frac{n!M}{R^n}, n = 1, 2, \\cdots\\)； 设函数\\(f(z)\\)在全平面上解析且有界，那么\\(f(z)\\)是常数。 幂级数 基本概念及 Aebl 定理 基本概念 类比实数序列极限的概念，可以得到复数序列的极限的概念，这里不再赘述。设\\(z_n = x_n + iy_n\\)，\\(a = \\alpha + i\\beta\\)，那么： \\[\\displaystyle \\lim_\\limits{n \\to +\\infty}z_n = a \\Leftrightarrow \\lim_\\limits{n \\to +\\infty}x_n = \\alpha \\wedge \\lim_\\limits{n \\to +\\infty}y_n = \\beta\\] 这是显然的，这里不再证明。下面开始介绍复数项级数。设\\(\\{z_n\\}\\)是一复数序列： 称\\(\\displaystyle\\sum_{n=1}^{\\infty}z_n\\)为复数项级数，简记为\\(\\displaystyle\\sum z_n\\)； 称\\(s_n=\\displaystyle\\sum_{k=1}^n z_k = z_1+z_2+\\cdots+z_n\\)为级数的部分和； 如果序列\\(\\{s_n\\}\\)收敛，即\\(\\displaystyle \\lim_\\limits{n \\to \\infty}s_n = s\\)，则称级数收敛并且极限值\\(s\\)称为级数的和； 如果序列\\(\\{s_n\\}\\)不收敛，则称级数发散。 若\\(\\displaystyle \\sum |z_n|\\)收敛，则称\\(\\displaystyle \\sum z_n\\)绝对收敛；若\\(\\displaystyle \\sum|z_n|\\)发散，\\(\\displaystyle \\sum z_n\\)收敛，则称\\(\\displaystyle \\sum z_n\\)条件收敛。 设\\(z_n = x_n + iy_n\\)，那么\\(\\displaystyle \\sum z_n\\)收敛\\(\\Leftrightarrow\\displaystyle\\sum x_n\\)和\\(\\displaystyle \\sum y_n\\)都收敛；此外，与实数项级数类似，复数项级数也有性质： \\(\\displaystyle \\sum z_n\\)收敛\\(\\Rightarrow \\lim_\\limits{n \\to \\infty} z_n = 0\\)； 若\\(\\displaystyle \\sum|z_n|\\)收敛\\(\\Rightarrow \\displaystyle \\sum z_n\\)收敛。 基于复数项级数，可以定义复变函数项级数。设复变函数\\(f_n(z)\\)在区域\\(G\\)内有定义： 称\\(\\{f_n(z)\\}\\)为区域\\(G\\)内的复变函数序列； 称\\(\\displaystyle \\sum_{n=1}^{\\infty}f_n(z)\\)为区域\\(G\\)内的复变函数项级数，简记为\\(\\displaystyle \\sum f_{n}(z)\\)。 设\\(\\displaystyle \\sum f_n(z)\\)为区域\\(G\\)内的复变函数项级数： 称\\(s_n = \\displaystyle \\sum_{k=1}^{n}f_k(z)\\)为级数\\(\\displaystyle \\sum f_n(z)\\)的部分和； 若对于\\(G\\)内的某一点\\(z_0\\)，有\\(\\displaystyle \\lim_\\limits{n \\to \\infty}s_n(z_0) =s(z_0)\\)，则称级数\\(\\displaystyle \\sum f_n(z)\\)在\\(z_0\\)点收敛； 若存在区域\\(D \\subseteq G\\)，对于\\(\\forall z \\in D\\)，有\\(\\displaystyle \\lim_\\limits{n \\to \\infty}s_n(z) = s(z)\\)，则称级数\\(\\displaystyle \\sum f_n(z)\\)在区域\\(D\\)内收敛，此时称\\(s(z)\\)为和函数，\\(D\\)为收敛域。 幂级数由如下的复变函数项级数定义： \\[\\sum_{n=0}^{\\infty}a_n(z - a)^n = a_0 + a_1(z -a)+ a_2(z - a)^2 + \\cdots\\] 其中\\(a\\)和\\(\\{a_n\\}_{n=0,1,2\\cdots}\\)为复常数，当\\(a \\neq 0\\)时，幂级数是\\(\\text{(I)}\\)型的，否则是\\(\\text{(II)}\\)型的。以后的内容主要对\\(\\text{(II)}\\)型幂级数进行讨论，所有得到的结论只需要将\\(z\\)替换为\\((z - a)\\)即可应用到\\(\\text{(I)}型幂级数\\)。对于两种形式的幂级数，它们都在展开点收敛。 Abel 定理 下面给出幂级数的收敛定理—— Abel 定理。对于幂级数\\(\\displaystyle \\sum a_n z^n\\)有： 若级数在\\(z_0\\)点收敛，则它在\\(|z| &lt; |z_0|\\)上绝对收敛； 若级数在\\(z_1\\)点发散，则它在\\(|z| &gt; |z_1|\\)商发散。 事实上，级数在\\(z_0\\)点收敛，那么有\\(\\lim_\\limits{n\\to \\infty} a_n z_0^n = 0\\)，则存在\\(M\\)，使得： \\[\\forall n, |a_nz_0^n| \\leq M \\Rightarrow |a_nz^n| = |a_nz^n_0|\\cdot \\displaystyle |\\frac{z}{z_0} |^n \\leq Mq^n\\] 其中\\(q = \\displaystyle |\\frac{z}{z_0} | \\in [0,1)\\)，由等比级数的性质以及比较审敛法可知级数在\\(|z| &lt; |z_0|\\)上绝对收敛。利用反证法可以证明另外一个定理，假定级数在\\(z_2 \\in \\{|z| &gt; |z_1|\\}\\)处收敛，那么根据已证明的定理可知级数在\\(|z| &lt;|z_2|\\)收敛，这与级数在\\(z_1\\)处发散相矛盾。 以上的两个定理说明了级数收敛点构成的集合的内点是一个圆，该圆被称为收敛圆，\\(|z| &lt; R\\)的收敛圆记作\\(C_R\\)，其中\\(R\\)是收敛半径，\\(R=0\\)说明级数只在原点收敛；\\(R = +\\infty\\)表明级数在整个复平面上都收敛。注意级数在收敛圆边界的收敛情况是不一定的。 接下来介绍求收敛半径的方法，主要包括两种： 如果\\(\\displaystyle \\lim_\\limits{n \\to \\infty} \\frac{|a_{n+1}|}{|a_n|} = \\lambda\\)，则收敛半径为\\(R = \\displaystyle \\frac{1}{\\lambda}\\)（比值法）； 如果\\(\\displaystyle \\lim_\\limits{n \\to \\infty}\\sqrt[n]{|c_n|} = \\rho\\)，则收敛半径为\\(R= \\displaystyle\\frac{1}{\\rho}\\)（根值法）。 性质 运算性质 设\\(f(z) = \\displaystyle \\sum_{n = 0}^{\\infty}a_nz^n, |z| &lt; r_1\\)和\\(g(z) = \\displaystyle \\sum_{n = 0}^{\\infty}b_n z^n, |z| &lt; r_2\\)，令\\(r = \\min(r_1, r_2)\\)，那么在\\(|z| &lt; r\\)内有： \\(f(z) \\pm g(z) = \\displaystyle \\sum_{n = 0}^{\\infty}(a_n \\pm b_n)z^n\\)； \\(f(z)g(z) = \\displaystyle \\sum_{n = 0}^{\\infty}a_n z^n \\cdot \\sum_{n=0}^{\\infty0}b_n z^n = \\sum_{n = 0}^{\\infty}(\\sum_{k = 0}^{n}a_kb_{n-k})z^n\\)。 分析性质 设\\(f(z) = \\displaystyle \\sum_{n = 0}^{\\infty}a_n(z - z_0)^n, |z - z_0| &lt; R\\)，那么： 函数\\(f(z)\\)在收敛圆\\(|z - z_0| &lt; R\\)内解析； 函数\\(f(z)\\)的导数可以由其幂级数逐项求导得到，即\\(f&#39;(z) = \\displaystyle \\sum_{n = 1}^{\\infty}na_n(z - z_0)^{n-1}\\)； 在收敛圆内可以逐项积分，即\\(F(z) = \\displaystyle \\sum_{n = 0}^{\\infty} \\frac{a_n}{n+1}(z - z_0)^{n + 1} + C\\)，其中\\(C\\)是复常数。 复合性质 设级数\\(\\displaystyle \\sum_{n=0}^{\\infty}a_n z^n\\)在\\(|z| &lt; R\\)内收敛，和函数为\\(f(z)\\)，又设函数\\(g(z)\\)在\\(|z| &lt; r\\)内解析，并且\\(|g(z)| &lt; R\\)，那么当\\(|z| &lt; r\\)时，\\(f[g(z)] = \\displaystyle \\sum_{n = 0}^{\\infty}a_n[g(z)]^n\\)。 Taylor 级数 首先介绍 Taylor 定理的内容。设函数\\(f(z)\\)在区域\\(D\\)内解析，\\(C\\)为\\(D\\)的边界，并且有\\(z_0 \\in D\\)，\\(R = \\min_\\limits{z \\in C}|z - z_0|\\)，那么当\\(|z - z_0| &lt; R\\)时，有： \\[f(z) = \\sum_{n = 0}^{\\infty}a_n(z - z_0)^n, a_n = \\frac{1}{n!}f^{(n)}(z_0) = \\frac{1}{2\\pi i}\\oint_{C}\\frac{f(z)}{(z - z_0)^{n + 1}}dz\\] 这里需要注意： 根据幂级数的性质，幂级数的收敛域一定是圆域； 幂级数收敛\\(\\Rightarrow\\)和函数解析。 求解函数的 Taylor 级数时，需要熟记以下两个已知的展开式（形式上与实变函数相同）： \\[\\frac{1}{1 - z} =1 + z + z^2 +\\cdots , |z| &lt; 1\\] \\[e^z = \\sum_{n = 0}^{\\infty}\\frac{z^n}{n!} = 1 + z + \\frac{1}{2!}z^2 + \\frac{1}{3!}z^3 + \\cdots, |z| &lt; +\\infty\\] Laurent 级数 考察\\(\\displaystyle \\frac{1}{1 - z}\\)的 Taylor 级数，注意到其在复平面上除了奇点\\(z = 1\\)外都解析，但正是这一个奇点，使得函数只能在\\(|z| &lt; 1\\)的范围展开。注意到\\(|z| &gt; 1\\)时有如下等式成立： \\[\\frac{1}{1-z} = -\\frac{1}{z} \\frac{1}{1 - \\displaystyle\\frac{1}{z}} = -(\\frac{1}{z} + \\frac{1}{z^2}+\\cdots)\\] 这样一来有： \\[\\frac{1}{1 - z} = \\left\\{\\begin{matrix} 1 + z + z^2 + \\cdots, |z| &lt; 1 \\\\ \\displaystyle -(\\frac{1}{z} + \\frac{1}{z^2} + \\frac{1}{z^3} + \\cdots), |z| &gt; 1 \\end{matrix}\\right.\\] 上述例子带来的启示为：如果不限制一定要展开为只含正幂次项的幂级数的话，即引入负幂次项，那么有可能将函数在除了奇点所在的圆周以外的整个复平面展开。 考虑级数\\(\\displaystyle \\sum_{n=-\\infty}^{+\\infty}a_n(z - z_0)^n\\)的收敛特性：对于正（非负）幂次部分，收敛域的形式一定是\\(|z - z_0| &lt; R_2\\)；对于负幂次部分，收敛域的形式一定是\\(R_1 &lt; |z - z_0|\\)。因此，如果原级数收敛，那么其收敛域一定是圆环域\\(R_1 &lt; |z - z_0| &lt; R_2\\)，并且，级数的和函数在收敛域内解析。 Laurent 定理的内容为：设\\(f(z)\\)在圆环域\\(R_1 &lt; |z - z_0| &lt; R_2\\)，那么\\(f(z)\\)一定能在该域中展开为如下的形式： \\[f(z) = \\sum_{n = -\\infty}^{+\\infty}a_n(z - z_0)^n,a_n = \\frac{1}{2\\pi i}\\oint_{C}\\frac{f(\\zeta)}{(\\zeta - z_0)^{n + 1}}d\\zeta, n = 0, \\pm 1, \\pm 2, \\cdots\\] 其中\\(C\\)为在圆环域内任意一条环绕\\(z_0\\)的简单闭曲线。上述形式的级数被称为 Laurent 级数，一个在某圆环域中解析的函数展开为 Laurent 级数的结果是唯一的。Laurent 级数中，称正（非负）次幂项和负幂次项分别称为洛朗级数的解析部分和主要部分。格外注意 Laurent 级数中各项的系数与 Taylor 级数不同，即使是正幂次项。求解函数的 Laurent 级数前必须先将复平面划分为若干解析环。 下面以求解函数\\(f(z) = \\displaystyle \\frac{1}{(z - 1)(z - 2)}\\)在\\(z = 0\\)处展开的 Laurent 级数。 发现函数奇点\\(z = 1\\)和\\(z = 2\\)，据此将复平面划为以下\\(3\\)个解析域： \\(D_1 = \\{z| |z| &lt; 1\\}\\)； \\(D_2 = \\{z| 1 &lt; |z| &lt; 2\\}\\)； \\(D_3 = \\{z| |z| &gt; 2\\}\\)。 又\\(f(z) = \\displaystyle \\frac{1}{1 - z} - \\frac{1}{2 - z}\\)，利用\\(\\displaystyle \\frac{1}{1-z}\\)的展开式最终得到如下结果： \\[f(z) = \\left\\{\\begin{matrix} \\displaystyle = \\frac{1}{1 - z} -\\frac{1}{2} \\frac{1}{1 - \\displaystyle \\frac{z}{2}} = \\sum_{n = 0}^{\\infty}(1 - \\frac{1}{2^{n+1}})z^n, 0 \\leq |z| &lt; 1 \\\\ \\displaystyle = -(\\frac{1}{z}\\frac{1}{1- \\displaystyle\\frac{1}{z}} + \\frac{1}{2}\\frac{1}{1 - \\displaystyle\\frac{z}{2}}) = -\\sum_{n = 0}^{\\infty}(\\frac{1}{z^{n+1}} + \\frac{z^n}{2^{n+1}}), 1 &lt; |z| &lt; 2 \\\\ \\displaystyle -\\frac{1}{z}\\frac{1}{1 - \\displaystyle\\frac{1}{z}} + \\frac{1}{z}\\frac{1}{1 - \\displaystyle\\frac{2}{z}} = \\sum_{n = 0}^{+\\infty}\\frac{2^n - 1}{z^{n+1}}, |z| &gt; 2 \\end{matrix} \\right.\\] 留数 奇点的相关概念和性质 孤立奇点 了解奇点的相关定义对于理解留数的概念非常有帮助。设\\(z_0\\)为函数\\(f(z)\\)的奇点，并且存在\\(\\delta &gt; 0\\)，使得\\(f(z)\\)在\\(\\mathring{U}(z_0,\\delta)\\)内解析，那么称\\(z_0\\)为\\(f(z)\\)的孤立奇点。将函数\\(f(z)\\)在其孤立奇点的去新邻域中展开为 Laurent 级数，根据展开式的不同情况可以对鼓励奇点进行分类： 如果展开式中不含\\((z - z_0)\\)的负幂项，那么称\\(z_0\\)为可去奇点，如\\(z = 0\\)之于\\(f(z)=\\left\\{\\begin{matrix} \\displaystyle\\frac{\\sin z}{z}, z \\neq 0 \\\\ 1, z = 0 \\end{matrix}\\right.\\)； 如果展开式中只包含有限个\\((z - z_0)\\)的负幂项，且其中关于\\((z-z_0)^{-1}\\)的最高幂次为\\(m\\)，或函数\\(f(z)\\)可被表示为\\(\\displaystyle \\frac{g(z)}{(z - z_0)^m}\\)的形式，其中\\(g(z)\\)在\\(z_0\\)处解析，且\\(g(z_0)\\neq 0\\)，那么称\\(z_0\\)为\\(m\\)阶极点； 如果展开式中还有无穷多关于\\((z - z_0)\\)的负幂项，那么称\\(z_0\\)为本性奇点。 事实上，根据孤立奇点的定义不难得出以下的等价判断条件（在求解极限过程中可以使用 L'Hospital's 法则）： \\(z_0\\)为\\(f(z)\\)的可去奇点\\(\\Leftrightarrow\\displaystyle \\lim_\\limits{z \\to z_0}\\)存在且有限； \\(z_0\\)为\\(f(z)\\)的极点\\(\\Leftrightarrow \\displaystyle\\lim_\\limits{z \\to z_0}f(z) = \\infty\\)； \\(z_0\\)为\\(f(z)\\)的本性奇点\\(\\Leftrightarrow \\displaystyle\\lim_\\limits{z \\to z_0}f(z)\\)不存在且不为\\(\\infty\\)。 函数在无穷远点的性态需要另行说明。由于该点时复平面外的理想点，故无穷远点总是\\(f(z)\\)的奇点。如果函数\\(f(z)\\)在无穷远点的去心邻域\\(R &lt; |z| &lt; \\infty\\)内解析，则称点\\(\\infty\\)为\\(f(z)\\)的孤立奇点。作变换\\(w = \\displaystyle\\frac{1}{z}\\)，可以将扩充\\(z\\)平面上的\\(\\infty\\)去心邻域映射为扩充\\(w\\)平面上的原点的去心邻域\\(0 &lt; |w| &lt; \\displaystyle \\frac{1}{R}\\)。若记\\(f(z) = f(\\displaystyle \\frac{1}{w}) = \\phi(w)\\)，则\\(\\lim_\\limits{z \\to \\infty}f(z) = \\lim_\\limits{w \\to 0}\\phi(w)\\)，因此函数\\(f(z)\\)在无穷远点\\(z = \\infty\\)的性态可以由函数\\(\\phi(w)\\)在原点\\(w = 0\\)的性态来刻画。 零点与极点的关系 若\\(f(z)\\)在\\(z_0\\)处解析，而且\\(f(z) = (z - z_0)^m\\phi(z)\\)，其中\\(\\phi(z)\\)在\\(z_0\\)处解析且\\(\\phi(z_0)\\neq 0\\)，那么称\\(z = z_0\\)为\\(f(z)\\)的\\(m\\)阶零点。事实上，不恒为\\(0\\)的解析函数只有孤立零点。 如果\\(z_0\\)是\\(f(z)\\)的\\(m\\)阶零点，那么\\(z_0\\)是\\(\\displaystyle \\frac{1}{f(z)}\\)，反之亦然。 设函数\\(f(z)\\)在\\(z_0\\)处解析，那么以下条件等价： \\(z_0\\)为\\(f(z)\\)的\\(m\\)阶零点； \\(f^{(k)}(z_0) = 0, k \\in \\{0,1,2,\\cdots, m - 1\\} \\wedge f^{(m)}(z_0) \\neq 0\\)。 留数定理与应用 留数定理 根据之前章节的内容，对于复闭路积分\\(I = \\displaystyle \\oint_{\\Gamma}f(z)dz\\)，有： 若\\(f(z)\\)在\\(D\\)内解析，在\\(\\Gamma\\)上连续，由 Cauchy 积分定理可知\\(I = 0\\)； 若\\(f(z)\\)在\\(D\\)内有唯一的奇点\\(z_0\\)，由秘鲁变形原理可知\\(I = \\displaystyle \\oint_{C}f(z)dz\\)，此时对\\(f(z)\\)在\\(z_0\\)的某去心邻域内进行 Laurent 展开，并且在等式两端同取关于\\(C\\)的正向闭路积分可知\\(I = 2 \\pi i c_{-1}\\)，其中残留的 Laurent 系数\\(c_{-1}\\)就被称为函数\\(f(z)\\)在\\(z_0\\)处的留数，记作： \\[\\text{Res}[f(z), z_0] = c_{-1} = \\frac{1}{2\\pi i}\\oint_{C}f(z)dz\\] 设\\(f(z)\\)在区域\\(D\\)除了有限个孤立奇点\\(z_1,z_2,\\cdots,z_n\\)外处处解析，\\(C\\)为\\(D\\)内包含这\\(n\\)个奇点的一条正向简单闭曲线，那么： \\[\\oint_{C}f(z)dz = 2\\pi i \\sum_{k = 1}^{n}\\text{Res}[f(z), z_k]\\] 以上就是留数定理的内容，利用复合闭路定理易证。 设\\(C\\)是复平面上的一条简单闭曲线，并且记\\(D\\)和\\(G\\)分别为是\\(C\\)和\\(C^-\\)围成的区域，如果区域\\(D\\)内的奇点很多，但是区域\\(G\\)内的奇点很少，甚至只有无穷远点\\(\\infty\\)为奇点，那么沿\\(C^-\\)上的积分显然比沿\\(C\\)的积分简单很多，因此函数在无穷远点的留数时是必要研究的。设函数\\(f(z)\\)在圆环域\\(R &lt; |z| &lt; \\infty\\)解析，\\(C\\)是该圆环域中环绕原点的任何一条简单闭曲线，那么\\(f(z)\\)在无穷远处的留数被定义为： \\[\\text{Res}[f(z), \\infty] = \\displaystyle \\frac{1}{2\\pi i}\\oint_{C^-}f(z)dz = c_{-1}\\] 其中\\(C^-\\)应理解为圆环域内环绕\\(\\infty\\)的任何一条简单闭曲线。与复平面上的点不同，当\\(\\infty\\)为可去奇点时，\\(\\text{Res}[f(z), \\infty]\\)不一定为\\(0\\)，例如将\\(f(z) = \\displaystyle \\frac{1}{1-z}\\)在\\(|z| &gt; 1\\)内展开为 Laurent 级数，易得： \\[c_{-1} = -1 \\Rrightarrow \\text{Res}[f(z), \\infty] = 1\\] 这些求解复闭路积分的问题可以转化为求解留数的问题，若知晓奇点的类型，则对求解留数更有利： 如果\\(z_0\\)为\\(f(z)\\)的可去奇点，那么\\(\\text{Res}[f(z), z_0] = 0\\)； 如果\\(z_0\\)为\\(f(z)\\)的本性奇点，那么只能按照定义将函数在该点 Laurent 展开； 如果\\(z_0\\)为\\(f(z)\\)的极点，那么可以利用一些有用的法则求解\\(c_{-1}\\)。 下面给出\\(z_0\\)为极点的情况下，\\(\\text{Res}[f(z), z_0]\\)的求法： 法则一：若\\(z_0\\)为\\(f(z)\\)的一阶极点，那么\\(\\text{Res}[f(z),z_0] = \\lim_\\limits{z \\to z_0}(z-z_0)f(z)\\)； 法则二：若\\(z_0\\)为\\(f(z)\\)的\\(m\\)阶极点，那么\\(\\text{Res}[f(z),z_0] = \\displaystyle \\frac{1}{(m-1)!}\\lim_\\limits{z \\to z_0}\\frac{d^{m-1}}{dz^{m-1}}\\{(z-z_0)^mf(z)\\}\\)； 法则三：若\\(f(z) = \\displaystyle \\frac{P(z)}{Q(z)}\\)，\\(Q(z_0) = 0\\)，\\(Q&#39;(z_0) \\neq 0\\)，\\(P(z_0) \\neq 0\\)，并且\\(P(z)\\)和\\(Q(z)\\)在\\(z_0\\)解析，那么\\(z_0\\)是\\(f(z)\\)的简单极点，则\\(\\text{Res}[f(z),z_0] = \\displaystyle \\frac{P(z_0)}{Q&#39;(z_0)}\\)； 法则四：\\(\\text{Res}[f(z), \\infty] = \\displaystyle \\frac{1}{2\\pi i} \\oint_{C^-}f(z)dz = -\\frac{1}{2\\pi i}\\oint_{c}f(\\frac{1}{\\epsilon})\\frac{1}{\\epsilon^2}d\\epsilon = -\\text{Res}[f(\\frac{1}{z})\\cdot \\frac{1}{z^2}, 0]\\)，另外，如果\\(f(z)\\)在扩充复平面内只有有限个孤立奇点，那么\\(f(z)\\)所有奇点（包括\\(\\infty\\)）的留数总和必定为\\(0\\)。 法则一和法则二易证。\\(f(z)(z-z_0)^{m} = c_{-m} + \\cdots + c_{-1}(z-z_0)^{m-1} + \\cdots\\)，式中只含有\\((z-z_0)\\)的正幂次的项，那么： \\[\\frac{d^{m-1}}{dz^{m-1}}\\{(z-z_0)^mf(z)\\} = (m-1)!c_{-1}\\] 令两端\\(z\\to z_0\\)，同除\\((m-1)!\\)即可得到两个法则。 对于法则三而言，由于\\(Q(z_0) = 0\\)和\\(Q&#39;(z_0) \\neq 0\\)，可知\\(z_0\\)时\\(Q(z)\\)的一阶零点，从而\\(z_0\\)是\\(\\displaystyle \\frac{1}{Q(z)}\\)的一阶极点，并且\\(P(z_0) \\neq 0\\)，因而\\(z_0\\)是\\(f(z)\\)的一阶极点，根据法则一可得： \\[\\text{Res}[f(z), z_0] = \\lim_\\limits{z \\to z_0}\\frac{P(z)}{\\displaystyle \\frac{Q(z)}{(z-z_0)}} = \\frac{P(z_0)}{Q&#39;(z_0)}\\] 留数在定积分计算中的应用 某些定积分可以利用留数进行计算，一般的方法为将定积分转化为复平面上的环路积分进行计算。 如图，对于实积分\\(\\displaystyle \\int_a^bf(x)dx\\)，变量\\(x\\)定义在闭区间\\([a,b]\\)，记\\(l_1 = \\overline{ab}\\)，构造闭路曲线\\(l = l_1 + l_2\\)。为了将定积分变为闭路积分，闭曲线\\(l\\)必须落在被积函数f(x)\\(对应的复变函数\\)f(z)$的解析范围内，这时有如下等式： \\[\\oint_l f(z) dz = \\int_a^bf(x)dx + \\int_{l_2}f(z)dz \\Rightarrow \\int_a^bf(x)dx = \\oint_l f(z) dz - \\int_{l_2}f(z)dz = I_1 - I_2\\] \\(I_1\\)可以利用留数计算，\\(I_2\\)容易计算或等于\\(0\\)，此时定积分可解。 对于形如\\(\\displaystyle \\int_0^{2\\pi}R(\\cos \\theta, \\sin \\theta)d \\theta\\)的积分，\\(R(u,v)\\)是\\(u,v\\)的有理数，作变量代换\\(z = e^{i\\theta}\\)，有： \\[\\cos \\theta = \\frac{e^{i\\theta} + e^{-i\\theta}}{2} = \\frac{z^2+1}{2z}, \\sin \\theta = \\frac{e^{i\\theta} - e^{-i\\theta}}{2i} = \\frac{z^2-1}{2iz},dz = ie^{i\\theta}d\\theta = iz d\\theta\\] 实积分化为沿着正向圆周的复积分： \\[\\int_0^{2\\pi}R(\\cos \\theta, \\sin \\theta)d \\theta=\\oint_{|z| = 1} R(\\frac{z^2+1}{2z},\\frac{z^2-1}{2iz})\\frac{dz}{iz} = \\oint_{|z| = 1}f(z)dz\\] 其中\\(f(z)\\)是\\(z\\)的有理函数，且在单位圆周\\(|z| = 1\\)上分母不为，根据留数定理最终有： \\[\\int_{0}^{2\\pi}R(\\cos \\theta, \\sin \\theta)d\\theta = \\oint_{|z| = 1}f(z)dz = 2\\pi i\\sum_{k=1}^n\\text{Res}[f(z),z_k]\\] 其中\\(z_k(k=1,2,\\cdots,n)\\)为圆周\\(|z| = 1\\)内的孤立奇点。值得注意，三角函数有理式的定积分只有在积分区间长度为\\(2\\pi\\)时，才可由变换\\(z = e^{i\\theta}\\)化为单位圆周上的复闭路积分。 对于形如\\(\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)dx\\)的积分，当满足三个条件时，有\\(\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)dx = 2\\pi i \\sum_{k}\\text{Res}[R(z),z_k]\\)，其中\\(\\{z_k\\}\\)为上半复平面的所有孤立奇点： \\(\\displaystyle R(x) = \\frac{P(x)}{Q(x)}\\)，其中\\(P(x)\\)和\\(Q(x)\\)为多项式； 分母\\(Q(x)\\)的次数比分子\\(P(x)\\)的次数至少高两次； 分母\\(Q(x)\\)没有实零点。 事实上，设\\(R(z) = \\displaystyle \\frac{z^n + a_1 z^{n-1} + \\cdots a_n}{z^m + b_1 z^{m-1} + \\cdots b_m}, m - n \\geq 2\\)，显然\\(R(z)\\)只有有限个孤立的极点，取积分路径如图所示，其中\\(C_R\\)是以原点为中心，\\(R\\)为半径的上半平面的半圆周。取\\(R\\)适当大，使得\\(R(z)\\)所有的在上半平面的所有极点都被包在这闭路积分曲线\\(C = [-R,R] + C_R\\)内。 因此有： \\[\\oint_{C}R(z)dz = \\int_{-R}^{R}R(x)dx + \\int_{C_R}R(z)dz = 2\\pi i\\sum\\text{Res}[R(z), z_k]\\] 根据闭路变形原理，该等式不因\\(C_R\\)的半径\\(R\\)的不断增大而有所改变，即： \\[\\lim_\\limits{R \\to +\\infty}[\\int_{-R}^{R}R(x)dx + \\int_{C_R}R(z)dz] = 2\\pi i\\sum\\text{Res}[R(z), z_k]\\] 现需对\\(\\displaystyle \\int_{C_R}R(z)dz\\)进行估计，先有： \\[|R(z)| = \\frac{1}{|z|^{m-n}}\\frac{|1+a_1z^{-1}+\\cdots +a_n z^{-n}|}{|1+b_1z^{-1}+\\cdots +b_m z^{-m}|} \\leq \\frac{1}{|z|^{m-n}}\\frac{1+|a_1z^{-1}+\\cdots +a_n z^{-n}|}{1-|b_1z^{-1}+\\cdots +b_m z^{-m}|}\\] 当\\(|z|\\)充分大时,总有： \\[|a_1z^{-1}+\\cdots +a_n z^{-n}| &lt; \\frac{1}{10}, |b_1z^{-1}+\\cdots +b_m z^{-m}| &lt; \\frac{1}{10}\\] 再由\\(m-n \\geq 2\\)，有： \\[|R(z)| &lt; \\frac{1}{|z|^{m-n}} \\cdot \\frac{1 + \\displaystyle \\frac{1}{10}}{1 - \\displaystyle \\frac{1}{10}} &lt; \\frac{2}{|z|^2}\\] 最终有： \\[\\int_{C_R}R(z)dz \\leq \\int_{C_R}|R(z)|ds \\leq \\frac{2}{R^2}\\pi R &lt; \\frac{2\\pi}{R}\\] 令\\(R\\to +\\infty\\)，则\\(\\displaystyle \\int_{C_R}R(z)dz \\to 0\\)，所以： \\[\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)dx = 2\\pi i \\sum_{k}\\text{Res}[R(z),z_k]\\] 对于形如\\(\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)e^{iax}dx(a &gt; 0)\\)的积分，当满足三个条件时： \\(\\displaystyle R(x) = \\frac{P(x)}{Q(x)}\\)，其中\\(P(x)\\)和\\(Q(x)\\)为多项式； 分母\\(Q(x)\\)的次数比分子\\(P(x)\\)的次数至少高一次； 分母\\(Q(x)\\)没有实零点， 有\\(\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)dx = 2\\pi i \\sum_{k}\\text{Res}[R(z)e^{iaz},z_k]\\)，其中\\(\\{z_k\\}\\)为上半复平面的所有孤立奇点。注意到： \\[\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)dx = 2\\pi i \\sum_{k}\\text{Res}[R(z)e^{iaz},z_k] = A+iB\\] 由欧拉公式有\\(\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)\\cos ax dx = A\\)和\\(\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)\\sin ax dx = B\\)，即要求上述类型的广义定积分，可转化为形如\\(\\displaystyle \\int_{-\\infty}^{+\\infty}R(x)e^{iax}dx(a &gt; 0)\\)的复积分然后再用留数求解。 共形映射 之前的内容从数的角度对解析函数进行了研究，本章将从形的角度探究解析函数的相关性质。 本章不再另作笔记，可以查阅教材。 Fourier 变换 周期函数的 Fourier 级数 三角函数系的正交性 不妨记： \\[S_{\\omega_0}=\\{1, \\sin \\omega_0 t, \\cdots, \\sin n \\omega_0 t,\\cdots, \\cos \\omega_0 t , \\cdots, \\cos n \\omega_0 t, \\cdots\\},n\\in \\text{N}\\] 那么\\(\\forall f(t), g(t) \\in S_{\\omega_0}, f(t) \\neq g(t) \\Leftrightarrow \\displaystyle \\int_{t_0}^{t_0+T}f(t)g(t)dt=0\\)，其中\\(T = \\displaystyle\\frac{2\\pi}{\\omega_0}\\)，这一性质被称为三角函数系的正交性，这一性质在求解 Fourier 级数被使用。 Fourier 级数的三角形式 记\\(f_{T}(t)\\)是以\\(T\\)为周期的函数，若函数在\\([\\displaystyle -\\frac{T}{2},\\frac{T}{2}]\\)满足 Dirichlet 条件： 连续或只有有限个第一类间断点； 只有有限个极值点， 令\\(\\omega_0 = \\displaystyle \\frac{2\\pi}{T}\\)（称为基频），则在\\(f_T(t)\\)的连续点处，有； \\[f_{T}(t)=\\displaystyle \\frac{a_0}{2}+\\sum_{n=1}^{\\infty}(a_n \\cos n\\omega_0 t+b_n \\sin n \\omega_0 t)\\] 在间断点处，上式左端为\\(\\displaystyle \\frac{1}{2}[f_T(t+0)+f_T(t-0)]\\)，这就是 Fourier 级数的三角形式，式中的各项系数可由如下公式求出： \\[a_n=\\displaystyle \\frac{2}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f_T(t) \\cos n\\omega_0 tdt,n=0,1,2,\\cdots\\] \\[b_n=\\displaystyle\\frac{2}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f_T(t) \\sin n\\omega_0 tdt,n=1,2,\\cdots\\] 注意\\(b_{-n}=-b_n\\)，这一点会在求解傅里叶级数的复指数形式中出现。 事实上，还可以对 Fourier 级数的三角形式进行改写： \\[A_0 = \\displaystyle \\frac{a_0}{2},$A_n = \\sqrt{a_n^2 + b_n^2},\\cos \\theta_n = \\frac{a_n}{A_n}, \\sin \\theta = \\frac{-b_n}{A_n}\\] \\[\\Rightarrow f_T(t) = A_0 + \\sum_{n = 1}^{\\infty}A_n\\cos(n \\omega_0 t + \\theta_n)\\] 其中，振幅\\(A_n\\)反映了在信号\\(f_T(t)\\)中频率为\\(n\\omega_0\\)的简谐波所占有的份额，相位\\(\\theta_n\\)反映了信号\\(f_T(t)\\)中频率为\\(n\\omega_0\\)的简谐波沿着时间轴移动的大小，这两个指标完全定量地刻画了信号的频率特征。这说明了周期信号重要的两个特点： 周期信号可以分解为一些列固定频率的简谐波之和，这些简谐波的角频率分别为基频\\(\\omega_0\\)的倍数； 任何一个周期为\\(T\\)的周期信号\\(f_T(t)\\)并不包含所有的频率成分，其频率时以基频\\(\\omega_0\\)为间隔离散地取值的。 Fourier 级数的指数形式 利用复指数的性质可知： \\[\\forall \\theta \\in \\text{R}, e^{j\\theta}=\\cos\\theta + j\\sin\\theta \\Rightarrow \\sin \\theta =\\displaystyle \\frac{e^{j\\theta}-e^{-j\\theta}}{2j},\\cos \\theta = \\displaystyle \\frac{e^{j\\theta}+e^{-j\\theta}}{2}\\] 对 Fourire 级数的三角形式中使用欧拉公式可得： \\[f_{T}(t)=\\frac{a_0}{2}+\\sum_{n=1}^{\\infty}(\\frac{a_n-jb_n}{2}e^{jn\\omega_0 t} + \\frac{a_n+jb_n}{2}e^{-jn \\omega_0 t})\\] 若令\\(c_0=\\displaystyle\\frac{a_0}{2}=\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f_{T}(t)dt\\)及\\(c_n\\displaystyle=\\frac{a_n-jb_n}{2}=\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f_{T}(t)e^{-jn \\omega t}dt\\)，可得到傅里叶级数得复指数形式： \\[f_{T}(t)=\\sum_{n=-\\infty}^{+\\infty}c_ne^{jn\\omega_0 t}\\] 对于 Fourier 级数的指数形式有三点说明： 对于给定的函数，其 Fourier 级数的展开式是唯一的； 在计算展开系数\\(c_n\\)时，可以在任意一个长度为\\(T\\)的区间上计算其中的积分； 利用解析延拓，可以将结论运用在只定义在某个有限区间上的函数，换言之，定义在有限区间上的函数，同样可以展开为 Fourier 级数。 类似三角形式，复指数形式也可以考虑其几何意义，不难得出\\(|c_n|\\)是振幅、\\(\\text{arg}c_n\\)是相位的结论。 Fourier 级数的物理含义 对于复指数形式的级数而言，称\\(|c_n|\\)为振幅谱，\\(\\text{arg}c_n\\)为相位谱，称\\(c_n\\)为频谱。频谱图将\\(|c_n|\\)、\\(\\text{arg}c_n\\)与角频率\\(n\\omega_0\\)的关系画成图形。 非周期函数的 Fourier 变换 Fourier 积分公式与 Fourier 变换的定义 借助 Fourier 级数的展开，人们能够利用频谱分析的手段对周期信号进行分析，然而频谱分析的手段对实际问题中存在着的大量的非周期函数却是无效的。因此引入 Fourier 积分，考虑对非周期函数进行频谱分析。设\\(f(t)\\)满足如下条件： 在\\((-\\infty, +\\infty)\\)上的任何一个有限区间都满足 Dirichlet 条件； 绝对可积， 则在\\(f(t)\\)的连续点处有： \\[f(t) = \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\bigg[\\int_{-\\infty}^{+\\infty} f(t) e^{-j\\omega t} dt \\bigg]e^{j\\omega t}d\\omega\\] 在间断点处，上式左端为\\(\\displaystyle \\frac{1}{2}[f(t+0)+f(t-0)]\\)，这就是 Fourier 级数的三角形式。 以下推导从形式上得到了函数的 Fourier 积分。 \\[f_{T}(t)=\\displaystyle \\sum_{n=-\\infty}^{+\\infty}c_ne^{j n \\omega t}=\\frac{1}{T}\\sum_{n=-\\infty}^{+\\infty}e^{jn\\omega t}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f_{T}(t)e^{-jn\\omega t}dt,\\omega_n=n\\omega_0\\] 令\\(\\Delta \\omega_n=\\omega_{n+1}-\\omega_{n}\\)，那么\\(\\Delta \\omega_n=\\displaystyle\\frac{2\\pi}{T}\\to0 \\Rightarrow T\\to +\\infty\\)，记\\(f(t)=\\lim_\\limits{T\\to+\\infty}f_T(t)\\)，即可得到 Fourier 积分： \\[f(t)=\\lim_\\limits{\\Delta \\omega_n \\to 0} \\displaystyle\\frac{1}{2\\pi} \\sum_{n=-\\infty}^{+\\infty}e^{j \\omega_n t} \\Delta \\omega_n \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f(t)e^{-j n \\omega t}d t=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\bigg[\\int_{-\\infty}^{+\\infty} f(t) e^{-j\\omega t} dt \\bigg]e^{j\\omega t}d\\omega\\] 事实上，函数\\(f(t)\\)的 Fourier 积分实际上是对函数先后进行了 Fourier 变换和 Fourier 逆变换，即： \\[F(\\omega) = \\mathcal{F}[f(t)]=\\displaystyle \\int_{-\\infty}^{+\\infty}f(t)e^{-j\\omega t}dt\\] \\[f(t)=\\mathcal{F}^{-1}[F(\\omega)] = \\displaystyle \\frac{1}{2\\pi} \\int_{-\\infty}^{+\\infty}F(\\omega)e^{j\\omega t}d \\omega\\] 其中\\(F(\\omega)\\)被称为象函数，\\(f(t)\\)被称为象原函数，称\\(f(t) \\leftrightarrow F(\\omega)\\)为 Fourier 变换对。注意上述变换中的广义积分都取 Cauchy 主值，因此进行相关计算时要利用好 Euler 公式和奇偶性。 Fourier 变换的物理含义 与周期函数的 Fourier 级数的物理意义一样，非周期函数的 Fourier 变换同样刻画了频谱特性，不同之处在于非周期函数的频谱是连续取值的。象函数\\(F(\\omega)\\)反映的是函数\\(f(t)\\)中各频率分量的分布密度，它是复值函数，故可以表示为\\(F(\\omega) = |F(\\omega)|e^{j \\text{arg}F(\\omega)}\\)。称\\(F(\\omega)\\)为频谱密度函数（简称为连续频谱或者频谱）；称\\(|F(\\omega)|\\)为振幅谱；称\\(\\text{arg}F(\\omega)\\)为相位谱。 单位冲激函数 基本概念 在如数学、物理学以及实际工程技术中，一些常用的函数都不能进行 Fourier 变换；并且有很多瞬时物理量无法用通常的函数进行描述，例如质点等等。为此引入单位冲激函数（也称 Dirac 函数或\\(\\delta\\)函数）\\(\\delta(t)\\)： 当\\(t \\neq 0\\)时，\\(\\delta = 0\\)； \\(\\displaystyle \\int_{-\\infty}^{+\\infty}\\delta(t)dt = 1\\)。 关于 Dirac 函数，应当注意以下两点： 该函数并非是经典意义下的函数，因此通常称之为广义函数或者奇异函数； 它不能用通常意义下的映射来理解设使用，而总是通过它的性质来使用它。 性质 Dirac 函数具有如下性质： 筛选性质 设函数\\(f(t)\\)定义在\\(\\text{R}\\)上的有界函数，且在\\(t=t_0\\)处连续，则： \\[\\displaystyle\\int_{-\\infty}^{+\\infty}\\delta(t-t_0)f(t)dt = f(t_0)\\] 对称性质 Dirac 函数是偶函数； 积分性质 Heaviside 函数被定义为\\(u(t) = \\left\\{\\begin{matrix} 1, t &gt; 0 \\\\ 0, t &lt; 0 \\end{matrix}\\right.\\)，那么\\(\\displaystyle \\int_{-\\infty}^t\\delta(t)dt = u(t)\\)，反过来，等式两端对\\(t\\)求导有\\(u&#39;(t) = \\delta(t)\\)。 图形表示 通常用一条从原点出发的、长度为\\(1\\)的有向线段来表示，有向线段的长度被称为冲激强度。 Dirac 函数的 Fourier 变换 易得 Fourier 变换对\\(\\delta(t) \\leftrightarrow 1\\)，可知单位冲激函数包含所有的频率成分，且它们具有相同的幅度，故称此频谱图为均匀频谱或白色频谱。 并且可以得到重要公式： \\[\\int_{-\\infty}^{+\\infty}e^{j\\omega t}d\\omega = 2\\pi \\delta(t)\\] 在\\(\\delta\\)函数的 Fourier 变换中，其广义积分是根据\\(\\delta\\)函数的筛选性质直接给出的，而不是按照通常的积分方式得到的，这样的变换被称为广义 Fourier 变换。在使用\\(\\delta\\)函数时，应当牢记三个性质和一个上述重要公式。 Fourier 变换的性质 线性性质 由积分的线性显而易见。 位移性质 设\\(t_0\\)和\\(\\omega_0\\)都是常数，则： 时移性质 \\(\\mathcal{F}[f(t\\pm t_0)]=e^{\\pm j\\omega t_0}\\mathcal{F}[f(t)]\\)； 频移性质 \\(\\mathcal{F}^{-1}[f(\\omega \\pm \\omega_0)]=f(t)e^{\\mp j\\omega_0 t}\\)。 相似性质 设\\(a\\)为非零常数，则\\(\\mathcal{F}[f(at)] = \\displaystyle\\frac{1}{|a|}F(\\frac{\\omega}{a})\\)。 微分性质 若\\(\\lim\\limits_{|t|\\to \\infty}f(t)=0\\)，那么\\(\\mathcal{F}[f&#39;(t)]=j\\omega \\mathcal{F}[f(t)]=j\\omega F(\\omega)\\)。 \\[\\mathcal{F}[f&#39;(t)]=\\displaystyle \\int_{-\\infty}^{+\\infty}f&#39;(t)e^{-j\\omega t}dt=\\int_{-\\infty}^{+\\infty}e^{-j\\omega t}d[f(t)]=j\\omega\\int_{-\\infty}^{+\\infty}f(t)e^{-j\\omega t}dt=j\\omega\\mathcal{F}[f(t)]\\] 还可以得到象函数导数的表达式，下式经常用于求解\\(\\mathcal{F}[tf(t)]\\)。 \\[\\displaystyle \\frac{d}{d \\omega}F(\\omega)=\\frac{d}{d\\omega}\\int_{-\\infty}^{+\\infty}f(t)e^{-j\\omega t}dt=-j\\int_{-\\infty}^{+\\infty}tf(t)e^{-j\\omega t}dt=-j \\mathcal{F}[tf(t)]\\] 以下是两个常用结论。 \\[\\mathcal{F}[f^{(n)}(t)]=(j\\omega)^n\\mathcal{F}[f(t)]\\] \\[\\displaystyle \\frac{d^n}{d\\omega^n}F(\\omega)=(-j)^n\\mathcal{F}[t^nf(t)] \\Leftrightarrow \\mathcal{F}[t^nf(t)]=j^n\\frac{d^n}{d\\omega^n}F(\\omega)\\] 积分性质 若\\(\\displaystyle\\lim_\\limits{t\\to +\\infty}\\int_{-\\infty}^tf(u)du=0\\)，那么： \\[\\mathcal{F}[\\displaystyle \\int_{-\\infty}^t f(u)du]=\\frac{1}{j\\omega}\\mathcal{F}[f(t)]\\] Parseval 等式 *本节中所有上划线均代表复数共轭。 记\\(F(\\omega)=\\mathcal{F}[f(t)]\\)，那么有： \\[\\displaystyle\\int_{-\\infty}^{+\\infty}f^2(t)dt=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}|F(\\omega)|^2d\\omega\\] 该性质也被称为能量积分性质。 为了证明上式，首先需要证明傅里叶变换的乘法性质。记\\(F_i(\\omega)=\\mathcal{F}[f_i(t)], i=1,2\\)，那么： \\[\\displaystyle \\int_{-\\infty}^{+\\infty}f_1(t)\\overline{f_2(t)}dt=\\int_{-\\infty}^{+\\infty}[\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F_1(\\omega)e^{j\\omega t}d\\omega ]\\overline{f_2(t)}dt=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F_1(\\omega)[\\int_{-\\infty}^{+\\infty}\\overline{f_2(t)}e^{j \\omega t}dt]d\\omega\\] \\(=\\displaystyle \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F_{1}(\\omega)[\\int _{-\\infty}^{+\\infty}\\overline{f_2(t)e^{-j\\omega t}} dt]d\\omega=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F_1(\\omega)\\overline{F_2(\\omega)}d\\omega\\) 上式就是是傅里叶变换的乘法性质。令\\(f_1(t)=f_2(t)=f(t)\\)，那么有能量积分： \\[\\displaystyle \\int_{-\\infty}^{+\\infty}[f(t)]^2dt=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty} |F(\\omega)|^2 d\\omega\\] 例如，可以利用能量积分求解\\(\\displaystyle \\int_{-\\infty}^{+\\infty}(\\frac{\\sin t}{t})^2dt\\)。 \\[\\displaystyle \\int_{-\\infty}^{+\\infty}(\\frac{\\sin t}{t})^2dt=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}|\\mathcal{F}(\\frac{\\sin t}{t})|^2dt\\] \\[\\displaystyle\\mathcal{F}(\\frac{\\sin t}{t})=\\int_{-\\infty}^{+\\infty} \\frac{\\sin t}{t} e^{-j\\omega t} dt=\\int_{-\\infty}^{+\\infty}\\frac{\\sin t \\cos \\omega t}{t}dt\\] 又 \\(\\displaystyle \\int_{-\\infty}^{+\\infty}\\frac{\\sin t \\cos \\omega t}{t}dt=\\left\\{\\begin{aligned}\\pi,|\\omega|&lt;1\\\\0,\\text{others}\\end{aligned}\\right.\\)，因此\\(\\displaystyle \\int_{-\\infty}^{+\\infty}(\\frac{\\sin t}{t})^2dt=\\pi\\)。 卷积性质 设\\(\\mathcal{F}[f_i(t)] = F_i(\\omega), i =1,2\\)，那么： \\(\\mathcal{F}[f_1(t) * f_2(t)] = F_1(\\omega) * F_2(\\omega)\\)； \\(\\mathcal{F}^{-1}[f_1(t) * f_2(t)] = 2\\pi f_1(\\omega) * f_2(\\omega)\\)。 下面证明\\(\\mathcal{F}[f_1(t) * f_2(t)] = F_1(\\omega) * F_2(\\omega)\\)： \\[\\mathcal{F}[f_1(t) * f_2(t)] = \\int_{-\\infty}^{+\\infty}[\\int_{-\\infty}^{+\\infty} f_1(\\tau)f_2(t - \\tau) d\\tau]e^{-j\\omega t}dt \\] \\[= \\int_{-\\infty}^{+\\infty}[\\int_{-\\infty}^{+\\infty} f_1(\\tau)f_2(t - \\tau) dt]e^{-j\\omega t}d\\tau\\] \\[= \\int_{-\\infty}^{+\\infty}f_1(\\tau)e^{-j\\omega \\tau}[\\int_{-\\infty}^{+\\infty} f_2(t - \\tau) e^{-j\\omega(t-\\tau)} dt]d\\tau = F_1(\\omega) * F_2(\\omega)\\] 另外一个性质同理可证。 Fourier 变换的一些例子 例1 求矩形密度函数\\(f(t) = \\left\\{\\begin{matrix}1, |t| \\leq a \\\\ 0, |t| &gt; a \\end{matrix}\\right.(a &gt; 0)\\)的 Fourier 变换以及其 Fourier 积分表达式。 \\[F(\\omega) = \\mathcal{F}[f(t)] = \\int_{-a}^{a}e^{-j\\omega t}dt = \\frac{e^{j\\omega a} - e^{-j\\omega a}}{j\\omega} = \\frac{2}{\\omega}\\sin a \\omega =2a \\frac{\\sin a\\omega}{a\\omega}\\] 振幅谱为\\(\\displaystyle |F(\\omega)| = 2a|\\frac{\\sin a\\omega}{a\\omega}|\\)，相位谱为\\(\\text{arg}F(\\omega )=\\left\\{\\begin{matrix}\\displaystyle0, \\frac{2n\\pi}{a} \\leq |\\omega| \\leq \\frac{(2n+1)\\pi}{a} \\\\ \\pi, \\text{others}\\end{matrix}\\right.\\)，函数的 Fourier 积分表达式为： \\[f(t) =\\mathcal{F}^{-1}[f(\\omega)]= \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F(\\omega)e^{j\\omega t}d\\omega =\\frac{1}{\\pi}\\int_{-\\infty}^{+\\infty}\\frac{\\sin a\\omega \\cos \\omega t}{\\omega}d\\omega = \\left\\{\\begin{matrix}1,|t|&lt;a \\\\ \\displaystyle \\frac{1}{2}, |t| = a \\\\ 0, |t| &gt; a\\end{matrix}\\right.\\] 在上式中令\\(t = 0\\)，可得 Dirichlet 积分的结果： \\[\\int_{-\\infty}^{+\\infty}\\frac{\\sin ax}{x}dx = \\pi(a &gt; 0)\\] 例2 已知函数\\(f(t)\\)的频谱为\\(F(\\omega) = \\displaystyle \\frac{2}{j\\omega}\\)，求\\(f(t)\\)。 \\[f(t) = \\mathcal{F}^{-1}[F(\\omega)] = \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F(\\omega)e^{j\\omega t}d \\omega = \\frac{1}{\\pi}\\int_{-\\infty}^{+\\infty}\\frac{\\sin \\omega t}{\\omega}d\\omega = \\left\\{\\begin{matrix} 1, t&gt; 0 \\\\ 0, t = 0 \\\\ -1, t &lt; 0 \\end{matrix}\\right.\\] 由这个例子可得 Fourier 变换对\\(\\text{sgn}t \\leftrightarrow \\displaystyle\\frac{2}{j\\omega}\\)，这也是一个常用的结果，需要记住。 例3 已知函数\\(f(t)\\)的频谱为\\(F(\\omega) = \\left\\{\\begin{matrix} 1, |\\omega| \\leq a\\\\ 0, |\\omega| &gt; a \\end{matrix}\\right.(a&gt;0)\\)，求\\(f(t)\\)。 \\[f(t) = \\mathcal{F}[F(\\omega)] = \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F(\\omega)e^{j\\omega t}d\\omega = \\frac{\\sin at}{\\pi t}\\] 例4 分别求\\(f_1(t) =1\\)与\\(f_2(t) = t\\)的 Fourier 变换。 \\[F_1(\\omega) = \\int_{-\\infty}^{+\\infty}f_1(t)e^{-j\\omega t}dt = 2\\pi \\delta(\\omega)\\] 事实上，在上式两端对\\(\\omega\\)求导有： \\[-j\\int_{-\\infty}^{+\\infty}te^{-j\\omega t}dt = 2\\pi \\delta&#39;(t)\\Rightarrow F_2(\\omega) = 2j\\omega\\delta&#39;(\\omega)\\] 例5 求 Heaviside 的 Fourier 变换。 事实上，\\(u(t) = \\displaystyle \\frac{1}{2}(\\text{sgn}t + 1)\\)，由 Fourier 变换的性质易得： \\[F(\\omega) = \\mathcal{F}[u(t)] = \\frac{1}{j\\omega} + \\pi \\delta(t)\\] 例6 分别求\\(f_1(t) =e^{j\\omega_0 t}\\)与\\(f_2(t) = \\cos \\omega_0 t\\)的 Fourier 变换。 \\[F_1(\\omega) = \\int_{-\\infty}^{+\\infty}e^{j(\\omega_0 - \\omega)t}dt =2\\pi \\delta(\\omega_0 - \\omega) = 2\\pi \\delta(\\omega - \\omega_0)\\] 由欧拉公式及 Fourier 变换的性质易得： \\[F_2(\\omega) = \\frac{1}{2}[\\mathcal{F}(e^{j\\omega_0t})+\\mathcal{F}(-j\\omega_0t)] = \\pi[\\delta(\\omega - \\omega_0)+\\delta(\\omega + \\omega_0)]\\] 又得到一个常用的变换对\\(e^{j\\omega_0 t}\\leftrightarrow 2\\pi \\delta(\\omega - \\omega_0)\\)。 例7 求函数\\(h(t)\\)与\\(\\delta(t)\\)的卷积。 \\[h(t)*\\delta(t) = \\int_{-\\infty}^{+\\infty}h(\\tau)\\delta(t-\\tau)d\\tau = h(t)\\] 这说明了卷积运算的单位元是\\(\\delta(t)\\)。一般地，有\\(h(t)*\\delta(t-t_0) =h(t-t_0)\\)。 Lapalce 变换 Laplace 变换的概念 实际工程问题中，许多以时间\\(t\\)为自变量的函数在\\(t&lt;0\\)时为\\(0\\)或者没有定义，因此对这些函数进行 Fourier 变换时，不能或者没有必要在整个实轴上进行，因此考虑对 Fourier 变换进行改造，具体方法如下： 将\\(f(t)\\)与\\(u(t)\\)相乘，使得函数在\\(t &lt; 0\\)时恒被定义为\\(0\\)； 再乘以指数衰减函数\\(e^{-\\beta t}(\\beta &gt; 0)\\)，使得函数在\\(t &gt; 0\\)时尽快衰减下来，以满足 Fourier 变换的的条件。 于是得到： \\[\\mathcal{F}[f(t)u(t)e^{-\\beta t}] = \\int_{0}^{+\\infty}f(t)e^{-(\\beta + j \\omega)t}dt\\] 将\\(\\beta + j\\omega\\)记作\\(s\\)，那么得到一种新的变换： \\[F(s)=\\mathcal{L}[f(t)]=\\displaystyle \\int_{0}^{+\\infty}f(t)e^{-st}dt\\] 值得注意的是，上述广义积分结果存在的关键是变量\\(s\\)的实部\\(\\beta\\)足够大。这时可以给出 Laplace 变换的严格定义。设函数\\(f(t)\\)是定义在\\((0,+\\infty)\\)的实变函数，若对于复参数\\(s =\\beta +j\\omega\\)，上式积分在复平面某一区域收敛，那么称\\(F(s)\\)是\\(f(t)\\)的 Laplace 变换或象函数，记作\\(F(s) = \\mathcal{L}[f(t)]\\)，相应地称\\(f(t)\\)是\\(F(s)\\)的 Laplace 逆变换或象原函数。 在进行积分时，要确定\\(s\\)的范围以保证积分存在，下面给出象函数的存在定理。设函数\\(f(t)\\)在\\(t\\geq 0\\)时满足以下两个条件，则象函数\\(F(s)\\)一定在半平面\\(\\text{Re}(s) &gt; c\\)上存在且解析。 在任何的有限区间上分段连续； 具有有限的增长性，即存在常数\\(c\\)及\\(M &gt; 0\\)使得\\(|f(t)| \\leq Me^{ct}\\)（其中\\(c\\)被称为\\(f(t)\\)的增长指数）。 根据存在定理，可以知道： 象函数的存在域一般是一个右半平面，即只需复数\\(s\\)的实部足够大即可，因此在进行 Laplace 变换时，通常略去存在域，只在非常必要时才会特别注明； 在 Laplace 变换中的函数通常约定在\\(t&lt;0\\)时恒为\\(0\\)，即函数\\(f(t)\\)等价于\\(f(t)u(t)\\)。 Laplace 变换的性质 线性性质 由积分的线性显而易见。 相似性质 设\\(a\\)为正实数，则\\(\\mathcal{L}[f(at)] = \\displaystyle\\frac{1}{a}F(\\frac{s}{a})\\)。 延迟性质和位移性质 延迟性质 对任何一负实数有\\(\\tau\\)有： \\[\\mathcal{L}[f(t-\\tau)u(t-\\tau)]=e^{-s\\tau}F(s)\\Leftrightarrow \\mathcal{L}^{-1}[e^{-s\\tau}F(s)]=f(t-\\tau)u(t-\\tau)\\] 位移性质 设\\(a\\)为一复常数，则\\(\\mathcal{L}[e^{at}f(t)] = F(s- a)\\)。 微分性质 积分性质 Laplace 逆变换 Laplace 变换的变换及综合举例 常用结论 反常积分 \\[\\displaystyle \\int_{0}^{+\\infty}x^ne^{-\\lambda x}dx=\\frac{n!}{\\lambda^{n+1}}(\\lambda &gt; 0, n \\in \\text{N}^+)\\] \\[\\displaystyle \\int_{0}^{+\\infty}e^{-\\lambda x} \\cos ax dx = \\frac{\\lambda}{\\lambda^2 + a^2}(\\lambda &gt; 0)\\] \\[\\displaystyle \\int_{0}^{+\\infty}e^{-\\lambda x} \\sin ax dx = \\frac{a}{\\lambda^2+a^2}(\\lambda &gt; 0)\\] \\(\\delta(t)\\)的性质 \\[\\displaystyle \\int_{-\\infty}^{+\\infty}\\delta(t)dt=1\\] \\[\\displaystyle \\delta(t) := \\lim_\\limits{\\epsilon \\to 0} \\delta_{\\epsilon}(t)\\] \\[\\displaystyle \\int_{-\\infty}^{+\\infty}f(t)\\delta(t)dt = f(0)\\] \\[\\displaystyle \\int_{-\\infty}^{+\\infty}\\delta^{(n)}(t)f(t)dt=(-1)^nf^{(n)}(0)\\] 常用的 Fourier 变换 \\[\\displaystyle \\mathcal{F}[u(t)]=\\frac{1}{j \\omega} + \\pi \\delta(\\omega)\\] \\[\\displaystyle \\mathcal{F}[\\delta(t)] = 1\\] \\[\\mathcal{F}[e^{j\\omega_0t}]=2\\pi\\delta(\\omega - \\omega_0) \\Rightarrow \\mathcal{F}(1)=2\\pi\\delta(\\omega)\\] \\[\\mathcal{F}[\\sin \\omega_0 t]=\\pi j[\\delta(\\omega+\\omega_0)-\\delta(\\omega-\\omega_0)]\\] \\[\\mathcal{F}[\\cos \\omega_0t]=\\pi[\\delta(\\omega+\\omega_0)+\\delta(\\omega-\\omega_0)]\\] \\[\\mathcal{F}[e^{j\\omega_0 t}]=\\mathcal{F}(\\cos \\omega_0 t) + j \\mathcal{F}(\\sin \\omega_o t)\\] 常用的 Laplace 变换 \\[\\mathcal{L}[1] = \\displaystyle \\frac{1}{s}\\] \\[\\mathcal{L}[t^m] = \\displaystyle \\frac{\\Gamma(m + 1)}{s^{m+1}}\\] \\[\\mathcal{L}[e^at] = \\displaystyle \\frac{1}{s - a}\\] \\[\\mathcal{L}[\\cos at] = \\displaystyle \\frac{s}{s^2+a^2}\\] \\[\\mathcal{L}[\\sin at] = \\displaystyle \\frac{a}{s^2+a^2}\\] 其他常用的恒等式 \\[\\sin3t=3\\sin t - 4\\sin^3t\\] \\[\\omega^4+4=[(\\omega+1)^2+1][(\\omega-1)^2+1]\\] 解题技巧 对形如\\(e^{j \\omega t}\\)函数的积分时，当积分下限为\\(-\\infty\\)考虑\\(\\delta(\\omega - \\omega_0)\\)； 广义函数在证明相同的时候考虑使用\\(\\text{R}\\)上的积分； \\(\\delta_1(x)=\\delta_2(x) \\Leftrightarrow \\displaystyle \\int_{R}\\delta_1(x)dx=\\int_{R}\\delta_2(x)dx\\) 在证明\\(\\delta(t)\\)的相关性质时，要注意\\(f(t)\\)需要是无穷次可微函数。 参考资料 【上海交通大学】姚卫红《复变函数与概率》； 复变函数与积分变换（华中科技大学）； 《复变函数（第四版）》，西安交通大学高等数学教研室； 《积分变换（第五版）》，东南大学数学系； 《复变函数与积分变换》，南开大学出版社。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"两篇体系结构方向英文论文阅读笔记","slug":"两篇体系结构方向英文论文阅读笔记","date":"2022-09-30T09:06:15.000Z","updated":"2022-10-02T09:27:20.524Z","comments":true,"path":"2022-09-30-两篇体系结构方向英文论文阅读笔记/","link":"","permalink":"http://example.com/2022-09-30-%E4%B8%A4%E7%AF%87%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B9%E5%90%91%E8%8B%B1%E6%96%87%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"首次阅读这方面的英文论文，有不足和错误之处还望各位不吝赐教。","text":"首次阅读这方面的英文论文，有不足和错误之处还望各位不吝赐教。 SALO 这篇文章主要介绍了为降低机器学习中的 self-attention 机制计算复杂度而设计的一套软硬件系统。 主要计算过程 为了简单起见，首先考虑一个包含\\(4\\)个输入列向量的矩阵\\(I=[a_1^T;a_2^T;a_3^T;a_4^T]\\)，自注意力机制中涉及的主要计算公式过程包括以下过程。 得到\\(Q\\)、\\(K\\)和\\(V\\)矩阵 \\[Q = W^q \\cdot I\\] \\[K = W^k \\cdot I\\] \\[V = W^v \\cdot I\\] 利用\\(Q\\)和\\(K\\)计算每两个输入向量之间的相关性 \\[A = K^T \\cdot Q,\\ \\text{where} \\ a_{i,j}=(q^i)^T \\cdot k^j\\] 图1-1 矩阵\\(A\\)图示 对\\(A\\)使用\\(\\text{softmax}\\)函数进行激活，得到矩阵\\(A&#39;\\) \\[a&#39;_{i,j} = \\text{softmax}(a_{i,j}) = \\displaystyle \\frac{e^{a_{i,j}}}{\\displaystyle \\sum_{i = 1} ^ {4}\\sum_{j = 1} ^ {4} e^{a_{i,j}}}\\] 最终得到输出矩阵\\(O\\) \\[O = V \\cdot A&#39;,\\ \\text{where}\\ b_i = \\sum_{j=1}^4 v_i \\alpha&#39;_{i,j}\\] 图1-2 矩阵\\(O\\)图示 文章设计的解决方案 Sparse Attention Mechanisms ScaleHLS 参考资料 SALO 第四周(2)自注意力机制(Self-Attention) ScaleHLS","categories":[],"tags":[]},{"title":"Hello, world!","slug":"hello-world","date":"2022-09-30T02:42:34.000Z","updated":"2023-01-14T12:03:58.305Z","comments":true,"path":"2022-09-30-hello-world/","link":"","permalink":"http://example.com/2022-09-30-hello-world/","excerpt":"记录一下网站的配置过程，方便以后查阅。","text":"记录一下网站的配置过程，方便以后查阅。 公式渲染和代码高亮的问题卡了一天，最后直接重用了旧版本的 Volantis 搭建的博客的代码。 前言 一直有建立个人网站的想法，借着大三上学期选修课的机会终于是尝试动手了，2021年9月23日正式搭起了博客。为了应付课程（主要是有服务器配置的内容），我从腾讯云购买服务器与域名（有优惠的话第一年的价格还算比较美丽）。2022年9月份，收到了腾讯云关于服务器和域名快要到期的通知短信，终于又想起了自己原来还搞了小博客。个人网站是可以发布在 Github 上的，可以省下一笔不小的开支；如果希望域名能自定义则需要多花个域名的钱。此外，博客图片过多的话也可以考虑使用图床。 环境搭建 以下内容均基于 Windows 10，必要的工具有 npm 、 Hexo 、 OpenSSH 以及 git 。 npm 新版的 Node.js已经集成了 npm ，因此查找 Node.js 的安装教程即可。 Hexo 如果 npm 已经安装完成，那么只需使用如下命令即可安装 Hexo 及其 Github 部署工具。 1npm install hexo-cli -g &amp;&amp; npm install hexo-deployer-git --save git 与 OpenSSH 中文互联网上教程很多，并且基本没有什么太大的问题，在此不再赘述。 搭建仓库 在 Github 上登陆账号并新建一个仓库即可，注意仓库名必须是 username.github.io ，其中 username 是 Github 上的用户名。 生成 SSH keys 安装好 OpenSSH 后，使用如下命令创建公钥与私钥，其中 github-email 是 Github 账户的邮箱。 1ssh-keygen -t rsa -C github-email 生成完成后，在 C:/Users/your-username/.ssh 目录下找到 id_rsa.pub 文件（即公钥），将其中的内容复制后在 Github 中的 SSH and GPG keys 一栏中选择 New SSH key 创建新的密钥即可。 Hexo 相关内容 初始化 在博客文件夹使用如下命令即可。 1hexo init Volantis 主题配置 下载并安装主题 我选择直接从 Github 下载主题源码，这种方式需要将源码文件夹放到 themes 下，随后需要： 复制主题中 _config.yml ，并将其更名为 _config.volantis.yml ，然后拷贝到博客根目录； 将主题源码的文件夹名改为 volantis ，并将根目录中 _config.yml 中 theme 更改为 volantis ，注意 yml 的书写规范。 1theme: volantis #冒号后一个空格 字体更改 我使用的配置如下所示。 12345678910111213141516171819#file: _contig.volantis.yml #for valantis, 2023/1/14 fontfamily: codefont: fontfamily: &#x27;Fira&#x27; # registered font name should be consistent with &#x27;name&#x27; url: /static/ttf/FiraCode-Regular.ttf # watch out for this term and notice the pattern of valid paths name: &#x27;Fira&#x27; logofont: fontfamily: &#x27;&quot;Times New Roman&quot;, SimSun&#x27; # name: &#x27;Varela Round&#x27; # url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;Times New Roman&quot;, SimSun&#x27; # name: &#x27;UbuntuMono&#x27; # url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal 数学公式渲染 我最终采用的渲染器为 hexo-renderer-marked ，即 Hexo 自带的渲染器。在使用 Volantis-5.7.6 更换渲染器后，报出了如下的错误，一直没有找到解决的办法，这是我直接使用旧版本的其中一个原因，然而最后还是通过重装解决了未知的问题。 123456789101112131415161718ERRORSyntaxError: Unexpected identifier in &quot;D:\\\\code\\\\blog\\\\themes\\\\volantis\\\\layout\\\\layout.ejs&quot; at new Function (&lt;anonymous&gt;) at exports.compile (D:\\code\\blog\\node_modules\\hexo-renderer-mathjax\\node_modules\\ejs\\lib\\ejs.js:242:14) at Object.exports.render (D:\\code\\blog\\node_modules\\hexo-renderer-mathjax\\node_modules\\ejs\\lib\\ejs.js:284:66) at Hexo.&lt;anonymous&gt; (D:\\code\\blog\\node_modules\\hexo-renderer-mathjax\\index.js:14:24) at Hexo.tryCatcher (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Hexo.ret (eval at makeNodePromisifiedEval (C:\\Users\\17258\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\node_modules\\bluebird\\js\\release\\promisify.js:184:12), &lt;anonymous&gt;:13:39) at D:\\code\\blog\\node_modules\\hexo\\lib\\hexo\\render.js:81:22 at tryCatcher (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\promise.js:547:31) at Promise._settlePromise (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\promise.js:604:18) at Promise._settlePromiseCtx (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\promise.js:641:10) at _drainQueueStep (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:97:12) at _drainQueue (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:86:9) at Async._drainQueues (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:102:5) at Immediate.Async.drainQueues [as _onImmediate] (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:15:14) at processImmediate (node:internal/timers:464:21) BTW，在尝试对多行公式渲染时果然出现了问题，解决方法详见使用 pandoc 正确渲染多行 MathJax 公式。 代码高亮 在使用 Volantis-5.7.6 实在是没有找到代码高亮的配置方法，还是用回了 4.3.1 版本，现在还需设置复制代码的按钮。经过多次尝试后发现是包安装的问题，最终通过重装解决了相关问题。 评论区 最终采用 giscuss 作为评论区，具体原理详见参考资料。 主题配置文件 多读官方文档以及配置文件中的注释，这是入门最快的一个方式。 参考资料 volantis (hexo博客主题) 【2021最新版】保姆级Hexo+github搭建个人博客 如何使用 GitHub 讨论作为您博客的聊天系统","categories":[{"name":"网站相关","slug":"网站相关","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"反馈点集问题","slug":"反馈点集问题","date":"2022-09-28T08:51:58.000Z","updated":"2023-01-04T13:32:30.041Z","comments":true,"path":"2022-09-28-反馈点集问题/","link":"","permalink":"http://example.com/2022-09-28-%E5%8F%8D%E9%A6%88%E7%82%B9%E9%9B%86%E9%97%AE%E9%A2%98/","excerpt":"算是在 HUST-Smart 实验室的一次小实习。","text":"算是在 HUST-Smart 实验室的一次小实习。 背景介绍 有向反馈点集问题主要研究如何消除有向拓扑图中的环路问题。 题目描述 给定一个有向图，请删除最少数量的顶点使得图无环，请注意顶点的输入输出都从\\(0\\)开始编号。 输入包括\\(n+1\\)行，第\\(1\\)行为顶点数\\(n\\)以及边数\\(m\\)，接下来\\(n\\)行分别代表顶点\\(0 \\sim n-1\\)的邻接表。 输出包括若干行，每一行为要删除的一个顶点的编号。 理论原理 在有向图中，反馈集由图中在圈上的点（包括圈和圈的交点）组成。反馈点集问题的内容是：如何消除尽可能少的点，使得一个有向图无环，换言之就是如何找到有向图的最小反馈点集。 In a directed graph, a feedback set is a set of vertices that intersects any cycle of the graph. 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cmath&gt;#include &lt;random&gt;#include &lt;fstream&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;chrono&gt;#include &lt;unordered_map&gt;#pragma warning(disable: 4996)//#define OFFLINE#define __TIMER__using namespace std;using namespace chrono;struct Node &#123; int nodeId; vector&lt;int&gt; pred; // 前驱节点 vector&lt;int&gt; succ; // 后继节点 Node(int id = -1) :nodeId(id), pred(vector&lt;int&gt;()), succ(vector&lt;int&gt;()) &#123;&#125;&#125;;void init() &#123;&#125;double rand_p() &#123; return rand() / double(RAND_MAX);&#125;vector&lt;int&gt; get_conflict_points(unordered_map&lt;int, int&gt;&amp; S, pair&lt;int, int&gt; move, vector&lt;Node&gt;&amp; graph) &#123; if (move.first == -1) return &#123;&#125;; vector&lt;int&gt; conflictPoints; for (auto su : graph[move.first].succ) &#123; if ((move.first == su) || (S.count(su) &amp;&amp; move.second &gt;= S[su])) &#123; conflictPoints.emplace_back(su); &#125; &#125; return conflictPoints;&#125;//first为结点ID，second为插入位置pair&lt;int, int&gt; rand_choice(unordered_map&lt;int, int&gt;&amp; S, vector&lt;Node&gt;&amp; graph) &#123; int nodeID = -1, insertPos = 0; while (S.size() &lt; graph.size() &amp;&amp; -1 == nodeID) &#123; int r = rand() % graph.size(); if (S.find(r) == S.end()) nodeID = r; &#125; if (nodeID != -1) &#123; for (auto pr : graph[nodeID].pred) &#123; if (S.count(pr)) &#123; insertPos = max(insertPos, S[pr] + 1); &#125; &#125; &#125; return &#123; nodeID, insertPos &#125;;&#125;void add_sol(unordered_map&lt;int, int&gt;&amp; S, vector&lt;Node&gt;&amp; graph, pair&lt;int, int&gt; move, vector&lt;int&gt;&amp; conflictPoints) &#123; if (move.first == -1) return; S.insert(move); //去除冲突点 for (auto cp : conflictPoints) &#123; S.erase(cp); &#125; for (auto&amp; it : S) &#123; if (it.first != move.first &amp;&amp; it.second &gt;= move.second) &#123; it.second++; &#125; &#125;&#125;unordered_map&lt;int, int&gt; SA_FVSP(vector&lt;Node&gt;&amp; graph, long long secTimeOut) &#123; //初始化解 unordered_map&lt;int, int&gt; S, S_star; //初始化模拟退火所需的参数 double T = 0.6, alpha = 0.98; //int maxFail = 50, maxMvt = 5 * graph.size(), nbFail = 0; //可以适当修改参数，前40个算例没必要那么多轮迭代 int maxFail = 25, maxMvt = 5 * graph.size(), nbFail = 0; //模拟退火算法主函数#ifdef __TIMER__ time_t start_t, end_t; auto start = system_clock::now();//运用c++ 11 auto auto end = system_clock::now(); start_t = system_clock::to_time_t(start);//to_time_t函数：time_point转换成time_t秒(即ctime标准类型) long long duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();#endif do &#123; int nbMvt = 0; bool failure = true; do &#123; auto move = rand_choice(S, graph); auto conflictPoints = get_conflict_points(S, move, graph); int delta = conflictPoints.size() - 1; if (delta &lt;= 0 || exp(-delta / T) &gt; rand_p()) &#123; add_sol(S, graph, move, conflictPoints); nbMvt++; if (S.size() &gt; S_star.size()) &#123; S_star = S; failure = false; &#125; &#125;#ifdef __TIMER__ end = system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count(); if (duration == secTimeOut) &#123; cerr &lt;&lt; &quot;Time limit exceeded!&quot; &lt;&lt; endl; exit(-1); &#125;#endif &#125; while (nbMvt != maxMvt); nbFail = (failure ? nbFail + 1 : 0); T *= alpha; &#125; while (nbFail != maxFail); //返回最优解 return S_star;&#125;long long to_ll(const char* src) &#123; int len = strlen(src); long long ans = 0; for (int i = 0; i &lt; len; i++) &#123; ans = ans * 10 + (src[i] - &#x27;0&#x27;); &#125; return ans;&#125;int main(int argc, char* argv[]) &#123; //快速I/O#ifdef OFFLINE auto start = clock();#endif cin.tie(0); cout.tie(0); cout.sync_with_stdio(false); //处理命令行参数 long long secTimeout = 0; if (argc == 3) &#123; secTimeout = atoll(argv[1]); srand(atoi(argv[2])); &#125; else return 0; //读入数据 int n, m;#ifdef OFFLINE //const string targetFilePath(&quot;C:\\\\Users\\\\17258\\\\Desktop\\\\npbenchmark.data\\\\DFVSP\\\\Instance\\\\pardalos.n1000e30000.txt&quot;); const string targetFilePath(&quot;testData.txt&quot;); ifstream in(targetFilePath); in &gt;&gt; n &gt;&gt; m; in.get();#else cin &gt;&gt; n &gt;&gt; m; cin.get();#endif //读入有向图 vector&lt;Node&gt; graph(n); for (int s = 0; s &lt; n; s++) &#123; graph[s].nodeId = s; string line;#ifdef OFFLINE getline(in, line);#else getline(cin, line);#endif stringstream ss(line); vector&lt;int&gt; cur; int e; while (ss &gt;&gt; e) &#123; graph[e].pred.emplace_back(s); graph[s].succ.emplace_back(e); &#125; &#125; //求解 auto sol = SA_FVSP(graph, secTimeout); //打印结果 for (int i = 0; i &lt; n; i++) &#123; //打印删除的点 if (0 == sol.count(i)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; &#125;#ifdef OFFLINE auto end = clock(); cout &lt;&lt; double(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;","categories":[{"name":"NP问题","slug":"NP问题","permalink":"http://example.com/categories/NP%E9%97%AE%E9%A2%98/"}],"tags":[]},{"title":"Hello, Java!","slug":"Hello-Java","date":"2022-09-20T10:41:55.000Z","updated":"2023-01-14T12:03:59.965Z","comments":true,"path":"2022-09-20-Hello-Java/","link":"","permalink":"http://example.com/2022-09-20-Hello-Java/","excerpt":"初学Java时所做的一些笔记，内容主要以题目形式呈现。","text":"初学Java时所做的一些笔记，内容主要以题目形式呈现。 AcWing 656 这是原题链接，主要考察计算精度处理。 123456789101112131415161718import java.util.Scanner;public class Main &#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); double N = sc.nextDouble(); //精度问题，既然都是小数点后两位那直接将输入*100再用整数计算即可 int n = (int)(N * 100); int[] arr = new int[] &#123;10000, 5000, 2000, 1000, 500, 200, 100, 50, 25, 10, 5, 1&#125;; for(int i = 0; i &lt; arr.length; i++) &#123; if(i == 0) System.out.println(&quot;NOTAS:&quot;); if(i == 6) System.out.println(&quot;MOEDAS:&quot;); if(i &lt; 6) System.out.printf(&quot;%d nota(s) de R$ %d.00\\n&quot;, n / arr[i], arr[i] / 100); else System.out.printf(&quot;%d moeda(s) de R$ %.2f\\n&quot;, n / arr[i], arr[i]/ 100.0); n -= n / arr[i] * arr[i]; &#125; &#125;&#125; AcWing 727 经典输出菱形的题目，这是原题链接，受到\\(|x| + |y| = 1\\)代表边长为\\(\\sqrt{2}\\)、中心在原点且各个顶点都在坐标轴上的正方形可以得到较为优雅的代码。 1234567891011121314151617import java.util.Scanner;public class Main &#123; static boolean star(int i, int j, int n) &#123; return Math.abs(i - n / 2) + Math.abs(j - n / 2) &lt;= n / 2; &#125; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; System.out.printf(&quot;%c&quot;, star(i, j, n)? &#x27;*&#x27;: &#x27; &#x27;); &#125; System.out.println(); &#125; &#125;&#125; AcWing 719 这是原题链接，注意 C/C++ 和 Java 中，取整操作都是向下取整，对于负数取整结果可能小于零。 12345678910111213141516171819import java.util.Scanner;public class Main &#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for(int i = 0; i &lt; n; i++) &#123; int a = sc.nextInt(), b = sc.nextInt(), ans = 0; if(a &gt; b) &#123; int t = a; a = b; b = t; &#125; //attention for(int j = a + 1; j &lt; b; j++) if(j % 2 == 1 || j % 2 == -1) ans += j; System.out.println(ans); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"初探NLP","slug":"初探NLP","date":"2022-09-15T06:35:24.000Z","updated":"2022-09-15T07:28:20.555Z","comments":true,"path":"2022-09-15-初探NLP/","link":"","permalink":"http://example.com/2022-09-15-%E5%88%9D%E6%8E%A2NLP/","excerpt":"阅读《基于深度学习的自然语言处理》时所记的一些笔记。","text":"阅读《基于深度学习的自然语言处理》时所记的一些笔记。 第一章 自然语言处理 相关概念 自然语言处理的功能有以下三个。 语音识别 自然语言理解 自然语言生成 文本数据被称为语料库(corpora)或语料(corpus)。 自然语言处理可以被应用于包括以下在内的很多领域。 自动文摘 翻译 情感分析 信息提取 关系提取 聊天机器人 个人语音助理 语法检查 文本预处理技术 在这部分中，我们将使用 NLTK(Python) 库，它是自然语言处理最简单也是最受欢迎的库之一。 大小写转换 这是人们经常忘记使用的最简单有效的预处理技术之一。 123words = [&quot;India&quot;, &quot;inDia&quot;, &quot;indIA&quot;, &quot;IndIa&quot;]words = [word.lower() for word in words]print(words) 去噪 去噪的对象包括单词、符号、标点符号、HTML标记、数字、空白、停止此、特定术语、特定正则表达式、非ASCII字符以及解析词。 1234567891011121314151617import redef clean_words(text: str) -&gt; str: # remove html markup text = re.sub(&quot;(&lt;.*?&gt;)&quot;, &quot;&quot;, text) # remove non-ascii and digits text = re.sub(&quot;(\\W|d+)&quot;, &quot; &quot;, text) # remove whitespace text = text.strip() return textraw = [&quot;..sleepy&quot;, &quot;sleepy!!&quot;, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;sleepy&lt;&lt;&lt;&lt;&quot;, &quot;&lt;a&gt;sleepy&lt;/a&gt;&quot;]raw = [clean_words(word) for word in raw]print(raw) 文本规范化 例如 color 和 colour 是同一个词的不同书写形式，在自然语言处理的过程中，需要将原始语料库转换为规范和标准的形式。 词干提取 词干提取即提取单词的词根。 123456789101112import nltkimport pandas as pdfrom nltk.stem import PorterStemmer as psstemmer = ps()words = [&#x27;annoy&#x27;, &#x27;annoying&#x27;, &#x27;annoyed&#x27;, &#x27;annoys&#x27;]stems = [stemmer.stem(word = word) for word in words]print(stems)# 使用DataFrame打印结果sdf = pd.DataFrame(&#123;&#x27;raw word&#x27;: words, &#x27;stem&#x27;: stems&#125;)print(sdf) 词形还原 这一步需要下载 WordNet 。 1234# python run on cmdimport nltknltk.download(&#x27;wordnet&#x27;)nltk.download(&#x27;omw-1.4&#x27;) 完成下载后使用以下代码进行测试。 1234567891011from nltk.stem import WordNetLemmatizer as wnlimport pandas as pdlemmatizer = wnl()words = [&#x27;troubling&#x27;, &#x27;troubled&#x27;, &#x27;troubles&#x27;, &#x27;trouble&#x27;]# v&#x27;是还原的词性，&#x27;v&#x27;即verblemmatized = [lemmatizer.lemmatize(word = word, pos = &#x27;v&#x27;) for word in words]ldf = pd.DataFrame(&#123;&#x27;raw word&#x27;: words, &#x27;lemmatized&#x27;: lemmatized&#125;)ldf = ldf[[&#x27;raw word&#x27;, &#x27;lemmatized&#x27;]]print(ldf) 标记化单词 首先需要下载 punkt 数据包。 123# python run on cmdimport nltknltk.download(&#x27;punkt&#x27;) 运行如下代码尝试标记化单词。 12345from nltk import word_tokenizes = &quot;Hi! My name is Sam.&quot;tokens = word_tokenize(s)print(tokens) 标记化句子 运行如下代码尝试标记化句子，运行结果应该是两个句子被分为两个独立的标记。 12345from nltk import sent_tokenizes = &quot;Hi! My name is Sam.&quot;tokens = sent_tokenize(s)print(tokens) 删除停止词 首先需要下载 stopwords 。 123# python run on cmdimport nltknltk.download(&#x27;stopwords&#x27;) 随后可以进行如下测试。 12345678from nltk.corpus import stopwordsstop_words = set(stopwords.words(&#x27;english&#x27;))s = &#x27;the weather is really hot and i want to go for a swim&#x27;tokens = word_tokenize(s)tokens = [word for word in tokens if not word in stop_words]print(tokens) 词嵌入 自然语言处理为机器学习模型和深度学习模型准备了文本数据，而这些模型以数值数据作为输入时执行效率最高。因此为字眼语言处理的关键作用是将预处理的文本数据转换为数值数据，数值数据是文本数据的数字表示。 这就是词嵌入的含义：它们是文本实值向量形式的数值表示，具有相同含义的词映射到相似的向量，因此具有相似的表示，这有助于机器学习不同单词的含义和背景。 图1-1 词嵌入图示 常用的词嵌入技术有 Word2Vec 和 GloVe 。 Word2Vec Word2Vec 是一个只有两层的浅层神经网络， GloVe","categories":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"},{"name":"读书笔记","slug":"NLP/读书笔记","permalink":"http://example.com/categories/NLP/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"一些杂七杂八的数学题目","slug":"一些杂七杂八的数学题目","date":"2022-09-14T12:18:39.000Z","updated":"2022-10-16T08:18:43.475Z","comments":true,"path":"2022-09-14-一些杂七杂八的数学题目/","link":"","permalink":"http://example.com/2022-09-14-%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98%E7%9B%AE/","excerpt":"这篇博客用于记录一些杂七杂八的数学题目以及相关的知识。","text":"这篇博客用于记录一些杂七杂八的数学题目以及相关的知识。 设\\(a_n = \\displaystyle (1+\\frac{1}{n})^n\\)，求证：\\(\\forall n \\in \\text{N}^+, a_{n+1}&gt;a_n\\) 解法一 \\(a_n=\\displaystyle \\prod_{i=1}^{n} (1 +\\frac{1}{n})=\\prod_{i=1}^{n} (1 +\\frac{1}{n})\\cdot 1 \\leq [\\frac{\\displaystyle \\sum_{i=1}^{n}(1+\\frac{1}{n})+1}{n+1}]^{n+1}=(1+\\frac{1}{n+1})^{n+1}=a_{n+1}\\) 上式中的取等条件为\\(\\displaystyle \\frac{1}{n}+1=1\\)，这显然是不可能成立的，故\\(a_{n+1} &gt; a_{n}\\)。 这个解法使用了均值不等式，即\\(\\forall a_1, a_2,\\dots,a_n \\in \\text{R}\\)，\\(H_n \\leq G_n \\leq A_n\\leq Q_n\\)，其中四个均值分别为调和平均数、几何平均数、算数平均数和平方平均数，不等式取等条件都是\\(\\forall i,j\\in\\{1,2,\\dots,n\\},a_i=a_j\\)。上面的证明使用到了\\(G_n\\leq A_n\\)的变形，即\\(\\displaystyle \\prod_{i=1}^{n}a_i \\leq (\\frac{\\displaystyle \\sum_{i=1}^{n}a_i}{n})^n\\)。 解法二 \\(\\displaystyle \\frac{a_{n+1}}{a_n} = [1-\\frac{1}{(n+1)^2}]^n \\cdot \\frac{n+2}{n+1} \\geq [1-\\frac{n}{(n+1)^2}] \\cdot \\frac{n+2}{n+1} &gt; (1-\\frac{1}{n+2}) \\cdot \\frac{n+2}{n+1}=1\\) 以上证明使用了伯努利不等式，即\\(\\forall x &gt; -1\\)： \\(n\\geq1 \\Rightarrow (1+x)^n\\geq1+nx\\)； \\(n\\in[0,1] \\Rightarrow(1+x)^n\\leq1+nx\\)。 此外，\\(\\displaystyle \\frac{n}{(n+1)^2}=\\frac{1}{n+\\displaystyle\\frac{1}{n}+2}&lt;\\frac{1}{n+2}\\)。 解法三 设\\(y=e^{\\displaystyle x\\ln(1+\\frac{1}{x})}, x\\in \\text{R}^+\\)，则\\(f&#39;(x)=[\\displaystyle\\ln(1+\\frac{1}{x})-\\frac{1}{x+1}]f(x)\\)。 设\\(g(x)=\\ln(1+x)-\\displaystyle\\frac{x}{1+x}\\)，则\\(g&#39;(x)=\\displaystyle\\frac{x}{1+x} &gt; 0\\)，那么\\(f&#39;(x)&gt;0\\)，那么\\(f(x)\\)在\\(\\text{R}^+\\)上单调递增，原命题显然。 删数问题 题目描述 已知有一数组，其元素为\\(1,2,3,\\dots,100\\)共\\(100\\)个数，现随机删除\\(2\\)个数，并将其余\\(98\\)个数乱序存于另一数组，试问如何求出这\\(2\\)个数？ 求解思路 对于删除\\(1\\)个数的情况，可以利用\\(100\\)个数的总和为\\(5050\\)的条件，遍历剩余的\\(99\\)个数并得到总和\\(B_1\\)，则被删去的数就是\\((5050 -B_1)\\)。 事实上，不难发现原来\\(100\\)个数的乘积也是常数\\(100!\\)，那么可以得到剩下\\(98\\)个数的和、乘积，即可得到被删除的\\(2\\)个数的和、乘积，逆用韦达定理即可构造关于这\\(2\\)个数的一元二次方程，求解这个方程，得到的两根一定是被删去的数。 推广 那么，以上求解方程的思想是否可以推广到删除超过\\(2\\)个数的情况呢？我经过思考后认为可以。 设被删除的数为\\(\\{b_1,b_2,\\dots,b_t\\}\\)共\\(t\\)个，可以通过构造一元\\(t\\)次方程求解被删除的数，其中\\(1\\leq t \\leq99\\)。 首先可以通过剩余\\((100-t)\\)个数得到\\(\\displaystyle \\sum_{i=1}^tb_i\\)和\\(\\displaystyle \\prod_{i=1}^tb_i\\)，不妨分别记之为\\(B_1\\)和\\(B_t\\)。 考虑\\(\\displaystyle (\\sum_{i=1}^{100}i)^2 = 5050^2\\)，那么： \\[\\begin{aligned} 5050^2 &amp; =\\displaystyle (\\sum_{i=1}^{100}i)^2 \\\\ &amp;= ((\\sum_{i=1}^tb_i)+(5050-\\sum_{i=1}^tb_i))^2\\\\ &amp; = \\displaystyle (\\sum_{i=1}^tb_i)^2 + (5050-\\sum_{i=1}^tb_i)^2+2(\\sum_{i=1}^tb_i)(5050-\\sum_{i=1}^tb_i) \\\\ &amp; = B_1^2+(5050-B_1)^2+10100B_1+2\\displaystyle (\\sum_{i=1}^tb_i)(\\sum_{i=1}^tb_i) \\\\ &amp;= B_1^2+(5050-B_1)^2+10100B_1+2\\displaystyle (\\sum_{i=1}^tb_i^2 + \\sum_{1\\leq i &lt; j \\leq t} b_i b_j)\\end{aligned}\\] 不妨记\\(\\displaystyle \\sum_{1\\leq i &lt; j \\leq t} b_i b_j = B_2\\)。由于\\(100\\)个数的平方和是一定的，那么可以得到\\(\\displaystyle \\sum_{i=1}^tb_i^2\\)也是常数。恒等式左侧中仅有\\(B_2\\)是未知数，而右侧为常数，那么可以求解得到\\(B_2\\)。 现在不妨观察已经得到的\\(3\\)个常系数，这\\(3\\)个系数与\\(\\{b_1,b_2,\\dots,b_t\\}\\)之间的关系为： \\[\\begin{cases} \\displaystyle \\sum_{i=1}^{t}b_i=B_1\\\\ \\displaystyle \\sum_{1\\leq i &lt; j \\leq t} b_i b_j = B_2\\\\b_1b_2\\cdots b_t = B_t\\\\ \\end{cases}\\] 不难发现以上等式左侧都是关于\\(b1,b_2,\\dots,b_t\\)的轮换对称式，那么可以类比求解\\(B_2\\)的方法，利用\\(\\displaystyle (\\sum_{i=1}^{100}i)^3 = 5050^3\\)，得到\\(\\displaystyle \\sum_{1\\leq i &lt; j &lt;k \\leq t} b_i b_j b_k = B_3\\)，最终可以得到\\(B_1,B_2,\\dots,B_t\\)共\\(t\\)个常数。上述推理的简单证明如下： 归纳奠基：显然通过\\(\\displaystyle(\\sum_{i=1}^{100}i)^1=5050\\)已经求得\\(B_1\\)； 归纳推理：设\\(k\\geq2\\)，已知\\(\\displaystyle (\\sum_{i=1}^ti)^k=5050^k\\)以及\\(B_1,B_2,\\dots,B_{k-1}\\)，而\\(\\displaystyle ((\\sum_{i=1}^tb_i)+(5050-\\sum_{i=1}^tb_i))^k\\)的的展开式可由二项式定理求得为\\(\\displaystyle \\sum_{j=0}^k C_k^j(\\sum_{i=1}^tb_i)^{j}(5050-\\sum_{i=1}^tb_i)^{k-j}\\)，进一步展开后\\((k+1)\\)项中除了\\(B_k\\)未知之外，其余各项均已求得，因此可以求得\\(B_k\\)。 利用构造出的\\(t\\)个关于\\(b_1,b_2,\\dots,b_t\\)即可根据系数构造一元\\(t\\)次方程： \\[\\displaystyle \\prod_{i=1}^t(x-b_i)=x^t-B_1x^{t-1}+\\cdots+(-1)^tB_t=0\\] 求解这个方程就可以得到被删除的\\(t\\)个数。 卡特兰数 卡特兰数的其中一个应用为：数\\(1 \\sim n\\)按序入栈，求课内的出栈序列的个数。 卡特兰数的通项公式为\\(C_n = \\frac{C_{2n}^n}{n+1},n\\in \\text{N}^+\\)。 求\\(I=\\lim\\limits_{x \\to 1^-} (1-x)^3 \\displaystyle \\sum_{n=1}^{\\infty} n^2x^n\\) 首先需要知道以下公式。 \\[\\displaystyle\\sum_{n=0}^{\\infty}x^n = \\frac{1}{1-x}, x\\in(-1,1)\\] 对上式两端求导得到如下公式。 \\[\\displaystyle\\sum_{n=0}^{\\infty}(n+1)x^{n} = \\frac{1}{(1-x)^2}, x\\in(-1,1)\\] \\[\\displaystyle\\sum_{n=0}^{\\infty}(n+1)(n+2)x^{n} = \\frac{2}{(1-x)^3}, x\\in(-1,1)\\] 由\\(n^2=(n+1)(n+2)-3(n+1)+1\\)可以得到如下的结果。 \\[\\displaystyle \\sum_{n=1}^{\\infty} n^2x^n = \\frac{2}{(1-x)^3} - \\frac{3}{(1-x)^2} + \\frac{1}{1-x} , x \\in(-1,1)\\] 最终可以得到\\(I=2\\)。 无穷级数中的下标变化问题 在前面求解过程中涉及到了两次求导，事实上隐含了两次下标变换，具体如下所示。 \\[(\\frac{1}{1-x})&#39; = \\displaystyle\\sum_{n=1}^{\\infty}nx^{n-1} = \\displaystyle\\sum_{n-1=0}^{\\infty}[(n-1)+1]x^{n-1} = \\displaystyle\\sum_{n=0}^{\\infty}(n+1)x^{n}, x\\in(-1,1)\\] \\[[\\frac{1}{(1-x)^2}]&#39;= \\sum_{n=1}^{\\infty}n(n+1)x^{n-1}= \\sum_{n-1=0}^{\\infty}[(n-1)+1][(n-1)+2]x^{n-1} = \\displaystyle\\sum_{n=0}^{\\infty}(n+1)(n+2)x^{n}, x\\in(-1,1)\\] 实际上，无穷级数的第一项需要分类讨论，因为对于\\(f(x)=Cx^0\\)，\\(f&#39;(x) \\neq Cx^{-1}\\)，而是\\(f&#39;(x)=0\\)，因此需要分类讨论。 无穷集合势相关的证明 证明：\\([0,1]\\sim (0,1)\\) 可以构造如下的\\([0,1] \\to (0,1)\\)的双射，证毕。 \\[f(x) = \\begin{cases} \\displaystyle \\frac{1}{2}, x = 1\\\\ \\displaystyle \\frac{1}{4}, x = 0\\\\ \\displaystyle \\frac{1}{4}x, x = \\frac{1}{2^n}, n \\in \\{1,2,3,\\dots\\}\\\\ \\displaystyle x, \\text{others}\\\\ \\end{cases}\\] 证明：\\(|\\text{N}^+| &lt; |(0,1)|\\) 参考康托对角线证明。 求 \\(I=\\displaystyle \\lim\\limits_{n \\to \\infty} \\sum_{i=1}^{n} \\frac{1}{n+i}\\) 解法一 可以使用定积分定义求解。 \\[ I = \\displaystyle \\frac{1}{n}\\sum_{i=1}^{n} \\frac{1}{1+ \\displaystyle\\frac{i}{n}} = \\int_{0}^{1}\\frac{1}{1+x}dx=\\ln 2\\] 解法二 由不等式\\(\\displaystyle \\frac{x}{1+x} &lt; \\ln(1+x) &lt; x\\)，可以使用夹逼定理求解。 \\[\\displaystyle \\frac{1}{n + 1} = \\frac{\\displaystyle \\frac{1}{n}}{1 + \\displaystyle \\frac{1}{n}} &lt; \\ln(1 + \\frac{1}{n}) =\\ln(n+1) - \\ln n &lt; \\frac{1}{n} \\] 类推可以得到下列不等式。 \\[\\begin{cases} \\displaystyle \\frac{1}{n + 1} &lt; \\ln(n+1) - \\ln n &lt; \\frac{1}{n}\\\\ \\displaystyle \\frac{1}{n + 2} &lt; \\ln(n+2) - \\ln (n+1) &lt; \\frac{1}{n + 1}\\\\ \\cdots\\\\ \\displaystyle \\frac{1}{2n} &lt; \\ln(2n) - \\ln (2n-1) &lt; \\frac{1}{2n-1} \\end{cases}\\] 将以上\\(n\\)个不等式求和可得到如下不等式。 \\[\\displaystyle \\sum_{i=1}^{n} \\frac{1}{n+i} &lt; \\ln2 &lt; \\sum_{i=1}^{n} \\frac{1}{n+i} + \\frac{1}{n} - \\frac{1}{2n} = \\sum_{i=1}^{n} \\frac{1}{n+i} + \\frac{1}{2n}\\] 进一步可知\\(\\displaystyle \\ln2 - \\frac{1}{2n} &lt; \\sum_{i=1}^{n} \\frac{1}{n+i} &lt; \\ln2\\)，故\\(I=\\ln2\\)。 已知\\(S=\\{1,2,\\dots,2000\\}\\)，求满足条件\\(S_i \\subseteq S\\)且\\(\\displaystyle\\sum_{e \\in S_i}e \\equiv 0 \\pmod{5}\\)的集合\\(S_i\\)的个数 题目来源于3Blue1Brown。 不妨首先考虑\\(S&#39;= \\{1,2,3,4,5\\}\\)以及生成函数\\(g(x) = (1+x)(1+x^2)(1+x^3)(1+x^4)(1+x^5)\\)，考虑\\(g(x)\\)展开式中\\(x\\)各个幂次前对应的系数：注意展开等号右侧的过程，\\(x\\)的幂次实际上说明了在展开过程中在\\(5\\)个括号中选择的\\(x\\)的幂次之和，这就表明\\(x^i\\)的系数\\(c_i\\)可以代表\\(S&#39;\\)和为\\(i\\)的集合的个数，其中\\(i \\in \\{0,1,\\dots,15\\}\\)；同理，可以考虑生成函数 \\(f(x) = \\displaystyle \\prod_{i=1}^{2000}(1+x^i) = \\sum_{i=0}^{2000}c_ix^i\\)。 基于上述分析，原问题可转化为求解和式\\(\\displaystyle \\sum_{i \\equiv 0 \\pmod{5}}c_i\\)的值。记\\(T_j = \\displaystyle \\sum_{i \\equiv j \\pmod{5}}c_i, j \\in \\{ 0,1,2,3,4\\}\\)，那么下面需要求解\\(T_0\\)。 注意到\\(f(1)=2^{2000}\\)，\\(f(-1)=0\\)，根据这两个式子可以得到\\(f(x)\\)展开式中\\(x\\)的奇数次项和偶数次项前的系数和都是\\(2^{1999}\\)。受此启发，引入\\(\\zeta = e^{\\displaystyle\\frac{2\\pi}{5}i}\\)，计算\\(f(\\zeta^0)\\)，\\(f(\\zeta^1)\\)，\\(f(\\zeta^2)\\)，\\(f(\\zeta^3)\\)和\\(f(\\zeta^4)\\)，由复数性质可得如下结果。 \\[\\begin{cases} f(\\zeta^0)=T_0+T_1+T_2+T_3+T_4=2^{2000}\\\\ f(\\zeta^1)=T_0+\\zeta^1 T_1+\\zeta^2T_2+\\zeta^3T_3+\\zeta^4T_4=2^{400}\\\\ f(\\zeta^2)=T_0+\\zeta^2 T_1+\\zeta^4T_2+\\zeta^1T_3+\\zeta^3T_4=2^{400}\\\\ f(\\zeta^3)=T_0+\\zeta^3 T_1+\\zeta^1T_2+\\zeta^4T_3+\\zeta^2T_4=2^{400}\\\\ f(\\zeta^4)=T_0+\\zeta^4 T_1+\\zeta^3T_2+\\zeta^2T_3+\\zeta^1T_4=2^{400} \\end{cases}\\] \\(f(1)\\)显然可得。下面将主要求解\\(f(\\zeta)\\)，其余\\(3\\)个函数值同理可得，注意到\\(\\zeta\\)是\\(z^5-1=0\\)的根，因此有\\(z^5-1=\\displaystyle\\prod_{i=0}^{4}(z-\\zeta^i)\\)，令\\(z=-1\\)，则\\(\\displaystyle\\prod_{i=0}^{4}(1+\\zeta^i)=2\\)，那么可以求解\\(f(\\zeta)\\)如下所示。 \\[f(\\zeta)=[(1+\\zeta^0)(1+\\zeta^1)(1+\\zeta^2)(1+\\zeta^3)(1+\\zeta^4)]^{400}=2^{400}\\] 由\\(\\displaystyle\\sum_{i=0}^4\\zeta^i=0\\)，对以上五个式子求和最终可得\\(T_0=\\displaystyle \\frac{1}{5}(2^{2000} + 2^{400})\\)。 已知方阵\\(A\\)和\\(B\\)满足关系\\(AB=A+B\\)，求证：\\(AB=BA\\) \\[AB=A+B \\Rightarrow (A-E)(B-E)=E \\Rightarrow (A-E)^{-1} = (B-E) \\Rightarrow (A-E)(B-E) = (B-E)(A-E) \\Rightarrow AB = BA\\] 群论相关的一些证明 我比较喜欢这个课程。 已知\\(&lt;V,\\cdot&gt;\\)为半群，且\\(\\forall a,b \\in V, a \\neq b \\Rightarrow ab \\neq ba\\)，求证以下命题 （1）\\(V\\)中幂等律成立 （2）\\(\\forall a,b \\in V, aba = a\\) （3）\\(\\forall a,b,c \\in V, abc = ac\\) （1）\\(\\forall a \\in V\\)，假定\\(a \\cdot a \\neq a\\)，那么\\(a \\cdot (a \\cdot a) \\neq (a \\cdot a) \\cdot a\\)，对于满足结合律的半群而言产生矛盾，因此\\(V\\)中幂等律成立。 （2）\\(\\forall a,b \\in V\\)，假定\\(aba \\neq a\\)，那么\\(aba \\cdot a \\neq a \\cdot aba\\)，根据结合律和幂等律可知\\(aba \\neq aba\\)，产生矛盾，因此命题成立。 （3）\\(\\forall a,b,c \\in V\\)，假定\\(abc \\neq ac\\)，那么\\(abc \\cdot ac \\neq ac \\cdot abc\\)，由结合律和（2）可知\\(abc \\neq abc\\)，产生矛盾，因此命题成立。 抽象函数相关的题目 已知函数\\(f(x)\\)在\\(\\text{R}\\)可导，且\\(f(x+y)=e^yf(x)+e^xf(y)\\)以及\\(f&#39;(0)=2\\)，求\\(f(x)\\)的表达式 首先令\\(x=y=0\\)，得到\\(f(0)=0\\)。 再令\\(y=\\Delta x\\)，那么\\(f(x+\\Delta x) - f(x) = (e^{\\Delta x} - 1)f(x)+e^xf(\\Delta x)\\)。 由题目的\\(f(x)\\)处处可导及导数定义有： \\[f&#39;(x)=\\lim_\\limits{\\Delta \\to 0} \\displaystyle \\frac{f(x + \\Delta x) - f(x)}{\\Delta x}=f(x)\\lim_\\limits{\\Delta \\to 0}\\frac { e^{\\Delta x} - 1}{\\Delta x} + e^x \\lim_\\limits{\\Delta x \\to 0} \\frac{f(\\Delta x) - f(0)}{\\Delta x - 0}=f(x)+2e^x\\] 求解微分方程得到\\(f(x)=e^x(C+2x),C\\in \\text{R}\\)。 对于微分方程\\(\\displaystyle \\frac{dy}{dx} + P(x)y=Q(x)\\)，其通解为\\(y=e^{-\\displaystyle \\int P(x) dx}(C + \\displaystyle \\int e^{P(x)}Q(x)dx)\\)。 设\\(X_1,X_2,\\dots,X_n(n \\geq 2)\\)为来自总体\\(N(\\mu, \\sigma^2)\\)的简单随机样本，求证：\\(\\bar{X}\\)和\\(S^2\\)独立 待补充 已知\\(A\\)是实反对称矩阵，求证：\\(B=(E-A)(E+A)^{-1}\\)为正交矩阵 \\[B^TB=[(E-A)(E+A)^{-1}]^T(E-A)(E+A)^{-1} = (E-A)^{-1}(E+A)(E-A)(E+A)^{-1}\\] 注意到\\((E-A)(E+A)=E-A^2=(E+A)(E-A)\\)，因此\\(B^TB=E\\)，证毕。 事实上，只要\\(B=\\displaystyle\\prod_{i} f_i(A)\\)，其中\\(A\\)为方阵，那么\\(f_{i_1}(A)\\)与\\(f_{i_2}(A)\\)就可以交换乘积顺序。 求曲线\\(x+y+e^y=0\\)的渐近线 显然曲线\\(x=-(e^y+y)\\)只有斜渐近线，设之方程为\\(x = ay+b\\)。 \\[a = \\lim_\\limits{y \\to \\infty} \\displaystyle \\frac{x}{y} = -1 - \\lim_\\limits{y \\to \\infty}\\frac{e^y}{y}\\] 以上极限仅在\\(y\\to -\\infty\\)时存在，并且\\(a = -1\\)。 \\[b = \\lim_\\limits{y \\to -\\infty} \\frac{x - ay}{y} = 0\\] 因此所求渐近线方程为\\(x+y=0\\)。通过本题可知，不要局限地将任何惯用的因（自）变量符号默认当作因（自）变量。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"随笔栏的实现过程","slug":"随笔栏的实现过程","date":"2022-09-14T09:29:41.000Z","updated":"2023-01-14T12:00:57.605Z","comments":true,"path":"2022-09-14-随笔栏的实现过程/","link":"","permalink":"http://example.com/2022-09-14-%E9%9A%8F%E7%AC%94%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/","excerpt":"这篇博客用于记录配置自定义分页的过程。","text":"这篇博客用于记录配置自定义分页的过程。 安装 hexo-generator-index2 按照作者的教程进行安装即可。 使用如下命令卸载博客自带的分页生成器并安装 hexo-generator-index2 。 12npm install hexo-generator-index2 --savenpm uninstall hexo-generator-index --save 根配置文件 阅读说明后，我进行了如下配置，注意最好将原来的生成器相关配置注释掉。 首先是路径配置。 123# Directory# other paths as defaultessay_dir: essays 然后是生成器相关的配置。 1234567891011121314151617181920# index2 generator related configurationindex2_include_index: false # suggested false# the custom index2 generator, can be array or objectindex2_generator: - layout: &#x27;index&#x27; # use existing index layout path: &#x27;&#x27; # default path per_page: 10 order_by: -date index: true # home page layout or not exclude: - category essays - layout: &#x27;index&#x27; # use existing index layout path: &#x27;essays&#x27; # your-website/essays index: false per_page: 10 order_by: -date include: - category essays 修改 generator2.js 阅读代码后我发现该生成器生成的网站标题名默认为路径，这有些不太美观，因此我做了如下细节的修改。 12345678// file: blog-root-path/node_modules/hexo-generator-index2/lib/generator2.js // ... opts.title = generator.path; // line: 92 /* for essays */ if(generator.path == &#x27;essays&#x27;) &#123; opts.title = &#x27;随笔&#x27;; // my code &#125; //../ 细节上的完善 我主要修改了一部分 ejs 文件使得细节方面更加美观。 首先是主题文件夹中布局目录下 _widget 中的 category.ejs。 123456789&lt;!-- 主页侧边栏不显示essays分类 --&gt;&lt;!-- file: blog-root-path/themes/volantis/layout/_widget/category.ejs --&gt; &lt;!-- ... --&gt; &lt;% site.categories.sort(&#x27;path&#x27;).each(function(category)&#123; %&gt; &lt;!-- line: 7, not modified --&gt; &lt;% if(category.name != &#x27;essays&#x27;) &#123; %&gt; &lt;!-- ... --&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;!-- ... --&gt; 其次是 post.ejs。 1234567891011121314151617&lt;!-- 分页界面文章标签左下角不显示分类 --&gt;&lt;!-- file: blog-root-path/themes/volantis/layout/_partial/post.ejs --&gt; &lt;!-- ... --&gt; &lt;% if (post.categories &amp;&amp; post.categories.length &gt; 0) &#123; %&gt; &lt;!-- line: 108, not modified --&gt; &lt;% let contains_essays = false; for(cat of post.categories.toArray()) &#123; if(cat.name == &#x27;essays&#x27;) &#123; contains_essays = true; break; &#125; &#125; if(!contains_essays) &#123; %&gt; &lt;!-- ... --&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;!-- ... --&gt; 类似地，还可以修改以下两个 categories.ejs。 123456789&lt;!-- 所有分类界面不显示essays分类 --&gt;&lt;!-- file: blog-root-path/themes/volantis/layout/category.ejs --&gt; &lt;!-- ... --&gt; &lt;% site.categories.sort(&#x27;path&#x27;).each(function(category)&#123; %&gt; &lt;!-- line: 16, not modified --&gt; &lt;% if(category.name != &#x27;essays&#x27;) &#123; %&gt; &lt;!-- ... --&gt; &lt;% &#125; %&gt; &lt;% &#125;) %&gt; &lt;!-- ... --&gt; 123456789101112131415&lt;!-- 所有随笔文章头部不显示essays分类 --&gt;&lt;!-- file: blog-root-path/themes/volantis/layout/_meta/category.ejs --&gt;&lt;% if (post.categories &amp;&amp; post.categories.length)&#123; %&gt; &lt;!-- line: 1, not modified --&gt; &lt;% let contains_essays = false; for(cat of post.categories.toArray()) &#123; if(cat.name == &#x27;essays&#x27;) &#123; contains_essays = true; break; &#125; &#125; if(!contains_essays) &#123; %&gt; &lt;!-- ... --&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 随笔博客的翻页范围应该与一般博客区分开了，将 article.ejs 进行修改是一种办法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 除去随笔页面中的翻页功能 --&gt;&lt;!-- file: blog-root-path/themes/volantis/layout/_partial/article.ejs --&gt;&lt;% &lt;!-- line: about 150, not modified --&gt; &lt;!-- ... --&gt; &lt;!-- for essays begin --&gt; let contains_essays = false; if (post.categories &amp;&amp; post.categories.length)&#123; for(cat of post.categories.toArray()) &#123; if(cat.name == &#x27;essays&#x27;) &#123; contains_essays = true; break; &#125; &#125; &#125; &lt;!-- for essays end --&gt; if ([&#x27;docs&#x27;].includes(post.layout) &amp;&amp; (prev || next) &amp;&amp; (!contains_essays)) &#123; %&gt; &lt;div class=&quot;prev-next&quot;&gt; &lt;% if (prev.path) &#123; %&gt; &lt;a class=&#x27;prev&#x27; href=&#x27;&lt;%- url_for(prev.path) %&gt;&#x27;&gt; &lt;p class=&#x27;title&#x27;&gt;&lt;i class=&quot;fa-solid fa-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;%- prev.title || &#x27;&#x27; %&gt;&lt;/p&gt; &lt;!--&lt;p class=&#x27;content&#x27;&gt;&lt;%- prev.exp %&gt;&lt;/p&gt;--&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;% if (next.path) &#123; %&gt; &lt;a class=&#x27;next&#x27; href=&#x27;&lt;%- url_for(next.path) %&gt;&#x27;&gt; &lt;p class=&#x27;title&#x27;&gt;&lt;%- next.title || &#x27;&#x27; %&gt;&lt;i class=&quot;fa-solid fa-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/p&gt; &lt;!--&lt;p class=&#x27;content&#x27;&gt;&lt;%- next.exp %&gt;&lt;/p&gt;--&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;% &lt;!-- for essays begin --&gt; let contains_essays = false; if (post.categories &amp;&amp; post.categories.length)&#123; for(cat of post.categories.toArray()) &#123; if(cat.name == &#x27;essays&#x27;) &#123; contains_essays = true; break; &#125; &#125; &#125; &lt;!-- for essays end --&gt; if ((post.prev || post.next) &amp;&amp; (!contains_essays)) &#123; %&gt; &lt;!-- not modified line --&gt; &lt;!-- ... --&gt; 然而，上述方法并没有改变每篇博客逻辑上的前后页，而只是不显示翻页功能而已，这将导致一般博客在有随笔博客作为前页或后页时出现问题，因此合理的方式应该是修改 post.js，即从逻辑上修改这一般博客与随笔博客的前后页设置。修改完成后，可以将 article.ejs 中关于删除分页功能的逻辑删除即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//file: file: blog-root-path/node_modules/hexo/lib/plugins/generator/post.js&#x27;use strict&#x27;;function postGenerator(locals) &#123; const posts = locals.posts.sort(&#x27;-date&#x27;).toArray(); const &#123; length &#125; = posts; return posts.map((post, i) =&gt; &#123; const &#123; path, layout &#125; = post; if (!layout || layout === &#x27;false&#x27;) &#123; return &#123; path, data: post.content &#125;; &#125; /* if (i) post.prev = posts[i - 1]; if (i &lt; length - 1) post.next = posts[i + 1]; */ // get prev &amp; next function catContainEssays(post) &#123; let result = false; if(post.categories &amp;&amp; post.categories.length &gt; 0) &#123; post[&#x27;categories&#x27;].toArray().forEach(cat =&gt; &#123; if(cat.name == &#x27;essays&#x27;) result = true; &#125;); &#125; return result; &#125; let curPostContainsEssays = catContainEssays(post); let j = i - 1; while(j &gt;= 0 &amp;&amp; curPostContainsEssays ^ catContainEssays(posts[j])) j--; if(j &gt;= 0) post.prev = posts[j]; j = i + 1; while(j &lt; length &amp;&amp; curPostContainsEssays ^ catContainEssays(posts[j])) j++; if (j &lt; length) post.next = posts[j]; const layouts = [&#x27;post&#x27;, &#x27;page&#x27;, &#x27;index&#x27;]; if (layout !== &#x27;post&#x27;) layouts.unshift(layout); post.__post = true; return &#123; path, layout: layouts, data: post &#125;; &#125;);&#125;module.exports = postGenerator; 如果不希望随笔出现在归档页面，可以进行如下修改。 1234567891011121314151617181920212223242526272829303132333435//file: file: blog-root-path/themes/volantis/layout/archive.ejs // ... // about line 15, keyword: &lt;div&gt; label with class &#x27;timenode&#x27; &lt;% if (post.categories &amp;&amp; post.categories.length &gt; 0) &#123; let contains_essays = false; for(cat of post.categories.toArray()) &#123; if(cat.name == &#x27;essays&#x27;) &#123; contains_essays = true; break; &#125; &#125; if(!contains_essays) &#123; %&gt; &lt;div class=&#x27;timenode&#x27;&gt; &lt;a class=&quot;meta&quot; href=&quot;&lt;%= url_for(post.link || post.path) %&gt;&quot;&gt; &lt;time&gt;&lt;%= date(post.date, &#x27;MM-DD&#x27;) %&gt;&lt;/time&gt; &lt;% if(post.title || post.seo_title)&#123; %&gt; &lt;%- post.title || post.seo_title %&gt; &lt;% &#125; else if (post.date) &#123; %&gt; &lt;%= date(post.date, config.date_format) %&gt; &lt;% &#125; %&gt; &lt;% if(theme.plugins.aplayer &amp;&amp; theme.plugins.aplayer.enable &amp;&amp; post.music &amp;&amp; post.music.enable != false)&#123; %&gt; &amp;nbsp;&lt;i class=&quot;fa-solid fa-headphones-alt music&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;% &#125; %&gt; &lt;% if (post.icon) &#123; %&gt; &amp;nbsp;&lt;i class=&quot;&lt;%- post.icon %&gt;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;% &#125; %&gt; &lt;% (post.icons &amp;&amp; post.icons||[]).forEach(function(icon)&#123; %&gt; &amp;nbsp;&lt;i class=&quot;&lt;%- icon %&gt;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;% &#125;) %&gt; &lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; // ... 总结 目标至此完成实现。 笔者在此前几乎没有接触过 js 的相关项目，对于 Hexo 的细节了解也不够充分，但是最终仍然算是自行解决了问题，我认为得益于如下工具或因素： VS Code 的在文件中搜索文本功能； 耐心阅读官方文档； 仔细思考后再行动，这一点也是片上系统综合实践课程老师所提醒我的，千次盲目的尝试比不过静心思考后的一次实践； 此外，根据已有的基础知识部分阅读并修改大型项目的一部分代码也是计算机人应有的能力，同时也需要具有对专业名词的敏感性。 这次自定义博客不仅达到了预期目标，还锻炼了我的学习方法和思考问题的方式，我收获颇丰。 终于可以写随笔了！","categories":[{"name":"网站相关","slug":"网站相关","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"C++的大整数类","slug":"C++的大整数类","date":"2021-11-13T04:55:35.000Z","updated":"2022-09-15T03:09:35.270Z","comments":true,"path":"2021-11-13-C++的大整数类/","link":"","permalink":"http://example.com/2021-11-13-C++%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E7%B1%BB/","excerpt":"这两天写高精度计算，发现C++缺少一个方便使用的大整数类，于是自己写了一个，主要的原理是运算符重载。","text":"这两天写高精度计算，发现C++缺少一个方便使用的大整数类，于是自己写了一个，主要的原理是运算符重载。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//file: big_int.h#ifndef _BIG_INT_H#define _BIG_INT_H#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define __POSITIVE__ false#define __NEGATIVE__ trueclass big_int &#123;public: //构造函数 big_int() :sign(__POSITIVE__), nums(1, 0) &#123;&#125; big_int(int n); big_int(const std::string&amp; n); big_int(const big_int&amp; _ano); //求幂，原理为快速幂 big_int pow(const big_int&amp; _ano) const; //运算符重载 big_int operator+(const big_int&amp; _ano) const; big_int operator-(const big_int&amp; _ano) const; big_int operator*(const big_int&amp; _ano) const; big_int operator/(const big_int&amp; _ano) const; big_int operator%(const big_int&amp; _ano) const; big_int&amp; operator=(const big_int&amp; _ano); big_int&amp; operator+=(const big_int&amp; _ano); big_int&amp; operator-=(const big_int&amp; _ano); big_int&amp; operator*=(const big_int&amp; _ano); big_int&amp; operator/=(const big_int&amp; _ano); big_int operator%=(const big_int&amp; _ano); big_int operator++(int); big_int&amp; operator++(); bool operator&lt;(const big_int&amp; _ano) const; bool operator==(const big_int&amp; _ano) const; bool operator&gt;(const big_int&amp; _ano) const; bool operator&gt;=(const big_int&amp; _ano) const; bool operator&lt;=(const big_int&amp; _ano) const; std::string to_string(); friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const big_int&amp; _output);private: bool sign; std::vector&lt;int&gt; nums; big_int(bool sign, const std::vector&lt;int&gt;&amp; nums); bool absolute_value_A_less_than_B(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const; std::vector&lt;int&gt; absolute_value_subtract(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const; std::vector&lt;int&gt; absolute_value_mutiply(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const;&#125;;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205//file: big_int.cpp#include &quot;big_int.h&quot;big_int::big_int(bool sign, const std::vector&lt;int&gt;&amp; nums) :sign(sign), nums(nums) &#123;&#125;big_int::big_int(int n) :sign(n &lt; 0) &#123; if (n == 0) nums.resize(1, 0); else &#123; if (n &lt; 0) n = -n; while (n) &#123; nums.emplace_back(n % 10); n /= 10; &#125; &#125;&#125;big_int::big_int(const std::string&amp; n) :sign(n[0] == &#x27;-&#x27;) &#123; if (n == &quot;0&quot;) nums.resize(1, 0); else &#123; int highest = sign; for (int i = n.size() - 1; i &gt;= highest; i--) &#123; nums.emplace_back(n[i] - &#x27;0&#x27;); &#125; &#125;&#125;big_int::big_int(const big_int&amp; _ano) :sign(_ano.sign), nums(_ano.nums) &#123;&#125;big_int big_int::pow(const big_int&amp; _ano) const &#123; big_int ans = 1, _y = _ano, _x = *this; while (_y &gt; 0) &#123; if (_y % 2 == 1) ans *= _x; _x *= _x; _y /= 2; &#125; return ans;&#125;big_int big_int::operator+(const big_int&amp; _ano) const &#123; if (sign != _ano.sign) return *this - big_int(!_ano.sign, _ano.nums); std::vector&lt;int&gt; ans(std::max(_ano.nums.size(), nums.size()) + 1, 0); int i = 0, j = 0, k = 0; while (i &lt; nums.size() &amp;&amp; j &lt; _ano.nums.size()) ans[k++] = nums[i++] + _ano.nums[j++]; while (i &lt; nums.size()) ans[k++] = nums[i++]; while (j &lt; _ano.nums.size()) ans[k++] = _ano.nums[j++]; for (int i = 0, c = 0; i &lt; ans.size(); i++) &#123; ans[i] += c; c = ans[i] / 10; ans[i] %= 10; &#125; while (ans.size() &gt; 1 &amp;&amp; ans.back() == 0) ans.pop_back(); return big_int(sign, ans);&#125;big_int big_int::operator-(const big_int&amp; _ano) const &#123; if (sign != _ano.sign) return *this + big_int(!_ano.sign, _ano.nums); if (absolute_value_A_less_than_B(nums, _ano.nums)) return big_int(!sign, absolute_value_subtract(_ano.nums, nums)); else return big_int(sign, absolute_value_subtract(nums, _ano.nums));&#125;big_int big_int::operator*(const big_int&amp; _ano) const &#123; return big_int(sign ^ _ano.sign, absolute_value_mutiply(_ano.nums, nums));&#125;big_int big_int::operator/(const big_int&amp; _ano) const &#123; if (absolute_value_A_less_than_B(nums, _ano.nums)) return big_int(0); std::vector&lt;int&gt; res, temp, tempMul; for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; temp.push_back(nums[i]); std::reverse(temp.begin(), temp.end()); while (temp.size() &gt; 1 &amp;&amp; temp.back() == 0) temp.pop_back(); int j = 1; for (; j &lt;= 9; j++) &#123; std::vector&lt;int&gt; factor(1, j); tempMul = absolute_value_mutiply(factor, _ano.nums); if (absolute_value_A_less_than_B(temp, tempMul)) &#123; break; &#125; &#125; res.emplace_back(--j); tempMul = absolute_value_mutiply(std::vector&lt;int&gt;(1, j), _ano.nums); temp = absolute_value_subtract(temp, tempMul); std::reverse(temp.begin(), temp.end()); &#125; int i = 0; while (i &lt; res.size() - 1 &amp;&amp; res[i] == 0) i++; std::vector&lt;int&gt; ans(std::vector&lt;int&gt;(res.begin() + i, res.end())); std::reverse(ans.begin(), ans.end()); return big_int(sign ^ _ano.sign, ans);&#125;big_int big_int::operator%(const big_int&amp; _ano) const &#123; return *this - *this / _ano * _ano; &#125;big_int&amp; big_int::operator=(const big_int&amp; _ano) &#123; sign = _ano.sign; nums = _ano.nums; return *this;&#125;big_int&amp; big_int::operator+=(const big_int&amp; _ano) &#123; *this = *this + _ano; return *this;&#125;big_int&amp; big_int::operator-=(const big_int&amp; _ano) &#123; *this = *this - _ano; return *this;&#125;big_int&amp; big_int::operator*=(const big_int&amp; _ano) &#123; *this = *this * _ano; return *this;&#125;big_int&amp; big_int::operator/=(const big_int&amp; _ano) &#123; *this = *this / _ano; return *this;&#125;big_int big_int::operator%=(const big_int&amp; _ano) &#123; *this = *this - *this / _ano * _ano; return *this;&#125;big_int big_int::operator++(int) &#123; big_int temp = *this; *this += 1; return temp;&#125;big_int&amp; big_int::operator++() &#123; *this += 1; return *this;&#125;bool big_int::operator&lt;(const big_int&amp; _ano) const &#123; if (sign == _ano.sign) return absolute_value_A_less_than_B(nums, _ano.nums); else return sign == __NEGATIVE__;&#125;bool big_int::operator==(const big_int&amp; _ano) const &#123; return sign == _ano.sign &amp;&amp; nums == _ano.nums; &#125;bool big_int::operator&gt;(const big_int&amp; _ano) const &#123; return !(*this == _ano || *this &lt; _ano);&#125;bool big_int::operator&gt;=(const big_int&amp; _ano) const &#123; return *this &gt; _ano || *this == _ano;&#125;bool big_int::operator&lt;=(const big_int&amp; _ano) const &#123; return *this &lt; _ano || *this == _ano;&#125;std::string big_int::to_string() &#123; std::string ans; if (sign == __NEGATIVE__) ans.push_back(&#x27;-&#x27;); for (int i = nums.size() - 1; i &gt;= 0; i--) ans.push_back(nums[i] + &#x27;0&#x27;); return ans;&#125;std::vector&lt;int&gt; big_int::absolute_value_subtract(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const &#123; std::vector&lt;int&gt; ans(A); for (int i = 0, c = 0; i &lt; A.size(); i++) &#123; ans[i] -= c + (i &lt; B.size() ? B[i] : 0); c = ans[i] &lt; 0; ans[i] += (ans[i] &lt; 0 ? 10 : 0); &#125; while (ans.back() == 0 &amp;&amp; ans.size() &gt; 1) ans.pop_back(); return ans;&#125;bool big_int::absolute_value_A_less_than_B(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const &#123; if (A.size() != B.size()) return A.size() &lt; B.size(); else &#123; for (int i = A.size() - 1; i &gt;= 0; i--) &#123; if (A[i] != B[i]) return A[i] &lt; B[i]; &#125; &#125; return false;&#125;std::vector&lt;int&gt; big_int::absolute_value_mutiply(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const &#123; std::vector&lt;int&gt; ans(A.size() + B.size(), 0); for (int i = 0; i &lt; A.size(); i++) &#123; for (int j = 0; j &lt; B.size(); j++) &#123; ans[i + j] += A[i] * B[j]; &#125; &#125; for (int i = 0, c = 0; i &lt; ans.size(); i++) &#123; ans[i] += c; c = ans[i] / 10; ans[i] %= 10; &#125; while (ans.size() &gt; 1 &amp;&amp; ans.back() == 0) ans.pop_back(); return ans;&#125;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const big_int&amp; _output) &#123; if (_output.sign == __NEGATIVE__) o &lt;&lt; &#x27;-&#x27;; for (int i = _output.nums.size() - 1; i &gt;= 0; i--) o &lt;&lt; _output.nums[i]; return o;&#125; 测试代码如下所示。 123456789101112131415//file: test.cpp#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;big_int.h&quot;using namespace std;const int N = 100;big_int fact[N + 1];int main() &#123; fact[0] = 1; for (int i = 1; i &lt;= N; i++) &#123; fact[i] = fact[i - 1] * i; &#125; cout &lt;&lt; fact[10] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法日常练习7","slug":"算法日常练习7","date":"2021-11-12T11:38:30.000Z","updated":"2022-10-17T02:51:16.066Z","comments":true,"path":"2021-11-12-算法日常练习7/","link":"","permalink":"http://example.com/2021-11-12-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A07/","excerpt":"2021年11月12日练习。","text":"2021年11月12日练习。 BJTU-ALGO 2015 做题做的人有点麻，来道签到题。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; nums(n,vector&lt;int&gt;(m)); for (auto&amp; i : nums) &#123; for (auto&amp; j : i) &#123; cin &gt;&gt; j; &#125; &#125; for (int j = 0; j &lt; m; j++) &#123; for (int i = n - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; nums[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; BJTU-ALGO 1007 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;#define square(x) ((x)*(x))using namespace std;int main() &#123; int N; double R, C = 0.0; cin &gt;&gt; N &gt;&gt; R; vector&lt;pair&lt;double, double&gt;&gt; points(N, pair&lt;double, double&gt;()); for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; points[i].first &gt;&gt; points[i].second; &#125; for (int i = 1; i &lt; N; i++) &#123; C += sqrt(square(points[i].first - points[i - 1].first) + square(points[i].second - points[i - 1].second)); &#125; C += sqrt(square(points[0].first - points[N - 1].first) + square(points[0].second - points[N - 1].second)); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2); cout &lt;&lt; C + acos(-1) * 2.0 * R &lt;&lt; endl; return 0;&#125; BJTU-ALGO 1054 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;bool&gt;&gt; land(n, vector&lt;bool&gt;(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int temp; cin &gt;&gt; temp; land[i][j] = temp; &#125; &#125; vector&lt;vector&lt;int&gt;&gt;dp(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (land[i][j]) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; &#125; &#125; &#125; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans = max(ans, dp[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; BJTU-ALGO 2039 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int product_counts(int i) &#123; int ans = 0; for (int j = 1; j &lt;= i; j++) &#123; if (i % j == 0) &#123; ans++; &#125; &#125; return ans;&#125;int main() &#123; int K; bool s = false; cin &gt;&gt; K; for (int i = 1; i &lt;= 2000; i++) &#123; if (product_counts(i) == K) &#123; cout &lt;&lt; i &lt;&lt; endl; s = true; &#125; &#125; cout &lt;&lt; (s ? &quot;&quot; : &quot;NO SOLUTION\\n&quot;); return 0;&#125; BJTU-ALGO 1083 12345678910111213141516import java.math.*;import java.util.*;public class Main &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); String s = input.nextLine(); BigInteger n = new BigInteger(s);//当2^(i) &lt;= n &lt; 2^(i+1)时，输出1+2*(n-2^i) BigInteger pow = new BigInteger(&quot;1&quot;); while(pow.compareTo(n) &lt;= 0)&#123; pow = pow.multiply(new BigInteger(&quot;2&quot;)); &#125; input.close(); System.out.print(n.multiply(new BigInteger(&quot;2&quot;)).subtract(pow).add(new BigInteger(&quot;1&quot;))); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;using namespace std;struct big_int &#123;//只在正数范围内进行求解 vector&lt;int&gt; nums;//实际数字的低位存在数组的低位较为容易计算 big_int():nums(vector&lt;int&gt;())&#123;&#125; big_int(int _init) :nums(vector&lt;int&gt;()) &#123; while (1) &#123; nums.emplace_back(_init % 10); _init /= 10; if (_init == 0) &#123; break; &#125; &#125; &#125; big_int(const string&amp; _init):nums(vector&lt;int&gt;()) &#123; for (int i = _init.size() - 1; i &gt;= 0; i--) &#123; nums.emplace_back(_init[i] - &#x27;0&#x27;); &#125; &#125; big_int operator*(const big_int&amp; ano)&#123; big_int ans(0); int n = nums.size(), m = ano.nums.size(); ans.nums.resize(m + n, 0); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans.nums[i + j] += nums[i] * ano.nums[j]; &#125; &#125; int c = 0; for (int i = 0; i &lt; m + n; i++) &#123; ans.nums[i] += c; c = ans.nums[i] / 10; ans.nums[i] %= 10; &#125; for (int i = m + n - 1; i &gt;= 0; i--) &#123; if (ans.nums[i] == 0) &#123; ans.nums.pop_back(); &#125; else &#123; break; &#125; &#125; if (c != 0) &#123; ans.nums.emplace_back(c); &#125; return ans; &#125; big_int pow(int n) &#123; big_int ans(1); for (int i = 1; i &lt;= n; i++) &#123; ans = ans * (* this); &#125; return ans; &#125; bool operator&lt;(const big_int&amp; _ano) const&#123; if (nums.size() != _ano.nums.size()) &#123; return nums.size() &lt; _ano.nums.size(); &#125; else &#123; int n = nums.size(); for (int i = n - 1; i &gt;= 0; i--) &#123; if (nums[i] &lt; _ano.nums[i]) &#123; return true; &#125; else if (nums[i] == _ano.nums[i]) &#123; continue; &#125; else &#123; return false; &#125; &#125; return false; &#125; &#125; bool operator==(const big_int&amp; _ano) const&#123; return _ano.nums == nums; &#125; bool operator&lt;=(const big_int&amp; _ano) const&#123; return *this &lt; _ano || *this == _ano; &#125; big_int operator+(const big_int&amp; _ano) const&#123; big_int ans; int n = nums.size(), m = _ano.nums.size(); int i = 0, j = 0, c = 0, k = 0; ans.nums.resize(max(m, n), 0); while (i &lt; n &amp;&amp; j &lt; m) &#123; ans.nums[k] += (c + nums[i] + _ano.nums[j]); c = ans.nums[k] / 10; ans.nums[k] %= 10; i++; j++; k++; &#125; while (i &lt; n) &#123; ans.nums[k] += (c + nums[i]); c = ans.nums[k] / 10; ans.nums[k] %= 10; i++; k++; &#125; while (j &lt; m) &#123; ans.nums[k] += (c + _ano.nums[j]); c = ans.nums[k] / 10; ans.nums[k] %= 10; j++; k++; &#125; if (c != 0) &#123; ans.nums.emplace_back(c); &#125; return ans; &#125; big_int operator-(const big_int&amp; _ano) const&#123;//*this &gt; _ano big_int ans; int n = nums.size(), m = _ano.nums.size(); int c = 0; ans.nums.resize(n, 0); for (int i = 0; i &lt; n; i++) &#123; int temp = (i &lt; m ? nums[i] - _ano.nums[i] + c : nums[i] + c); ans.nums[i] = (temp &gt;= 0 ? temp : temp + 10); c = (temp &gt;= 0 ? 0 : -1); &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; if (ans.nums[i] == 0) &#123; ans.nums.pop_back(); &#125; else &#123; break; &#125; &#125; return ans; &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, const big_int&amp; _output) &#123; for (int i = _output.nums.size() - 1; i &gt;= 0; i--) &#123; os &lt;&lt; _output.nums[i]; &#125; return os;&#125;int main() &#123; string n; cin &gt;&gt; n;//当2^(i) &lt;= n &lt; 2^(i+1)时，输出2n+1-2^(i+1) int i = 0; while (1) &#123; if (!(big_int(2).pow(i) &lt;= big_int(n) &amp;&amp; big_int(n) &lt; big_int(2).pow(i + 1))) &#123; i++; &#125; else &#123; break; &#125; &#125; cout &lt;&lt; big_int(2) * big_int(n) + big_int(1) - big_int(2).pow(i + 1) &lt;&lt; endl; return 0;&#125; BTW，好久不用 list ，顺便复习一下。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;//约瑟夫环121报数版本using namespace std;int main() &#123; for (int n = 1; n &lt;= 1000; n++) &#123; list&lt;int&gt; l; for (int i = 1; i &lt;= n; i++) &#123; l.emplace_back(i); &#125; auto iter = l.begin(); iter++; while (l.size() &gt; 1) &#123; auto cur_out = iter; for (int i = 1; i &lt;= 2; i++) &#123;//学习list的使用 iter++; if (iter == l.end()) &#123; iter = l.begin(); &#125; &#125; l.erase(cur_out); &#125; cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &#x27;:&#x27; &lt;&lt; l.front() &lt;&lt; endl; &#125; return 0;&#125; BJTU-ALGO 1101 123456789101112131415161718192021222324252627//AC代码#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll ans = 0;int n, k;void dfs(int last_sum, int last_num,int cur_depth) &#123; if (cur_depth == k - 1) &#123; if (n - last_sum &gt;= last_num) &#123;//减少一层深度就过了 ans++; &#125; return; &#125; for (int i = last_num; i &lt;= n - last_sum; i++) &#123; dfs(last_sum + i, i, cur_depth + 1); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n / k + 1; i++) &#123; dfs(i, i, 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 123456789101112131415161718192021222324252627//80分代码#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll ans = 0;int n, k;void dfs(int last_sum, int last_num, int cur_depth) &#123; if (cur_depth == k) &#123; if (last_sum == n) &#123; ans++; &#125; return; &#125; for (int i = last_num; i = n - last_sum; i++) &#123; dfs(last_sum + i, i, cur_depth + 1); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n / k + 1; i++) &#123; dfs(i, i, 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; BJTU-ALGO 1106 本题最佳解法是直接计算卡特兰数。 1234567891011121314151617//本题实际上是计算卡特兰数的裸题#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123; int n; cin &gt;&gt; n; ll ans = 1;//卡特兰数 for (int i = 2 * n; i &gt;= n + 2; i--) &#123; ans *= i; &#125; for (int i = n; i &gt;= 2; i--) &#123; ans /= i; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 暴力搜索代码如下。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll ans = 0;int n;void dfs(int stack_elements, int next_in) &#123; if (next_in &gt; n) &#123; ans++; return; &#125; else &#123; dfs(stack_elements + 1, next_in + 1);//进栈 if (stack_elements &gt; 0) &#123; dfs(stack_elements - 1, next_in);//出栈 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; dfs(0, 1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"概率论的一些知识点的总结","slug":"概率论的一些小技巧","date":"2021-11-11T11:13:52.000Z","updated":"2022-09-15T03:10:43.154Z","comments":true,"path":"2021-11-11-概率论的一些小技巧/","link":"","permalink":"http://example.com/2021-11-11-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"想起之前学概率论的时候整理了不少计算的小技巧，正好拿来练练写公式。","text":"想起之前学概率论的时候整理了不少计算的小技巧，正好拿来练练写公式。 常用的七个幂级数展开式 \\[\\displaystyle \\sin x = \\sum\\limits_{n=0}^\\infty \\frac{(-1)^n}{(2n+1)!}x^{2n+1}=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-...,x\\in(-\\infty,+\\infty)\\] \\[\\displaystyle \\cos x = \\sum\\limits_{n=0}^\\infty\\frac{(-1)^n}{(2n)!}x^{2n}=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-...,x\\in(-\\infty,+\\infty)\\] \\[\\displaystyle e^x=\\sum\\limits_{n=0}^\\infty\\frac{x^n}{n!}=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+...,x\\in(-\\infty,+\\infty)\\] 由以上三个公式可得欧拉公式：\\(\\displaystyle e^{ix}=i \\sin x+ \\cos x\\)。 \\[\\displaystyle \\ln(1+x)= \\sum \\limits_{n=1}^\\infty\\frac{(-1)^{n+1}}{n}x^n=x-\\frac{x^2}{2}+\\frac{x^3}{3}-...,x\\in(-1,1]\\] 由\\(\\ln(1+x)\\)的展开式可得\\(\\displaystyle \\ln2= \\sum \\limits_{n=1}^\\infty\\frac{(-1)^{n+1}}{n}\\)。 事实上，\\(\\ln(x+1)\\)的展开式可以由下式推出： \\[\\displaystyle\\frac{1}{1+x}= \\sum \\limits_{n=0}^\\infty (-x)^n=1-x+x^2-...,x\\in(-1,1)\\] 将上式中的 \\(x\\) 代换为\\((-x)\\)即可得到下式： \\[\\displaystyle\\frac{1}{1-x} =\\sum \\limits_{n=0}^\\infty x^n=1+x+x^2+...,x\\in(-1,1)\\] 事实上，\\(\\displaystyle\\frac{1}{1+x}\\)与\\(\\displaystyle\\frac{1}{1-x}\\)的泰勒展开式就是首项为\\(1\\)，公比为\\(\\mp x\\)的等比数列的前 \\(n\\) 项和 \\(S_n\\) 在\\(n\\to\\infty\\)的极限。关于等比级数还有一个常用的结论：当\\(|q|&lt;1\\) 时，级数\\(\\displaystyle \\sum \\limits_{n=1}^\\infty a_1q^{n-1}\\)收敛于\\(\\displaystyle \\frac{a_1}{1-q}\\)。 还有一个相对其他六个不太常用的一个公式： \\[\\displaystyle (1+x)^{\\alpha}=1+\\alpha x+\\frac{\\alpha(\\alpha-1)}{2!}x^2+...,x\\in(-1,1),a\\neq0\\] 由第七个公式可得一个常用的等价无穷小：\\((1+\\beta x)^{\\alpha}-1\\)~\\(\\alpha \\beta x,x\\to0\\)。 事实上，记住以上七个泰勒公式后，很多等价无穷小可以直接推出。 另外，同理第五个、第六个公式，有以下公式： \\[\\displaystyle\\frac{1}{1+x^2}= \\sum \\limits_{n=0}^\\infty(-1)^nx^{2n}=1-x^2+...,x\\in(-1,1)\\] 对上式积分有：\\(\\displaystyle\\int_0^x\\frac{1}{1+t^2}dt=\\int_0^x\\displaystyle \\sum \\limits_{n=0}^ \\infty(-1)^nt^{2n}dt\\)，等式左侧\\(=\\arctan x\\)，等式右侧\\(=\\displaystyle \\sum \\limits_{n=0}^ \\infty(-1)^{n}(\\frac{1}{2n+1}x^{2n+1})\\)，所以：\\[\\arctan x =\\displaystyle \\sum \\limits_{n=0}^ \\infty(-1)^{n}(\\frac{1}{2n+1}x^{2n+1})=x-\\frac{x^3}{3}+\\frac{x^5}{5}-...,x\\in(-1,1)\\] 与\\(e^{-x}\\)有关的反常积分 首先是最简单的一个积分：\\(\\displaystyle\\int_0^{+\\infty} e^{-x}dx=[-e^{-x}]_0^{+\\infty}=1\\)。 然后进行一些简单的推广：\\(\\displaystyle\\int_0^{+\\infty} x^n e^{-x}dx=n!,x\\in N\\)，当\\(n=0\\)时就是上面的积分，这个积分有很多种证明的方法，使用分部积分法加上第一数学归纳法或者待定系数法都可以证明，这里略去证明。当\\(n\\)换为另外一个实数时，以上积分的值需要进行推广，在实数域上就是伽马函数。值得注意的是\\(\\Gamma(x+1)=x\\Gamma(x)\\)，而\\((n+1)!=(n+1)n!\\)。 随后再进行一些变换：\\(\\displaystyle\\int_0^{+\\infty} x^n e^{-\\lambda x}dx=\\frac{n!}{\\lambda ^ {n+1}},n\\in N,\\lambda\\in R^+\\)。有了上面的积分的结果，只需要进行一步换元，令\\(\\lambda x = t\\)很容易计算出上面的结果。 与\\(e^{-x^2}\\)有关的反常积分 首先是最著名的高斯积分：\\(\\displaystyle \\int_{-\\infty}^{+\\infty}e^{-x^2}dx=\\sqrt{\\pi}\\)。求解这个积分最常见的方法是将其转换为二重积分。记\\(\\displaystyle I = \\int ^{+\\infty}_{-\\infty} e^{-x^2} dx\\)，则： \\[\\displaystyle I^2 = \\int ^{+\\infty} _{-\\infty} e^{-x^2} dx\\int ^{+\\infty} _{-\\infty} e^{-y^2} dy = \\int ^{+\\infty} _{-\\infty} \\int ^{+\\infty} _{-\\infty}e^{-(x^2+y^2)}dxdy \\] 随后进行极坐标换元有：\\(\\displaystyle I^2 = \\int_0^{2\\pi}d\\theta\\int ^{+\\infty} _0 \\rho e^{-\\rho^2}d\\rho=\\pi\\)，显然\\(I&gt;0\\)，因此\\(I=\\sqrt{\\pi}\\)。 此外，还有一个我很喜欢的广义积分：\\(\\displaystyle \\int_0^{+\\infty}\\frac{\\sin x}{x}dx=\\frac{\\pi}{2}\\)，这个积分被称为狄利克雷积分积分，使用拉普拉斯变换可以很容易求解这个积分。 正态分布是概率论中很重要的的一种分布，设\\(X\\)~\\(N(\\mu,\\sigma^2)\\)，则\\(X\\)的概率密度函数为\\(\\displaystyle f_X(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},x\\in(-\\infty,+\\infty),\\mu\\in R,\\sigma\\in R^+\\)，而由概率密度函数的意义有：\\(\\displaystyle \\int ^{+\\infty} _{-\\infty}f_X(x)dx=1\\)，因此有\\(\\displaystyle \\int ^{+\\infty} _{-\\infty}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx=1\\)。纯粹从求解题目的角度来讲，从概率密度函数定义的角度出发也是可以求解高斯积分的。令\\(\\mu=0,\\sigma=\\displaystyle\\frac{\\sqrt{2}}{2}\\)，代入上述概率密度函数的积分有：\\(\\displaystyle \\int ^{+\\infty} _{-\\infty}\\frac{1}{\\sqrt{\\pi}}e^{-x^2}dx=1\\)，结果很显然了。 设随机变量\\(X\\sim N(\\mu,\\sigma^2)\\)，则有： \\[\\displaystyle E(X)=\\int ^{+\\infty} _{-\\infty}xf_X(x)dx=\\int ^{+\\infty} _{-\\infty}\\frac{x}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx{\\xlongequal{t=\\frac{x-\\mu}{\\sigma}}}\\int ^{+\\infty} _{-\\infty}\\frac{\\sigma t + \\mu}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{t^2}{2}}d(\\sigma t+\\mu)=\\mu\\int ^{+\\infty} _{-\\infty}\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt=\\mu\\] 同理可求得\\(E(X^2)\\)： \\[\\displaystyle E(X^2)=\\int ^{+\\infty} _{-\\infty}x^2 f_X(x)dx=\\int ^{+\\infty} _{-\\infty}\\frac{x^2}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx{\\xlongequal{t=\\frac{x-\\mu}{\\sigma}}}\\int ^{+\\infty} _{-\\infty}\\frac{(\\sigma t + \\mu)^2}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{t^2}{2}}d(\\sigma t+\\mu)=\\mu^2+\\frac{\\sigma^2}{\\sqrt{2\\pi}}\\int ^{+\\infty} _{-\\infty}t^2e^{-\\frac{t^2}{2}}dt\\] 对于最后一部分的积分，有：\\(\\displaystyle \\int ^{+\\infty} _{-\\infty}t^2e^{-\\frac{t^2}{2}}dt=\\int^{+\\infty} _{-\\infty}e^{-\\frac{t^2}{2}}dt-[te^{-\\frac{t^2}{2}}]^{+\\infty} _{-\\infty}=\\sqrt{2\\pi}\\)，因此\\(E(X^2)=\\mu^2+\\sigma^2\\)。 又\\(D(X)=E(X^2)-[E(X)]^2\\)，故\\(D(X)=\\sigma^2\\)。 在求解正态分布的期望和方差时，我们又得到了一个非常有用的积分值\\(\\displaystyle \\int^{+\\infty} _{-\\infty}\\frac{x^2}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}dx=1\\)。事实上，可以求出标准正态分布的\\(n\\)阶原点矩。设\\(X\\sim N(0,1)\\)当\\(n\\)为偶数时，\\(E(X^n)=(n-1)!!\\)；当\\(n\\)为奇数时，\\(E(X^n)=0\\)。还有一个比较常用的值为\\(E(X^4)=3\\)。 大学物理中出现的一些积分 \\[\\displaystyle \\int_{-\\infty}^{+\\infty}x^{2n}e^{-bx^2}dx =2\\int^{+\\infty}_0(\\frac{t}{b})^ne^{-t}d(\\sqrt\\frac{t}{b})=\\frac{1}{(\\sqrt b)^{2n+1}}\\int_0^{+\\infty}t^{n-\\frac{1}{2}}e^{-t}dt=\\frac{1}{(\\sqrt b)^{2n+1}}\\Gamma(n+\\frac{1}{2})=\\displaystyle\\frac{(2n-1)!!}{2^{n+1}b^n}\\sqrt{\\frac{\\pi}{b}}\\] \\[\\displaystyle \\int_{0}^{+\\infty}\\frac{x^3}{e^x-1}dx=\\int_{0}^{+\\infty}x^3\\frac{e^{-x}}{1-e^{-x}}dx=\\displaystyle \\int_0^{+\\infty}x^3 \\sum_{n=1}^{\\infty} e^{-n} dx=\\displaystyle \\sum_{n=1}^{\\infty}\\int_{0}^{+\\infty} x^3e^{-n}dx=3! \\cdot \\displaystyle \\sum_{n=1}^{\\infty}\\frac{1}{n^4}=\\frac{\\pi^4}{15}\\]","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"计算技巧","slug":"计算技巧","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7/"}]},{"title":"算法日常练习6","slug":"算法日常练习6","date":"2021-11-11T00:52:28.000Z","updated":"2022-10-17T02:51:33.891Z","comments":true,"path":"2021-11-11-算法日常练习6/","link":"","permalink":"http://example.com/2021-11-11-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A06/","excerpt":"2021年11月11日练习。","text":"2021年11月11日练习。 平面上最近点对问题 给定平面上\\(n\\)个点及其横纵坐标（保证横纵坐标都是 long long 范围内的整数），求这\\(n\\)个点中距离最小的一对点，要求输出最小距离，保留三位小数。 最直接的想法当然是暴力枚举。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define square(x) ((x)*(x))using namespace std;using ll = long long;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;ll&gt;&gt; points(n, vector&lt;int&gt;(2)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; points[i][0] &gt;&gt; points[i][1]; &#125; double ans = 0.0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; ans = max(ans, sqrt(square(points[i][0] - points[j][0]) + square(points[i][1] - points[j][1]))); &#125; &#125; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 但是当点的数量太多的时候，暴力枚举会超时，所以需要进行求解的优化。 对于本题来讲可以采用分治的策略。那么什么是分治策略呢？ 事实上，二分查找就是分治策略的一种应用。要在排序好的数组中查找目标值，先取中间值，然后根据情况取左、右区间中的一个进行查找。当数组较大时，数组中的很大一部分空间并没有被遍历，因此二分查找确实是将时间复杂度降低了（由\\(O(n)\\)到\\(O(logn)\\)）。 但是分治策略对于有些问题是无效的，例如矩阵乘法问题，矩阵进行分块后再相乘并没有减少乘法的次数。使用分治策略求解平面上最近点对的问题可以降低时间复杂度吗？ 答案是可以。分治策略中很关键的一点是如何降低从小规模问题的解构成大规模问题的解的时间复杂度。对于矩阵乘法问题，不论如何划分，”合“的过程的复杂度是无法降低的。现证明分治策略对于求平面最近点对的距离问题有效，参考资料见文末。 图1 证明分治策略有效 如图1，设\\(\\delta_L\\)和\\(\\delta_R\\)分别是对平面的左右部分求出来的最小距离，取\\(\\delta = min(\\delta_L,\\delta_R)\\)。考虑划分位置\\(L\\)左右\\(\\delta\\)范围内的点，首先可以证明如果平面左右部分中各取一点，若所求得的距离\\(d \\leq \\delta\\)，那么这两点一定在虚线的区域，这是很显然的。然后证明，对于左侧任意一个点\\(P_1\\)，它若与右侧中的一点\\(P_2 \\in Right\\)满足\\(distance(P_1,P_2) \\leq \\delta\\)，那么\\(Right\\)中的点一定在\\(\\delta * 2\\delta\\)的一个矩形内，如图2所示，这个同样是显然的。 图2 核心部分证明 图2所示的矩形部分之多有6个点。即将这个举行划分为6个\\(\\frac {2\\delta}{3} * \\frac {\\delta}{2}\\)的矩形，由鸽巢原理，若点的个数大于6，则这6个矩形中至少有一个中有超过2个点，而每个矩形中2个点最远的距离是\\(\\sqrt{\\left(\\frac{2\\delta}{3}\\right)^2 + \\left(\\frac{\\delta}{2}\\right)^2}=\\frac{5\\delta}{6}&lt;\\delta\\)，而这是刚刚求解过的右半部分，显然这是不成立的，因此原假设不真。这也就证明了在进行局部解到整体解的合并的过程中需要枚举的点大大减少，时间复杂度确实降低了。 由这样的思路最终得出如下的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define square(x) ((x)*(x))#define MAX_SIZE 200050using db = double;using ll = long long;using namespace std;int n;struct point &#123; ll x, y; &#125;;vector&lt;point&gt;input;bool cmp1(point u, point v) &#123; return u.x == v.x ? u.y &lt; v.y : u.x &lt; v.x; &#125;bool cmp2(point u, point v) &#123; return u.y &lt; v.y; &#125;db distance(point u, point v) &#123; return square(u.x - v.x) + square(u.y - v.y); &#125;db sol(int l, int r)&#123; if (l &gt;= r) &#123; return LLONG_MAX; &#125; else if (r == l + 1) &#123; return distance(input[l], input[r]); &#125; else &#123; int mid = (l + r) &gt;&gt; 1, midx = input[mid].x; db d = min(sol(l, mid), sol(mid + 1, r)); vector&lt;point&gt; left_right; for (int i = l; i &lt; r; i++) &#123; if (square(input[i].x - midx) &lt;= d) &#123; left_right.emplace_back(input[i]); &#125; &#125; int ct = left_right.size(); sort(left_right.begin(), left_right.end(), cmp2); for (int i = 0; i &lt; ct; i++) &#123; for(int j = i + 1; j &lt; ct; j++)&#123; if (square(left_right[i].y - left_right[j].y) &gt; d) &#123; break; &#125; d = min(d, distance(left_right[i],left_right[j])); &#125; &#125; return d; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; input.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; input[i].x &gt;&gt; input[i].y; &#125; sort(input.begin(), input.end(), cmp1); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3); cout &lt;&lt; sqrt(sol(0, n - 1)) &lt;&lt; endl; return 0;&#125; 生日纪念日 输入某个人的生日，他想知道自己的一万天纪念日是哪一天。输入为三个整数，分别为年、月、日并且保证日期绝对合法，输出格式为 年-月-日 。 最暴力的想法就是直接写一个日期的类，自加\\(10^4\\)次。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int days_in_months[13] = &#123; 0,31,28,31,30,31,30,31,31,30,31,30,31 &#125;;struct date &#123; int YY; int MM; int DD; void operator++(int)&#123; DD++; if (DD &gt; days_in_months[MM]) &#123; MM++; DD = 1; if (MM &gt; 12) &#123; YY++; MM = 1; &#125; &#125; &#125;&#125;;bool leap_year(int YY) &#123; return ((YY % 4 == 0 &amp;&amp; YY % 100 !=0) || (YY % 400 == 0));&#125;int main() &#123; date t; cin &gt;&gt; t.YY &gt;&gt; t.MM &gt;&gt; t.DD; for (int i = 1; i &lt;= 10000; i++) &#123; if (leap_year(t.YY)) &#123; days_in_months[2] = 29; &#125; else &#123; days_in_months[2] = 28; &#125; t++; &#125; cout &lt;&lt; t.YY &lt;&lt; &#x27;-&#x27; &lt;&lt; t.MM &lt;&lt; &#x27;-&#x27; &lt;&lt; t.DD &lt;&lt; endl; return 0;&#125; 然而，当天数过大时时间复杂度会爆掉，因此优化代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int days_in_month[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;bool isLeap(int y) &#123; return (y % 400 == 0) || (y % 100 != 0 &amp;&amp; y % 4 == 0);&#125;//格式化输出void display(int y, int m, int d) &#123; if(y &lt; 10) cout &lt;&lt; &quot;000&quot;; else if(y &lt; 100) cout &lt;&lt; &quot;00&quot;; else if(y &lt; 1000) cout &lt;&lt; 0; cout &lt;&lt; y &lt;&lt; &#x27;-&#x27;; if(m &lt; 10) cout &lt;&lt; 0; cout &lt;&lt; m &lt;&lt; &#x27;-&#x27;; if(d &lt; 10) cout &lt;&lt; 0; cout &lt;&lt; d &lt;&lt; endl;&#125;int main() &#123; //数据组数 int t; cin &gt;&gt; t; //年，月，日及增加的天数 int y, m, d, inc; while(t--) &#123; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d &gt;&gt; inc; d += inc; while(1) &#123; if(isLeap(y)) days_in_month[2] = 29; else days_in_month[2] = 28; if(d &lt;= days_in_month[m]) break; d -= days_in_month[m]; if(++m &gt; 12) m = 1, y++; &#125; display(y, m, d); &#125; return 0;&#125; 事实上，还可以使用ctime库来做。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#pragma warning(disable:4996)using namespace std;int main() &#123; struct tm d, * nd; int year, month, day; cin &gt;&gt; year &gt;&gt; month &gt;&gt; day; d.tm_year = year - 1900; //tm_year等于实际年份减去1900 d.tm_mon = month - 1; //tm_mon中0代表一月 d.tm_mday = day;//tm_mday取值范围是[1,31] d.tm_hour = 0; d.tm_min = 0; d.tm_sec = 0; time_t tt = mktime(&amp;d) + 10000 * 24 * 60 * 60;//将时间转换为自1970年1月1日以来持续时间的秒数，发生错误时返回-1 nd = gmtime(&amp;tt);//返回tm结构的格林尼治时间 cout &lt;&lt; nd-&gt;tm_year + 1900 &lt;&lt; &#x27;-&#x27; &lt;&lt; nd-&gt;tm_mon + 1 &lt;&lt; &#x27;-&#x27; &lt;&lt; nd-&gt;tm_mday &lt;&lt; endl; return 0;&#125; 清帝之惑之乾隆 实际上就是高精度计算问题，只不过输出有各种的坑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;class big_int &#123;private: vector&lt;int&gt; num;public: big_int(unsigned int _init) :num(vector&lt;int&gt;()) &#123; while (_init) &#123; num.emplace_back(_init % 10); _init /= 10; &#125; &#125; big_int(const string&amp; _init):num(vector&lt;int&gt;()) &#123; int n = _init.size(); for (int i = _init.size() - 1; i &gt;= 0; i--) &#123; num.emplace_back(_init[i] - &#x27;0&#x27;); &#125; &#125; big_int(const big_int &amp; ano):num(ano.num) &#123;&#125; big_int(const vector&lt;int&gt;&amp; ano) :num(ano) &#123;&#125; int operator[](size_t idx) &#123; if (idx &gt;= num.size()) &#123; exit(-1); &#125; else &#123; return num[idx]; &#125; &#125; big_int operator*(const big_int&amp; ano) const&#123; int n = num.size(), m = ano.num.size(); vector&lt;int&gt; ans(m + n, 0); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans[i + j] += num[i] * ano.num[j]; &#125; &#125; for (int i = m + n - 1; i &gt;= 0; i--) &#123; if (ans[i] == 0) &#123; ans.pop_back(); &#125; else &#123; break; &#125; &#125; int c = 0; for (size_t i = 0; i &lt; ans.size(); i++) &#123; ans[i] += c; c = ans[i] / 10; ans[i] %= 10; &#125; if (c &gt; 0) &#123; ans.emplace_back(c); &#125; return big_int(ans); &#125; big_int pow(int n) const&#123; big_int ans(1); for (int i = 1; i &lt;= n; i++) &#123; ans = ans * num; &#125; return ans; &#125; const size_t size() const&#123; return num.size(); &#125;&#125;;int main() &#123; string R, processed_R; int n; size_t dot_pos = 0; while (cin &gt;&gt; R &gt;&gt; n) &#123; processed_R.clear(); for (int i = R.size() - 1; i &gt;= 0; i--) &#123; if (R[i] == &#x27;0&#x27;) &#123; R.pop_back(); &#125; else &#123; break; &#125; &#125; for (size_t i = 0; i &lt; R.size(); i++) &#123; if (R[i] != &#x27;.&#x27;) &#123; processed_R.push_back(R[i]); &#125; else &#123; dot_pos = i; &#125; &#125; big_int ans = big_int(processed_R).pow(n); dot_pos = n * (R.size() - dot_pos - 1); if (dot_pos &gt;= ans.size()) &#123; cout &lt;&lt; &#x27;.&#x27;; for (int i = dot_pos - 1; i &gt;= 0; i--) &#123; if (i &gt;= ans.size()) &#123; cout &lt;&lt; 0; &#125; else &#123; cout &lt;&lt; ans[i]; &#125; &#125; &#125; else&#123; for (int i = ans.size() - 1; i &gt;= 0; i--) &#123; if (i == dot_pos) &#123; cout &lt;&lt; ans[i]; if (i != 0) &#123; cout &lt;&lt; &#x27;.&#x27;; &#125; &#125; else &#123; cout &lt;&lt; ans[i]; &#125; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 最小非负值 输入一个自然数\\(n(n&lt; 10^{1000})\\)，表示\\(1\\)到\\(n\\)共\\(n\\)个自然数排成一列，你要在每一个数前添上 + 或 - ,要使得添加符号后这个代数式的值最小且非负。 任意四个连续的自然数我们都可以让其和为\\(0\\)，因此题设要求的数列其实是一个周期数列。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int a; if (s.length() == 1) &#123; a = s[0] - &#x27;0&#x27;; &#125; else &#123; a = (s[s.length() - 1] - &#x27;0&#x27;) * 10 + s[s.length() - 2] - &#x27;0&#x27;; &#125; if (a % 4 == 1 || a % 4 == 2) &#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125; 求二叉树的先序序列 已知中序和后序序列，求先序序列，数据结构基本题目。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;string in_order, post_order;void pre_order(int in_order_left, int in_order_right, int post_order_left, int post_order_right)&#123; if (in_order_left == in_order_right) &#123; return; &#125; int cur_root = -1; for (int i = 0; i &lt; in_order_right; i++) &#123; if (in_order[i] == post_order[post_order_right - 1]) &#123; cur_root = i;//中序遍历序列里根的位置 cout &lt;&lt; in_order[cur_root]; break; &#125; &#125; pre_order(in_order_left, cur_root, post_order_left, post_order_left + cur_root - in_order_left); pre_order(cur_root + 1, in_order_right, post_order_left + cur_root - in_order_left, post_order_right - 1);&#125;int main()&#123; cin &gt;&gt; in_order &gt;&gt; post_order; pre_order(0, in_order.size(), 0, post_order.size()); return 0;&#125; 最小差距 给定一些不同的一位数字，你可以从这些数字中选择若干个，并将它们按一定顺序排列，组成一个整数，把剩下的数字按一定顺序排列，组成另一个整数。组成的整数不能以0开头（除非这个整数只有1位）。例如：给定\\(6\\)个数字为\\(\\{0,1,2,4,6,7\\}\\)，你可以用它们组成一对数\\(10\\)和\\(2467\\)，当然，还可以组成其他的很多对数，\\(204\\)和\\(176\\)。这些对数中两个数差的绝对值最小的是\\(204\\)和\\(176\\)，为\\(28\\)。 那么给定\\(N\\)个不同的\\(0\\)~\\(9\\)之间的数字，请你求出用这些数字组成的每对数中，差的绝对值最小的一对（或多对）数的绝对值是多少？ 输入包括\\((2T+1)\\)行，第一行包括一个数 \\(T(T≤1000)\\)，为测试数据的组数；接下来每组数据包括两行，第一行为一个数\\(N(2≤N≤10)\\)，表示数字的个数。下面一行为\\(N\\)个不同的一位数字。 一道贪心算法的题目，分奇数和偶数两种情况进行讨论即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;int minDiff(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (nums.size() == 2) &#123; return nums[1] - nums[0]; &#125; else &#123; if (n % 2 == 0) &#123; int last = (nums[0] == 0 ? nums[2] - nums[1] : nums[1] - nums[0]); int ans = INT_MAX; for (int i = (nums[0] == 0 ? 2 : 1); i &lt; n; i++) &#123; if (nums[i] - nums[i - 1] &lt;= last) &#123;//进行枚举 last = nums[i] - nums[i - 1]; int big = nums[i], small = nums[i - 1]; vector&lt;bool&gt; visited(n, false); visited[i] = visited[i - 1] = true; int r = n / 2 - 1; int j = n - 1; while (r) &#123; if (!visited[j]) &#123; small = small * 10 + nums[j]; r--; visited[j] = true; &#125; j--; &#125; for (j = 0; j &lt; n; j++) &#123; if (!visited[j]) &#123; big = big * 10 + nums[j]; &#125; &#125; ans = min(ans, big - small); &#125; &#125; return ans; &#125; else &#123; int big = (nums[0] == 0 ? nums[1] : nums[0]), small = 0; vector&lt;bool&gt; visited(n, false); visited[nums[0] == 0 ? 1 : 0] = true; int r = (n - 1) / 2; int j = 0; while (r) &#123; if (!visited[j]) &#123; r--; visited[j] = true; big = big * 10 + nums[j]; &#125; j++; &#125; for (j = n - 1; j &gt;= 0; j--) &#123; if (!visited[j]) &#123; small = small * 10 + nums[j]; &#125; &#125; return big - small; &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int i = 0; i &lt; T; i++) &#123; int N; cin &gt;&gt; N; vector&lt;int&gt; nums(N); for (auto&amp; i : nums) &#123; cin &gt;&gt; i; &#125; sort(nums.begin(), nums.end(), less&lt;int&gt;()); cout &lt;&lt; minDiff(nums) &lt;&lt; endl; &#125; return 0;&#125; 密码破解 已知数列数列\\(12345678910111213...\\)，输入是一个数\\(n\\)，表示求数列的第\\(n\\)位。 核心为：\\(i\\)位数共有\\(9*10^{i-1}\\)个。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;int main() &#123; int n; cin &gt;&gt; n; if (n &lt;= 9) &#123; cout &lt;&lt; n &lt;&lt; endl; return 0; &#125; else &#123; ll left = 1, right = 10, base = 9;//base不是10 int digit = 2; for (int i = 2; i &lt;= 10; i++) &#123; base *= 10; left = right; right = left + base * i; if (left &lt;= n &amp;&amp; n &lt; right) &#123; digit = i; break; &#125; &#125; int num = base / 10 + (n - left) / digit; int c = (n - left) / digit + 1; int k = (digit - 1) - (n - (left + (c - 1) * digit)); if (k == 0) &#123; k = digit - 1; &#125; while (k) &#123; num /= 10; k--; &#125; cout &lt;&lt; num % 10 &lt;&lt; endl; &#125; return 0;&#125; 参考资料 求平面内最近点对","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法分析与设计第五次作业题题解","slug":"算法分析与设计第五次作业题题解","date":"2021-11-09T09:08:53.000Z","updated":"2022-09-16T01:40:41.251Z","comments":true,"path":"2021-11-09-算法分析与设计第五次作业题题解/","link":"","permalink":"http://example.com/2021-11-09-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"动态规划的题目。","text":"动态规划的题目。 个人认为学习动态规划更容易理解的学习路径为暴力搜索\\(\\Rightarrow\\)记忆化搜索优化\\(\\Rightarrow\\)动态规划。 Problem A 题目描述 给定\\(1×N\\)的单行矩阵，矩阵每个元素都是\\(-127\\)到\\(127\\)之间的整数。请找到一个连续子矩阵，使得其元素之和最大。 输入数据 多组测试数据，每组数据的第一行为一个整数\\(N(N \\leq 100)\\)，第二行包含\\(N\\)个整数，为行矩阵的\\(N\\)个元素，每个元素介于\\(-127\\)到\\(127\\)之间。 输出数据 最大子矩阵之和，每组对应一行。 样例输入 12100 -2 -7 0 -2 11 -4 13 -5 -2 样例输出 120 题目分析 求最大连续子序列之和的题目。 题解 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int N; while (cin &gt;&gt; N) &#123; vector&lt;int&gt; nums(N); for (auto&amp; i : nums) &#123; cin &gt;&gt; i; &#125; vector&lt;int&gt; dp(N, INT_MIN); int ans = INT_MIN; dp[0] = nums[0]; for (int i = 1; i &lt; N; i++) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); ans = max(ans, dp[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem B 题目描述 给定\\(N×N\\)矩阵，矩阵元素都是\\(-127\\)到\\(127\\)之间的整数。请找到一个子矩阵，使得其元素之和最大。 输入数据 多组测试数据，每组测试数据的第一行整数\\(N (N \\leq 100)\\)；接下来N行元素，每行N个元素，每个元素介于\\(-127\\)到\\(127\\)之间。 输出数据 最大子矩阵元素之和，每组测试数据对应一行。 样例输入 1234540 -2 -7 09 2 -6 2-4 1 -4 1-1 8 0 -2 样例输出 115 题目分析 思想与A题类似，本题对输入的矩阵进行列的求和，然后用\\(i\\)和\\(j\\)对行进行遍历\\((1 \\leq i \\leq j \\leq N)\\)，然后对于确定的\\(i\\)和\\(j\\)，使用\\(k\\)进行列的遍历，最后求出最大的结果即可。 题解 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int N; ios::sync_with_stdio(false); cin.tie(0); while (cin &gt;&gt; N) &#123; vector&lt;vector&lt;int&gt;&gt; nums(N + 1, vector&lt;int&gt;(N + 1)); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(N + 1, INT_MIN)); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; dp[i][j] = dp[i - 1][j] + nums[i][j]; &#125; &#125; int ans = nums[0][0]; for (int i = 1; i &lt;= N; i++) &#123; for (int j = i; j &lt;= N; j++) &#123; int _sum = 0; for (int k = 1; k &lt;= N; k++) &#123; _sum = max(dp[j][k] - dp[i - 1][k] + _sum, dp[j][k] - dp[i - 1][k]); ans = max(ans, _sum); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem C 题目描述 作为一个有很多游戏想买但囊中羞涩的大学生，小明决定在这个暑假开始打工赚钱。经过一段时间的寻找，他一共找到了\\(n\\)个打工的招聘广告，其中第\\(i\\)个打工的日期从\\(l_i\\)开始，到\\(r_i\\)为止，一共付给他\\(c_i\\)元钱。因为这些打工的时间都相互冲突，所以同一天小明最多参加一个打工，并且一个打工一旦开始，就必须一直工作到结束，不能中途退出。现在小明想要知道，这个暑假他打工最多能得到多少钱？ 输入数据 第一行一个整数\\(n(1 \\leq n \\leq 1000000)\\)，表示招聘广告的数量；接下来一共\\(n\\)行，每行3个整数\\(l_i,r_i,c_i(1 \\leq l_i ≤ r_i \\leq 1000000,1 \\leq c_i \\leq 1000000000)\\)，表示打工的开始时间，结束时间和报酬。 输出数据 一行一个整数\\(k\\)，表示小明最多能够得到的钱数。 样例输入 123431 2 33 4 32 3 5 样例输出 16 题目分析 基本思路 这题目的思路可以从LintCode 515题中得到一些启发。如果采用动态规划的话，对于\\(n\\)项工作而言，每一项工作只有选和不选两种情况，设\\(dp[i][0]、dp[i][1]\\)为第\\(i\\)件工作接受或者不接受的条件下所获得的最大酬劳，那么最终的答案为\\(max(dp[n][0],dp[n][1])\\)。 但是本题对于每项工作的选择是有后效性的，必须要满足时间的约束条件；而要使得获得的薪酬最大，应该尽可能多做一些工作。根据会场安排的问题可以想到应该按照工作的结束时间进行排序。 会场安排问题 假设某社团某一天要组织\\(𝑛\\)个活动\\(𝐸=\\begin{Bmatrix}1, 2,⋯,n\\end{Bmatrix}\\)，其中每个活动都要求使用同一礼堂，而且在同一时间内只有一个活动能使用这个礼堂。每个活动\\(i\\)都有一个要求使用礼堂的起始时间\\(s_i\\)和结束时间\\(f_i\\)，且有\\(s_i &lt; f_i\\)。如果选择了活动\\(i\\)，则它在半开时间区间\\([s_i,f_i)\\)内占用资源。若区间\\([s_i,f_i)\\)与区间\\([s_j,f_j)\\)不相交，则称活动\\(i\\)与活动\\(j\\)是相容的。现在给定𝑛个活动的开始时间和结束时间，请设计一个活动安排方案，使得安排的相容活动数目最多。 分析题目，要解决这个问题可以使用二进制枚举，但是时间复杂度是\\(O(2^n)\\)，不可以接受，因此换一个思路。使用贪心的策略大致有三个思路： 按照占用时间短优先； 按照开始时间早优先； 按照结束时间早优先。 对于前两种情况，都可以找出反例证明贪心算法不成立：对于按照占用时间短优先的方案，反例为\\([0,10),[9,14),[13,17)\\)，按照占用时间短优先的话应该先安排\\([9,14)\\)，而最优安排显然是选另外两个；对于按照开始时间早优先的方案，反例为\\([0,10),[2,5),[6,7)\\)，显然。那么如何证明按照结束时间早的贪心策略是正确的呢？ 将集合\\(S\\)中的活动按照结束时间递增顺序排列，即记为\\(S=\\begin{Bmatrix}1,2,⋯,n \\end{Bmatrix}\\)；假设\\(A=\\begin{Bmatrix}j_1,j_2,...,j_m \\end{Bmatrix}\\)是\\(S\\)的一个最优解，其中活动也按照结束时间递增顺序排列。不妨设\\(B=\\begin{Bmatrix}A_1,A_2,⋯,A_c \\end{Bmatrix}\\)为该问题的最佳解构成的集合，显然对于任意一个有限的会场安排问题，总是存在最优解。现在需要证明对于贪心算法得出的这样的解\\(A\\)总满足\\(A \\in B\\)。 设\\(k=1\\)时选择活动为\\(\\begin{Bmatrix}1\\end{Bmatrix}\\)，需要证明存在一个最优解包含\\(\\begin{Bmatrix}1\\end{Bmatrix}\\)，若\\(j_1=1\\)，那么最优解包含了\\(\\begin{Bmatrix}1\\end{Bmatrix}\\)；否则，用活动\\(1\\)替换最优解中的\\(j_1\\)，显然\\(A&#39;=\\begin{Bmatrix} 1,j_2,...,j_m \\end{Bmatrix}\\)也是一个相容的活动集合（\\(1\\)是结束时间最早的活动），也是一个最优的活动安排。 当\\(k&gt;1\\)时，设\\(\\{ i_1,1_2,...,i_k \\}\\)是贪心算法前\\(k\\)步顺序选择的活动，那么存在一个最优解:\\(A=\\{ i_1=1,1_2,...,i_k \\} \\bigcup B\\)。假设\\(S&#39;\\)是\\(S\\)中与\\(\\{ i_1, i_2,⋯,i_k \\}\\)相容的活动，即\\(S&#39;=\\{ j | s[j]≥𝑓[i_k], j \\in 𝑆 \\}\\)，那么\\(B\\)是\\(S&#39;\\)的一个最优解。再用刚才关于活动\\(1\\)的替换等价性证明可知\\(𝑆&#39;\\) 的结束时间最早的活动\\(𝑖_{𝑘+1}\\)包含在某一个最优解\\(B&#39;\\)中，则可以构造原问题的一个最优解为\\(A&#39;=\\{ i_1=1,1_2,...,i_k,i_{k+1} \\} \\bigcup (B - \\{ i_{k+1} \\})\\)。 最终的代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;struct activity &#123; int start; int end; bool operator&lt;(const activity&amp; b) const&#123; return end &lt; b.end; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; if (n &lt; 1) &#123; return 0; &#125; vector&lt;activity&gt; act(n); for (auto&amp; i : act) &#123; cin &gt;&gt; i.start &gt;&gt; i.end; &#125; sort(act.begin(), act.end()); int ans = 1;//选择第一个活动 int last_selected = 0; for (int i = 1; i &lt; n; i++) &#123; if (act[i].start &gt;= act[last_selected].end) &#123; last_selected = i; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;/*测试用例1（答案为2）30 102 57 9测试用例2（答案为2）30 43 54 9*/ 网上查找了资料后发现本题或许可以使用树状数组来解决。 树状数组 树状数组可以解决大部分基于区间上的更新以及求和问题。设结点编号为\\(x\\)，那么该节点维护的值为\\((x-\\text{lowbit}(x),x]\\)的和，其中\\(\\text{lowbit}(x)=x^k\\)，其中\\(k\\)为\\(x\\)最低位1所在的二进制位。这种情况下要求树状数组的编号范围是\\([1,2^n]\\)。 \\(\\text{lowbit}\\)值一般使用\\(x \\&amp; (-x)\\)的方式计算，这一点利用了补码的运算性质，证略。 本题目使用树状数组进行了工作结束日期的统计。 最后改完代码后发现用 vector 空间会爆掉，所以直接使用空间足够大的数组即可。 题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_SIZE 1000005using ll = long long;using namespace std;struct adver &#123; int start; int end; int income;&#125;;ll dp[MAX_SIZE][2];ll temp[MAX_SIZE];adver adver_info[MAX_SIZE];int lowbit(int i) &#123; return i &amp; (-i);&#125;int sum(int i) &#123;//统计结束日期小于i的工作数量 int s = 0; while (i &gt; 0) &#123; s += temp[i]; i -= lowbit(i); &#125; return s;&#125;void add(int i) &#123;//添加一个结束日期为i的工作 if (i &gt; 0)&#123; while (i &lt; MAX_SIZE) &#123; temp[i]++; i += lowbit(i); &#125; &#125;&#125;bool cmp(adver&amp; a, adver&amp; b) &#123;//排序依据 return a.end &lt; b.end;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin &gt;&gt; n; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; adver_info[i].start &gt;&gt; adver_info[i].end &gt;&gt; adver_info[i].income; &#125; sort(adver_info + 1, adver_info + n + 1, cmp); //sort(adver_info + 1, adver_info + n + 1, [](adver&amp; a, adver&amp; b) &#123; return a.end &lt; b.end; &#125;); //sort(adver_info + 1, adver_info + n + 1, comparator(adver, end)); for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); ll s = sum(adver_info[i].start - 1); dp[i][1] = max(dp[s][0], dp[s][1]) + adver_info[i].income; add(adver_info[i].end); &#125; ans = max(dp[n][1], dp[n][0]); cout &lt;&lt; ans &lt;&lt; endl;&#125; Problem D 题目描述 给定一个信封，最多只允许粘贴\\(N\\)张邮票，计算在给定\\(M(N+M \\leq 10)\\)种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大\\(max\\)，使得\\(\\{1,\\dots ,max\\}\\)的每一个邮资值都能得到？ 输入数据 一行，分别为\\(N,M\\)。 输出数据 第一行为\\(m\\)种邮票的面值，按升序排列，各数之间用一个空格隔开；第二行为最大值，格式为：\"MAX=%d\" 。 样例输入 13 2 样例输出 121 3MAX=7 题目分析 对于已知邮票面值的情况下，可以使用动态规划求出最大的面值；要求出邮票的面值，可以使用深度优先搜索算法。 题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*每次在增加邮票面值时，所需要枚举的空间为上次求得的最大值+1到上一个枚举出来的邮票面值+1，上界很显然，由于邮票面值是要求递增的，因此在求的时候采用递增的策略即可，因此下界选择上一个枚举出来的邮票面值+1*/#include &lt;bits/stdc++.h&gt;using namespace std;int temp_denomination[15];int ans_denomination[15];//1~m储存结果int n, m;//n为最多可贴的邮票数；m为邮票种数int MAX = 0;int calculate_MAX(int cur_num) &#123;//计算num个面值的邮票的MAX if (cur_num == 0) &#123; return 0; &#125; else &#123;//有点像lintcode749 vector&lt;int&gt; dp(1001, INT_MAX); dp[0] = 0; int i = 0;//面值为1 3 输入为3 2 if (temp_denomination[1] == 1 &amp;&amp; temp_denomination[2] == 3) &#123; system(&quot;pause&quot;); &#125; while (dp[i] &lt;= n) &#123;//dp[i]总价为i分且面值由cur_num种时、所需要的邮票张数 i++; for (int j = 1; j &lt;= cur_num &amp;&amp; temp_denomination[j] &lt;= i; j++) &#123; dp[i] = min(dp[i - temp_denomination[j]] + 1, dp[i]); &#125; &#125; return i - 1; &#125;&#125;void dfs(int cur_num) &#123; if (cur_num == m) &#123;//深度优先搜索的最大深度为m，即只需要求出m个面值 int c = calculate_MAX(m);//利用动态规划计算MAX if (c &gt; MAX) &#123;//计算当前所得的MAX值，如果比之前的大就更新MAX与面值 for (int i = 1; i &lt;= m; i++) &#123; ans_denomination[i] = temp_denomination[i]; &#125; MAX = c; &#125; return; &#125; else &#123;//没有达到最大深度 int temp = calculate_MAX(cur_num);//计算当前所得的MAX值 for (int i = temp + 1; i &gt;= temp_denomination[cur_num] + 1; i--) &#123;//贪心算法的部分 temp_denomination[cur_num + 1] = i;//往下续，小面值已经不够用了，因此采用temp_MAX + 1 dfs(cur_num + 1); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; dfs(0); cout &lt;&lt; ans_denomination[1]; for (int i = 2; i &lt;= m; i++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; ans_denomination[i]; &#125; cout &lt;&lt; endl &lt;&lt; &quot;MAX=&quot; &lt;&lt; MAX &lt;&lt; endl; return 0;&#125; Problem E 题目描述 某国为了防御敌国的导弹袭击，研发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试验阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入数据 输入数据只有一行，该行包含若干个数据，之间用半角逗号隔开，表示导弹依次飞来的高度（导弹最多有\\(20\\)枚，其高度为不大于\\(3×10^3\\)的正整数）。 输出数据 输出数据只有一行，该行包含两个数据，之间用半角逗号隔开。第一个数据表示这套系统最多能拦截的导弹数；第二个数据表示若要拦截所有导弹至少要再添加多少套这样的系统。 样例输入 1389,207,155,300,299,170,158,65 样例输出 16,1 题解 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int h; char c; vector&lt;int&gt; height; while (1) &#123; cin &gt;&gt; h; c = getchar(); height.emplace_back(h); if (c == &#x27;\\n&#x27;) &#123; break; &#125; &#125; int n = height.size(); vector&lt;int&gt; dp(n, 1); int ans1 = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (height[i] &lt; height[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); ans1 = max(ans1, dp[i]); &#125; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; &#x27;,&#x27;; for (auto&amp; i : dp) &#123; i = 1; &#125; int ans2 = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (height[i] &gt; height[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); ans2 = max(ans2, dp[i]); &#125; &#125; &#125; cout &lt;&lt; ans2 - 1 &lt;&lt; endl; return 0;&#125; 参考资料 树状数组详解 小明的打工计划","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"单调栈和单调队列","slug":"单调栈和单调队列","date":"2021-10-25T13:07:20.000Z","updated":"2022-09-15T03:51:16.783Z","comments":true,"path":"2021-10-25-单调栈和单调队列/","link":"","permalink":"http://example.com/2021-10-25-%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"单调栈和单调队列可以用来降低一些查找问题的时间复杂度。","text":"单调栈和单调队列可以用来降低一些查找问题的时间复杂度。 内容待补充。 LintCode 1316 本题对于算法的时间复杂度要求较高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: /** * @param arr: the arr * @return: the sum of the luck number */ static bool pairComByFirst(pair&lt;int, int&gt;a, pair&lt;int, int&gt;b) &#123; return a.first &lt; b.first; &#125; int luckNumber(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); int ans = 0; vector&lt;pair&lt;int, int&gt;&gt; a; for (int i = 0; i &lt; n; i++) &#123; a.emplace_back(pair&lt;int, int&gt;(arr[i], i)); &#125; sort(a.begin(), a.end(), pairComByFirst); vector&lt;int&gt; l(n, 0), r(n, 0); stack&lt;pair&lt;int, int&gt;&gt; s; pair&lt;int, int&gt; fir(0, 0); for (int i = 0; i &lt; n; i++) &#123; while (!s.empty()) &#123; fir = s.top(); if (a[i].second &lt; fir.second) &#123; l[fir.second] = a[i].first; s.pop(); &#125; else &#123; break; &#125; &#125; s.push(a[i]); &#125; while (!s.empty()) &#123; s.pop(); &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; while (!s.empty()) &#123; fir = s.top(); if (a[i].second &gt; fir.second) &#123; r[fir.second] = a[i].first; s.pop(); &#125; else &#123; break; &#125; &#125; s.push(a[i]); &#125; for (int i = 1; i &lt; n - 1; i++) &#123; if (l[i] &amp;&amp; r[i] &amp;&amp; l[i] % r[i] == 0) &#123; ans++; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法分析与设计第四次作业题题解","slug":"算法分析与设计第四次作业题题解","date":"2021-10-24T15:05:07.000Z","updated":"2023-01-19T09:55:15.761Z","comments":true,"path":"2021-10-24-算法分析与设计第四次作业题题解/","link":"","permalink":"http://example.com/2021-10-24-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"题目发布于2021年10月25日下午5点。","text":"题目发布于2021年10月25日下午5点。 本次题目主要都是动态规划，A题和B题都是换汤不换药的0-1背包问题，C题是求最大递增、递减子序列，D题是很基础的路径问题，E题也很易得递推方程。 Problem A 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int T, M; cin &gt;&gt; T &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(T + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123;//最好外层是物品件数 for (int j = T; j &gt;= cost[i]; j--) &#123;//内层是cost，此时顺向、逆向枚举均可 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[M][T] &lt;&lt; endl; return 0;&#125; Problem B 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int V, M; cin &gt;&gt; V &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i]; value[i] = cost[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(V + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123; for (int j = V; j &gt;= cost[i]; j--) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i]] + value[i]); &#125; &#125; cout &lt;&lt; V - dp[M][V] &lt;&lt; endl; return 0;&#125; 此外，0-1背包问题还可以进行空间的优化。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int T, M; cin &gt;&gt; T &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i]; &#125; vector&lt;int&gt;dp(T + 1, 0); for (int i = 1; i &lt;= M; i++) &#123; for (int j = T; j &gt;= cost[i]; j--) &#123;//注意压缩空间后必须逆向枚举j dp[j] = max(dp[j], dp[j - cost[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; return 0;&#125; 多重背包问题、完全背包问题与0-1背包问题类似。 多重背包问题代码如下。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int V, M; cin &gt;&gt;V &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1), nums(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i] &gt;&gt; nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(V + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123; for (int j = cost[i]; j &lt;= V; j++) &#123; for (int k = 0; j &gt;= k * cost[i] &amp;&amp; k &lt;= nums[i]; k++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * cost[i]] + k * value[i]); &#125; &#125; &#125; cout &lt;&lt; dp[M][V] &lt;&lt; endl; return 0;&#125; 完全背包问题代码如下。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int V, M; cin &gt;&gt;V &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(V + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123; for (int j = cost[i]; j &lt;= V; j++) &#123; for (int k = 0; j &gt;= k * cost[i]; k++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * cost[i]] + k * value[i]); &#125; &#125; &#125; /*或者可以这样 for (int i = 1; i &lt;= M; i++) &#123; for (int j = cost[i]; j &lt;= V; j++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - cost[i]] + value[i]); //与0-1背包问题的唯一不同就是后一项中dp那部分的下标由(i - 1, j - cost[i])变为了(i, j - cost[i]) &#125; &#125; */ cout &lt;&lt; dp[M][V] &lt;&lt; endl; return 0;&#125; Problem C 题目描述 \\(N\\)位同学站成一排，音乐老师要请其中的\\((N-K)\\)位同学出列，使得剩下的\\(K\\)位同学排成合唱队形。 合唱队形是指这样的一种队形：设\\(K\\)位同学从左到右依次编号为\\(1,2,...,K\\)，他们的身高分别为\\(T_1,T_2,...,T_K\\)，则他们的身高满足\\(T_1&lt;...&lt;T_i\\)且\\(T_i&gt; T_{i+1}&gt;...&gt;T_K(1 \\leq i \\leq K)\\)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 题解 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int N; cin &gt;&gt; N; int K = 0; vector&lt;int&gt; T(1, -1); //第i位同学左侧最长单调增子序列、右侧最长单调减子序列的长度 for (int i = 0; i &lt; N; i++) &#123; int Ti; cin &gt;&gt; Ti; T.emplace_back(Ti); &#125; vector&lt;int&gt; dp_l(N + 1, 0), dp_r(N + 1, 0); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; if (T[i] &gt; T[j]) &#123; dp_l[i] = max(dp_l[i], dp_l[j] + 1); &#125; &#125; &#125; for (int i = N; i &gt;= 1; i--) &#123; for (int j = N; j &gt; i; j--) &#123; if (T[i] &gt; T[j]) &#123; dp_r[i] = max(dp_r[i], dp_r[j] + 1); &#125; &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; K = max(K, dp_l[i] + dp_r[i] + 1); &#125; cout &lt;&lt; N - K &lt;&lt; endl; return 0;&#125; Problem D 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int m, n, x, y;bool valid(int i, int j)&#123; return !((i == x &amp;&amp; j == y) || ((x - i) * (x - i) + (y - j) * (y - j) == 5));&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;//卒要从(0, 0)到(n, m)，马在(x, y)处不会动，马所能一步到达的位置和马自身的位置设定为不可达，卒只能向右或向下走，每次一步 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); dp[0][0] = valid(0, 0) ? 1 : 0; for(int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; if (i + j &amp;&amp; valid(i, j)) &#123; if (i == 0) &#123; dp[i][j] += dp[i][j - 1]; &#125; else if (j == 0) &#123; dp[i][j] += dp[i - 1][j]; &#125; else &#123; dp[i][j] += dp[i - 1][j]; dp[i][j] += dp[i][j - 1]; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl; return 0;&#125; Problem E 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m;//n人传球m次，只能传给编号相邻的同学，从1号开始发球，求有多少种传球方法最后球能回到1号同学手里；注意1-&gt;2算一次传球 vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); dp[0][1] = 1;//dp[i][j]代表第i次传到编号为j的同学处的方法数 for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int l = j &gt; 1 ? j - 1 : n; int r = j &lt; n ? j + 1 : 1; dp[i][j] = dp[i - 1][l] + dp[i - 1][r]; &#125; &#125; cout &lt;&lt; dp[m][1] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"排序算法","slug":"排序算法","date":"2021-10-14T02:32:29.000Z","updated":"2022-10-17T02:33:10.059Z","comments":true,"path":"2021-10-14-排序算法/","link":"","permalink":"http://example.com/2021-10-14-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"一些排序算法的 C++ 实现。","text":"一些排序算法的 C++ 实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167class my_sort &#123;public: /*交换排序：冒泡排序、快速排序*/ void bubble_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[i] &gt; arr[j]) &#123; swap(arr[i], arr[j]); &#125; &#125; &#125; &#125; void quick_sort(vector&lt;int&gt;&amp; arr) &#123; _quick_sort_(arr, 0, arr.size() - 1); &#125; /*二路归并排序*/ void merge_sort(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; temp(arr.size()); merge(temp, arr, 0, arr.size()); &#125; /*插入排序：（折半、简单）插入排序、希尔排序*/ void shell_sort(vector&lt;int&gt;&amp; arr) &#123; for (int seg = arr.size(); seg &gt; 0; seg /= 2) &#123; single_shell_sort(arr, seg); &#125; &#125; void insertion_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = 1; i &lt; n; i++) &#123; //for (int j = i - 1; j &gt;= 0; j--) &#123; // if (arr[j] &gt; arr[j + 1]) &#123; // swap(arr[j], arr[j + 1]); // &#125; //&#125; int l = 0, r = i; while (l &lt; r) &#123;//[0,i) int mid = l + (r - l) / 2; if (arr[mid] &lt; arr[i]) &#123; l = mid + 1; &#125; else &#123; r = mid; &#125; &#125; for (int j = i; j &gt;= l + 1; j--) &#123; swap(arr[j], arr[j - 1]); &#125; &#125; &#125; /*选择排序：简单选择排序、堆排序*/ void heap_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; heap_adjust(arr, i, n - 1); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; swap(arr[0], arr[i]); heap_adjust(arr, 0, i - 1); &#125; &#125; void selection_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; swap(arr[i], arr[find_min(arr, i)]); &#125; &#125;private: void single_shell_sort(vector&lt;int&gt;&amp; arr, int dk) &#123; int n = arr.size(); for (int i = dk; i &lt; n; i++) &#123; if (arr[i] &lt; arr[i - dk]) &#123; int tmp = arr[i]; int j = 0; for (j = i - dk; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j -= dk) &#123; arr[j + dk] = arr[j]; &#125; arr[j + dk] = tmp; &#125; &#125; &#125; void heap_adjust(vector&lt;int&gt;&amp; arr, int start, int end) &#123; int dad = start; int son = dad * 2 + 1; while (son &lt;= end) &#123; if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) &#123; son++; &#125; if (arr[son] &lt; arr[dad]) &#123;//son比dad、son+1都小 return; &#125; else &#123; swap(arr[dad], arr[son]); dad = son; son = dad * 2 + 1; &#125; &#125; &#125; void _quick_sort_(vector&lt;int&gt;&amp; arr, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; else &#123; int i = start, j = end; int tmp = arr[start]; while (i &lt; j) &#123; for (; i &lt; j &amp;&amp; tmp &lt; arr[j];j--) &#123;&#125; if (i &lt; j) &#123; swap(arr[i], arr[j]); i++; &#125; for (; i &lt; j &amp;&amp; arr[i] &lt; tmp ;i++) &#123;&#125; if (i &lt; j) &#123; swap(arr[i], arr[j]); j--; &#125; &#125; _quick_sort_(arr, start, i - 1); _quick_sort_(arr, i + 1, end); &#125; &#125; int adjust_arr(vector&lt;int&gt;&amp; arr, int l, int r) &#123; int i = l + 1, j = r - 1, key = arr[l]; while (i &lt; j) &#123; for(; arr[i] &lt;= key &amp;&amp; i &lt; j; i++) &#123;&#125; swap(arr[l], arr[i]); for(; arr[j] &gt;= key &amp;&amp; i &lt; j; j--) &#123;&#125; swap(arr[l], arr[j]); &#125; return i; &#125; void merge(vector&lt;int&gt;&amp; temp, vector&lt;int&gt;&amp; arr, int l, int r) &#123;//[l,r) if (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; merge(temp, arr, l, mid); merge(temp, arr, mid, r); int i = l, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; r) &#123; temp[k] = (arr[i] &lt; arr[j] ? arr[i++] : arr[j++]); k++; &#125; while (j &lt; r) &#123; temp[k++] = arr[j++]; &#125; while (i &lt; mid) &#123; temp[k++] = arr[i++]; &#125; for (int i = 0; i &lt; k; i++) &#123; arr[i + l] = temp[i]; &#125; &#125; &#125; int find_min(vector&lt;int&gt;&amp; arr, int cur_index) &#123;//选择序号[i,n)中的最小值 int i = cur_index, n = arr.size(); for (int j = i; j &lt; n; j++) &#123; i = (arr[j] &lt; arr[i] ? j : i); &#125; return i; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"二分查找学习","slug":"二分查找学习","date":"2021-10-11T09:41:26.000Z","updated":"2023-01-07T09:38:48.580Z","comments":true,"path":"2021-10-11-二分查找学习/","link":"","permalink":"http://example.com/2021-10-11-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AD%A6%E4%B9%A0/","excerpt":"折半查找的思想十分简单，其效率也很高；但是要将其运用到实际程序中却并不容易，需要考虑很多细节上的问题。","text":"折半查找的思想十分简单，其效率也很高；但是要将其运用到实际程序中却并不容易，需要考虑很多细节上的问题。 在数组中查找 设 arr 为一个数组， target 为目标值。假设 arr 已经是升序排序过的并且下文中默认这个条件。取 arr 的长度为\\(L\\)。 查找值 假定需要在 arr 中查找是否存在等于 target 的元素，如果查找到了则返回对应元素的下标；否则返回\\(-1\\)。 对于这种情况，返回结果的范围是\\(\\{-1\\} \\bigcup \\{0,1,\\dots ,L-1\\}\\)，因此取初始区间\\([l, r]\\)为\\([0,L-1]\\)，若找到 target 直接返回 mid ，否则一直查找，最后返回\\(-1\\)即可。值得注意还有结束条件，由于查找的有效结果是一个值，因此要保证区间\\([0,L-1]\\)中没有遗漏的值，那么必须保证没有找到的条件下，退出时的区间\\([l,r]\\)满足\\(l &gt; r\\)，可以得出循环条件为\\(l \\leqslant r\\)。 12345678910111213141516int findVal(vector&lt;int&gt; arr, int target) &#123; int l = 0, r = arr.size() - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (arr[mid] == target) &#123; return mid; &#125; else if (arr[mid] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return -1;&#125; 查找界 假定要查找 arr 中 target 的上确界，并且要求如果所有元素均大于等于 target 则返回\\(0\\)，如果所有元素均小于等于 target 则返回\\(L\\)。 对于这种情况，返回结果的范围是\\(\\{0,1,\\dots ,L-1\\} \\bigcup \\{L\\} = \\{0,1,\\dots ,L-1,L\\}\\)，因此取初始区间\\([l, r]\\)为\\([0,L]\\)，若 target \\(\\leqslant\\) arr[mid] ，那么可能的结果区间为\\([l,mid]\\)，则更新\\(r=mid\\)；否则更新区间为\\([mid+1,r]\\)。由于最终退出循环时为一个区间\\([l,r]\\)，其中\\(l \\leqslant r\\)，那么结束条件为\\(l \\leqslant r\\)，可以得出循环条件为\\(l&lt;r\\)，最终的返回值为\\(l\\)。 12345678910111213int findSupremum(vector&lt;int&gt; arr, int target) &#123; int l = 0, r = arr.size(); while (r - l &gt; 1) &#123; int mid = (l + r) / 2; if (arr[mid] &gt;= target) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;//返回第一个元素的下标&#125; 查找下确界同理。 12345678910111213int findInfimum(vector&lt;int&gt; arr, int target) &#123; int l = 0, r = arr.size(); while (r - l &gt; 1) &#123; int mid = (l + r) / 2; if (arr[mid] &lt;= target) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return r;//返回最后一个元素的下标&#125; findSupremum() 函数实现了查找第一个大于等于 target 的数的功能，findInfimum() 实现了查找最后一个小于等于 target 的数的功能。通过修改循环中分支的条件可以更改查找的功能。","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"算法分析与设计第三次作业题解","slug":"算法分析与设计第三次作业题题解","date":"2021-10-11T03:31:14.000Z","updated":"2022-10-17T03:31:28.169Z","comments":true,"path":"2021-10-11-算法分析与设计第三次作业题题解/","link":"","permalink":"http://example.com/2021-10-11-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"题目发布于2021年10月11日零点。","text":"题目发布于2021年10月11日零点。 Problem A 题目描述 我们有\\(n\\)根的木棍。现在从这些木棍中切割出来\\(m\\)条长度相同的木棍，问这\\(m\\)根木棍最长有多长？ 题解 实际上就是切绳子的问题，直接贴代码。注意\\(r\\)要足够大，\\(l\\)最好不要取负数 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool isOk(vector&lt;int&gt;&amp;length, int mid, int k) &#123; for (int i = 0; i &lt; length.size(); i++) &#123; k -= length[i] / mid; &#125; return k &lt;= 0;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; length(n); int max_len = 0; for (int i = 0; i &lt; n; i++) &#123; double temp; cin &gt;&gt; temp; length[i] = temp * 100; max_len = max(max_len, length[i]); &#125; int l = 1, r = 1000000000; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (isOk(length, mid, k)) &#123; ans = max(mid, ans); l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; ans / 100.0 &lt;&lt; endl; return 0;&#125; Problem B 题目描述 有一条河，河中间有一些石头，已知石头的数量和相邻两块石头之间的距离。现在可以移除一些石头，问最多移除\\(m\\)块石头后（首尾两块石头不可以移除），相邻两块石头之间的距离的最小值最大是多少。 输入数据 第一行输入两个数字，\\(n(2 \\leq n \\leq 1000)\\)为石头的个数，\\(m(0 \\leq m \\leq n-2)\\)为可移除的石头数目，随后\\(n-1\\)个数字，表示顺序和相邻两块石头的距离\\(d(d \\leq 1000)\\)。 题解 这个题乍看很迷惑，事实上这个题可以用二分查找进行解决。逆向思考，判断任意两块石头之间的距离均大于等于\\(d\\)时，移除石头数\\(f(d)\\)是否满足\\(f(d) \\leq m\\)。直接使用 vector 可以避免用 list 删除时的各种麻烦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;bool valid(int mid, vector&lt;int&gt;&amp; stones, int m);int main() &#123; int n, m; int _max = 0; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; stones(n + 1, 0); for (int i = 2; i &lt;= n; i++) &#123; int temp; cin &gt;&gt; temp; stones[i] = stones[i - 1] + temp; &#125; int l = 0, r = 100000000; while (l &lt; r - 1) &#123; int mid = (l + r) / 2; if (valid(mid, stones, m)) &#123; l = mid; &#125; else &#123; r = mid; &#125; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125;/*我的思路：逐个遍历stones，遇到小的就优先和后面的合并总保证当前指针的位置之前都是合法的*/bool valid(int mid, vector&lt;int&gt;&amp;stones, int m) &#123; int count = 0, back = 2, fr = 1; while (back &lt; stones.size()) &#123; int d = stones[back] - stones[fr]; while (d &lt; mid) &#123; back++; count++; if (count &gt; m) &#123; return false; &#125; if (back == stones.size()) &#123; return fr != 1; &#125; d = stones[back] - stones[fr]; &#125; fr = back; back++; &#125; return true;&#125; Problem C 题目描述 楼梯有n阶，可以一步上一阶、两阶或三阶，问有多少种不同的走法。由于答案很大，模\\(10^9+7\\)输出。 题解 动态规划可解的题目，比较基础。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;#define MOD 1000000007using namespace std;int main()&#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; dp(4, 0);//dp(n + 1, 0)平台会报runtime error dp[1] = 1; dp[2] = 2; dp[3] = 4; for (int i = 4; i &lt;= n; i++) &#123; //dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD; long long tmp = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD; dp.emplace_back(tmp); &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125; Problem D 题目描述 一个快递公司要将\\(n\\)个包裹分别送到\\(n\\)个地方，并分配给邮递员小K一个事先设定好的路线，小K需要开车按照路线给的地点顺序相继送达，且不能遗漏一个地点。小K得到每个地方可以签收的时间段，并且也知道路线中一个地方到下一个地方的距离。若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收，但不能晚于签收的时间段，可以认为签收的过程是瞬间完成的。 为了节省燃料，小K希望在全部送达的情况下，车的最大速度越小越好，就找到了你给他设计一种方案，并求出车的最大速度最小是多少。 输入数据 第1行为一个正整数\\(n(n&lt;2×10^4)\\)，表示需要运送包裹的地点数。 下面 n 行，第 i+1 行有 3 个正整数\\(x_i,y_i,s_i\\)， 表示按路线顺序给出第\\(i\\)个地点签收包裹的时间段为\\([x_i,y_i]\\)，即最早为距出发时刻\\(x_i\\)，最晚为距出发时刻\\(y_i\\)，从前一个地点到达第\\(i\\)个地点距离为 \\(s_i\\)，且保证路线中\\(x_i\\)递增。 可以认为\\(s1\\)为出发的地方到第\\(1\\)个地点的距离，且出发时刻为\\(0\\)。 题解 还是二分查找的题目。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 0.00001;bool valid(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y, vector&lt;int&gt;&amp; s, long double mid);int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; x(n), y(n), s(n); long double ans = 0.0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; s[i]; &#125; long double l = 1, r = 1e9; while (r -l &gt;= eps) &#123; long double mid = (l + r) / 2; if (valid(x, y, s, mid)) &#123; ans = mid; r = mid; &#125; else &#123; l = mid; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;bool valid(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y, vector&lt;int&gt;&amp; s, long double mid) &#123; int n = x.size(); long double t = 0.0; for (int i = 0; i &lt; n; i++) &#123; t += s[i] / mid; t = (t &lt; x[i] ? x[i] : t); if (t &gt; y[i]) &#123; return false; &#125; &#125; return true;&#125; Problem E 题目描述 有ABC三根杆和一些圆盘，开始的时候圆盘从小到大摞在A杆上，小盘在上大盘在下，规定如果圆盘p摞在圆盘q上面，那么\\(r_p \\leq r_q\\)，\\(r_p\\)和\\(r_q\\)为p和q的半径。 现在有若干个圆盘，半径从\\(1\\)到\\(n\\)，半径为\\(i\\)的圆盘有\\(i\\)个，每次操作可以移动一个圆盘，问把所有圆盘从A杆移动到C杆上最少需要几次操作。 由于最终答案可能很大，所以答案对\\(10^9+7\\)取模输出。 题解 汉诺塔升级版，对于汉诺塔而言，初始状态A柱上从上往下数第\\(i\\)个盘子共需要被移动\\(2^{n-i}\\)次；对于该问题而言，初始状态A柱上从上往下数第\\(i\\)个盘子共需要被移动\\(i * 2^{n-i}\\)次，用快速幂求解就行。 值得注意的是，快速幂中 x 要取 long long 才够用。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MOD 1000000007using namespace std;using ll = long long;ll fast_pow(int x, int y) &#123; long long ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = (ans * x) % MOD; &#125; x = ((x % MOD) * (x % MOD)) % MOD; y &gt;&gt;= 1; &#125; return ans % MOD;&#125;int main() &#123; int n; cin &gt;&gt; n; ll ans = 0; for (int r = 1; r &lt;= n; r++) &#123; ans = (ans + (r * fast_pow(2, n - r) % MOD)) % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法日常练习5","slug":"算法日常练习5","date":"2021-10-08T01:59:35.000Z","updated":"2022-10-17T03:02:12.030Z","comments":true,"path":"2021-10-08-算法日常练习5/","link":"","permalink":"http://example.com/2021-10-08-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A05/","excerpt":"2021年10月8日练习。","text":"2021年10月8日练习。 BJTU-ALGO 1002 记得我第一次用这个平台还是2020年的暑假小学期的时候，当时想按顺序做几道题，但是到这个题目就卡住了。思索很久也没有答案，正好最近在学动态规划，于是想着把这道题解出来。 ### 题目描述 在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：\\(0,1,\\dots,L\\)（其中\\(L\\)是桥的长度）。坐标为\\(0\\)的点表示桥的起点，坐标为\\(L\\)的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。 题目给出独木桥的长度\\(L\\)，青蛙跳跃的距离范围\\(S,T\\)，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。 对于30%的数据，\\(L \\leq 10000\\)； 对于全部的数据，\\(L \\leq 10^9\\)。 输入数据 输入共包括三行。 第一行有一个正整数\\(L(1≤L≤10^9)\\)， 表示独木桥的长度。 第二行有三个正整数\\(S,T,M\\)， 分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中\\(1≤S≤T≤10,1≤M≤100\\)。 第三行有\\(M\\)个不同的正整数分别表示这\\(M\\)个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。 输出数据 输出只包括一个整数，表示青蛙过河最少需要踩到的石子数。 样例输入 123102 3 52 3 5 6 7 样例输出 12 题目分析 阅读题目可知只要跳过\\(L\\)即可，记到达某一位置\\(i\\)所需踩的最少的石头数记作\\(\\text{dp}[i]\\)，其中\\(i \\in [0, L-1+T]\\)，当前到达当前位置所需的代价与之前\\(S\\)到\\(T\\)的位置有关。因此很容易写出状态转移方程\\(\\text{dp}[i]= \\min(\\text{dp}[i-j])\\)，其中\\(S \\leq i-j \\leq T\\)。再看题目中\\(L\\)的数据范围可知对于\\(70\\%\\)的数据需要进行空间的压缩。由\\(S\\)和\\(T\\)的范围，记\\(\\text{MOD}=\\text{lcm}(1,...,10)\\)，则\\(\\text{MOD}=2520\\)。之所以这样做的原因是要求出从任一位置\\(i\\)一定能前进的距离的最大值，也就是说可以任取\\(i\\)一定能从\\(i\\)跳至\\((i+\\text{MOD})\\)处。由此可以对距离进行压缩，压缩至大约\\(5 \\times 10^5\\)的范围内，可以使用动态规划。最终在区间\\([L,L+T-1]\\)的范围内找出最小值输出即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MOD 2520using namespace std;int main() &#123; int L; cin &gt;&gt; L; int S, T, M; cin &gt;&gt; S &gt;&gt; T &gt;&gt; M; vector&lt;int&gt; stones; for (int i = 0; i &lt; M; i++) &#123; int temp; cin &gt;&gt; temp; stones.emplace_back(temp); &#125; sort(stones.begin(), stones.end(), less&lt;int&gt;()); vector&lt;bool&gt; compressed(MOD * 107); vector&lt;int&gt; dis; for (int i = 1; i &lt; M; i++) &#123; dis.push_back((stones[i] - stones[i - 1]) % MOD); &#125; stones[0] = stones[0] % MOD; stones[0] += (stones[0] == 0 ? MOD : 0); compressed[stones[0]] = true; for (int i = 1; i &lt; M; i++) &#123; stones[i] = stones[i - 1] + dis[i - 1]; compressed[stones[i]] = true; &#125; L = stones[M - 1]; vector&lt;int&gt; dp(L + T + 1, 107); dp[0] = 0; for (int i = 1; i &lt;= L + T; i++) &#123; for (int j = S; j &lt;= T; j++) &#123; if (i - j &gt;= 0) &#123; dp[i] = min(dp[i - j], dp[i]) + (compressed[i] == true ? 1 : 0); &#125; &#125; &#125; int ans = 10e9; for (int i = L; i &lt; L + T; i++) &#123; ans = min(ans, dp[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法日常练习4","slug":"算法日常练习4","date":"2021-10-04T14:34:24.000Z","updated":"2022-10-17T03:08:00.341Z","comments":true,"path":"2021-10-04-算法日常练习4/","link":"","permalink":"http://example.com/2021-10-04-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A04/","excerpt":"2021年10月4日练习。","text":"2021年10月4日练习。 BJTU-ALGO 1355 火柴棒拼等式，经典的枚举问题。首先确定\\(1111+1=1112\\)共需要27根火柴，而题设说明\\(n\\leq24\\)，故枚举范围可知。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int costs[10] = &#123; 6,2,5,5,4,5,6,3,7,6 &#125;;int cost(int n) &#123; int c = 0; while (1) &#123; c += costs[n % 10]; n /= 10; if (n == 0) &#123; break; &#125; &#125; return c;&#125;int main() &#123; int n, ans = 0; cin &gt;&gt; n; if (n &gt;= 13) &#123; int avail_matches = n - 4;//可用来做数字的只有这些火柴 //至多20根 1111+1=1112 16+5=21 for (int i = 0; i &lt;= 1111; i++) &#123; for (int j = 0; j &lt;= 1111; j++) &#123; if (cost(i) + cost(j) + cost(i + j) == avail_matches) &#123; ans++; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 平台上写的是要求读写文件，实际上是用 cout 进行流输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;const int costs[10] = &#123; 6,2,5,5,4,5,6,3,7,6 &#125;;int cost(int n)&#123; int c = 0; while (1) &#123; c += costs[n % 10]; n /= 10; if (n == 0) &#123; break; &#125; &#125; return c;&#125;int main() &#123; int n, ans = 0; //read file fstream File; File.open(&quot;matches.in&quot;); if (!File) &#123; cout &lt;&lt; &quot;打开失败&quot; &lt;&lt; endl; exit(-1); &#125; File &gt;&gt; n; File.close(); if (n &gt;= 13) &#123; int avail_matches = n - 4;//可用来做数字的只有这些火柴 //至多20根 1111+1=1112 16+5=21 for (int i = 0; i &lt;= 1111; i++) &#123; for (int j = 0; j &lt;= 1111; j++) &#123; if (cost(i) + cost(j) + cost(i + j) == avail_matches) &#123; ans++; &#125; &#125; &#125; &#125; //write ans File.open(&quot;matches.out&quot;, ios::out); if (!File) &#123; cout &lt;&lt; &quot;打开失败&quot; &lt;&lt; endl; exit(-1); &#125; File &lt;&lt; ans; File.close(); return 0;&#125; LintCode 1316 主要是检索超时，经提示应该是需要使用单调栈解决问题，明日再解... 12345678910111213141516171819202122232425262728293031class Solution &#123;//超时public: /** * @param arr: the arr * @return: the sum of the luck number */ int luckNumber(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); int ans = 0; for (int i = 1; i &lt; n - 1; i++) &#123; int l_min = 40001, r_max = 0; bool l_find = false, r_find = false; for (int j = 0; j &lt;= i - 1; j++) &#123; if (arr[j] &gt; arr[i]) &#123; l_min = min(l_min, arr[j]); l_find = true; &#125; &#125; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[j] &lt; arr[i]) &#123; r_max = max(r_max, arr[j]); r_find = true; &#125; &#125; if (l_find &amp;&amp; r_find &amp;&amp; l_min % r_max == 0) &#123; ans++; &#125; &#125; return ans; &#125;&#125;; 和为\\(k\\) 排序后利用双指针就能解决问题，时间复杂度为\\(O(n\\log n)\\)。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, k, ans = 0; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; v(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i]; &#125; sort(v.begin(), v.end(), less&lt;int&gt;()); int i = 0, j = n - 1; while(i &lt; j)&#123; if (v[i] + v[j] == k) &#123; ans++; i++;//这个地方不好 20211007 j--; &#125; else if(v[i] + v[j] &lt; k) &#123; i++; &#125; else &#123; j--; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; BJTU-ALGO 1225 给定一个自然数\\(M\\)，求满足和恰为\\(M\\)的连续自然数的组数，要求从开始数排序从小到大依次输出起始数与最终数。实际上就是等差数列性质及分解因数。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;stack&gt;//vector可以使用emplace_back()方法代替push_back()方法using namespace std;int main() &#123; int M; cin &gt;&gt; M; stack&lt;pair&lt;int, int&gt;&gt; s; for (int i = 2; i * i &lt;= 2 * M; i++) &#123; if (2 * M % i == 0 &amp;&amp; ((M * 2 / i + i) % 2 == 1)) &#123;// s.push(pair&lt;int, int&gt;((2 * M / i - i + 1) / 2, (2 * M / i + i - 1) / 2)); &#125; &#125; while (!s.empty()) &#123; cout &lt;&lt; s.top().first &lt;&lt; &#x27; &#x27; &lt;&lt; s.top().second &lt;&lt; endl; s.pop(); &#125; return 0;&#125; 幸运数 定义幸运数为因数只有\\(3,5,7\\)的因数的正整数，输入一个正整数，求出小于这个数的幸运数个数。对数运算估计范围后暴力枚举+快速幂应该就可以解决。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;//有问题 20211007#include &lt;queue&gt;using namespace std;unsigned long long fast_pow(unsigned long long x, unsigned long long y) &#123;//快速幂，学学位运算 unsigned long long ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans *= x; &#125; x *= x; y &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; int ans = 0; //const unsigned long long lim = 1000000000000; unsigned long long lim; cin &gt;&gt; lim; for (int i = 0; i &lt;= 26; i++) &#123; for (int j = 0; j &lt;= 18; j++) &#123; for (int k = 0; k &lt;= 15; k++) &#123; if(fast_pow(3,i) * fast_pow(5, j) * fast_pow(7, k) &lt; lim)&#123; ans++; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"数论与组合数学学习笔记","slug":"数论与组合数学学习笔记","date":"2021-10-01T01:49:12.000Z","updated":"2023-01-19T11:33:47.721Z","comments":true,"path":"2021-10-01-数论与组合数学学习笔记/","link":"","permalink":"http://example.com/2021-10-01-%E6%95%B0%E8%AE%BA%E4%B8%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"整理学习数论和组合数学时的所思所想。","text":"整理学习数论和组合数学时的所思所想。 数论入门 求最大公约数与最小公倍数 求最大公约数的最朴素的想法就是暴力枚举。 12345678910int gcd1(int a, int b) &#123;//假定输入的a，b都是正数 int ans = 1; int _max = max(a, b), _min = a + b - _max; for (int i = 2; i &lt;= _min; i++) &#123; if (_max % i == 0 &amp;&amp; _min % i == 0) &#123; ans = i; &#125; &#125; return ans;&#125; 此外，还可以使用辗转相除法，其原理为\\(\\text{gcd}(a, b)=\\text{gcd}(b, a \\mod b)\\)。证明如下： 设\\(a=kb+r\\)，其中\\(a, b, k, r\\in Z，r=a \\mod b\\)。 另设\\(d\\)为\\(a\\)与\\(b\\)的一个公约数，由\\(a=kb+r\\)有：\\(r=a-kb\\)，等式两边同除\\(d\\)得：\\(\\displaystyle \\frac{r}{d}=\\frac{a}{r}-\\frac{kb}{d}\\)，显然式中任意一项都是整数，则\\(r\\)也是\\(a\\mod(b)\\)的因子。 事实上还有\\(\\text{gcd}(a,b)=\\text{gcd}(b,a)\\)，这一性质可以用于算法正确性的证明。 12345678910111213int gcd2(int a, int b) &#123; return a % b == 0 ? b : gcd2(b, a % b);&#125;int gcd3(int a, int b) &#123; int r = a; while (r != 0) &#123; r = a % b;//取余数 a = b;//大数更新为小数 b = r;//小数更新为余数 &#125; return a;&#125; 实际上，更相减损法与辗转相除法实质是一样的，而且前者所需的计算次数通常更多。更相减损法的原理是\\(\\text{gcd}(a,b)=\\text{gcd}(\\min(a,b),\\max(a,b)-\\min(a,b))\\)。 123456789101112131415161718192021222324252627282930313233343536int gcd4(int a, int b) &#123; if (a == b) &#123; return a; &#125; if (a &gt; b) &#123; return gcd4(b, a - b); &#125; else&#123; return gcd4(a, b - a); &#125;&#125;int gcd5(int a, int b) &#123; if (a == b) &#123; return a; &#125; int _max = max(a, b), _min = a + b - _max; while(_max != _min)&#123; int tmp1 = _max - _min, tmp2 = _min; _max = max(tmp1, tmp2); _min = tmp1 + tmp2 - _max; &#125; return _min;&#125;int gcd6(int a, int b) &#123; while(a!=b)&#123; if (a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return a;&#125; 显然，更相减损法是需要考虑两个数之间的大小的，而辗转相除法不需要。 事实上，求最小公倍数可以使用分解质因数法，也可以利用最小公倍数与最大公约数之间的关系求解。 12345678910111213141516171819202122232425262728293031323334353637bool is_prime(int n)&#123; if (n == 2) &#123; return true; &#125; if (n % 2 == 0 || n &lt; 2) &#123; return false; &#125; for (int i = 3; i * i &lt;= n; i += 2) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125;int lcm1(int a, int b) &#123; int _max = max(a, b); int _lcm = 1; for (int i = 2; i &lt;= _max; i++) &#123; if (is_prime(i)) &#123; while (a % i == 0 &amp;&amp; b % i == 0) &#123; _lcm *= i; a /= i; b /= i; &#125; while (a % i == 0)&#123; _lcm *= i; a /= i; &#125; while (b % i == 0) &#123; _lcm *= i; b /= i; &#125; &#125; &#125; return _lcm;&#125; 还可以利用最大公约数求解，具体原理详见算法分析与设计第二次题解中F题的分析。 123int lcm2(int a, int b)&#123; return a * b / gcd1(a, b);&#125; 求一个正整数的因数个数 由算术基本定理可知：每个正整数的标准分解式都是唯一的。考虑任意一个正整数\\(n\\)，记\\(n=\\displaystyle\\prod_i{p_i^{\\alpha_i}}\\)，那么\\(n\\)的因数的形式必定为\\(n=\\displaystyle\\prod_i{p_i^{\\beta_i}}\\)，其中，有\\(0\\leq\\beta_i\\leq\\alpha_i\\)。每一个质因数\\(p_i\\)的次数\\(\\beta_i\\)可取\\(0\\)到\\(\\alpha_i\\)，即共有\\((\\alpha_i+1)\\)种取法，因此总的因数个数\\(d(n)\\)为\\(d(n)=\\displaystyle\\prod_i({\\alpha_i + 1})\\)。 求 Euler 函数的值 组合数学 组合数与排列数 从\\(n\\)个不同元素中取出\\(m\\)个元素并排序，方案数为\\(\\displaystyle \\prod_{i=n-m+1}^{n}i =\\frac{n!}{(n-m)!} = \\text{A}_{n}^{m}\\)，其中\\(\\text{A}_{n}^{m}\\)被称为排列数，也被记为\\(\\text{P}_{n}^{m}\\)。 从\\(n\\)个不同元素中取出\\(m\\)个元素，两个方案视为不同当且仅当包含的元素不同，即与元素顺序无关时，方案数为\\(\\displaystyle\\frac{A_{n}^{m}}{m!}=\\frac{n!}{m!(n-m)!}=\\text{C}_{n}^{m}\\)。 从\\(n\\)个不同元素中取\\(m\\)个元素并排列在圆周上，其方案数显然是\\(\\displaystyle \\frac{\\text{P}_{n}^{m}}{m} = \\text{Q}_n^m\\)，其中\\(\\text{Q}_n^m\\)被称为圆排列数。 常见的组合数公式以及其组合意义上的证明 考虑从\\(n\\)个不同元素中取\\(m\\)个，其方案数显然是\\(\\text{C}_n^m\\)；此外，不妨以是否取其中某个特定元素为标准进行分类讨论，取之的方案数的\\(\\text{C}_{n-1}^{m-1}\\)，不取的方案数为\\(\\text{C}_{n-1}^{m}\\)，那么可以得到下面的公式。 \\[\\text{C}_{n}^{m}=\\text{C}_{n-1}^{m-1}+\\text{C}_{n-1}^{m} \\tag{1}\\] 事实上，公式\\((1)\\)可以进行推广。考虑从\\(n+m\\)个不同的元素中取\\(r\\)个，其方案数显然是\\(\\text{C}_{n+m}^r\\)；从另外一个思路考虑，可以从\\(n\\)个元素和\\(m\\)个元素两堆中共取\\(r\\)个元素，根据加法原理和乘法原理总的方案数就是\\(\\displaystyle \\sum_{i=0}^{r}\\text{C}_{n}^{r-i} \\text{C}_{m}^{i}\\)，即： \\[\\text{C}_{n+m}^{r} = \\displaystyle \\sum_{i=0}^{r}\\text{C}_{n}^{r-i} \\text{C}_{m}^{i} \\tag{2}\\] 据此，公式\\((1)\\)还可以写作\\(\\text{C}_{n}^{m}=\\text{C}_{1}^{0}\\text{C}_{n-1}^{m}+\\text{C}_{1}^{1}\\text{C}_{n-1}^{m-1}\\)。 允许重复的组合和不相邻的组合 允许重复的组合 不相邻的组合 组合数与排列数 从\\(n\\)个不同元素中取出\\(m\\)个元素并排序，方案数为\\(\\displaystyle \\prod_{i=n-m+1}^{n}i =\\frac{n!}{(n-m)!} = \\text{A}_{n}^{m}\\)，其中\\(\\text{A}_{n}^{m}\\)被称为排列数，也被记为\\(\\text{P}_{n}^{m}\\)。 从\\(n\\)个不同元素中取出\\(m\\)个元素，两个方案视为不同当且仅当包含的元素不同，即与元素顺序无关时，方案数为\\(\\displaystyle\\frac{A_{n}^{m}}{m!}=\\frac{n!}{m!(n-m)!}=\\text{C}_{n}^{m}\\)。 从\\(n\\)个不同元素中取\\(m\\)个元素并排列在圆周上，其方案数显然是\\(\\displaystyle \\frac{\\text{P}_{n}^{m}}{m} = \\text{Q}_n^m\\)，其中\\(\\text{Q}_n^m\\)被称为圆排列数。 常见的组合数公式以及其组合意义上的证明 考虑从\\(n\\)个不同元素中取\\(m\\)个，其方案数显然是\\(\\text{C}_n^m\\)；此外，不妨以是否取其中某个特定元素为标准进行分类讨论，取之的方案数的\\(\\text{C}_{n-1}^{m-1}\\)，不取的方案数为\\(\\text{C}_{n-1}^{m}\\)，那么可以得到下面的公式。 \\[\\text{C}_{n}^{m}=\\text{C}_{n-1}^{m-1}+\\text{C}_{n-1}^{m} \\tag{1}\\] 事实上，公式\\((1)\\)可以进行推广。考虑从\\(n+m\\)个不同的元素中取\\(r\\)个，其方案数显然是\\(\\text{C}_{n+m}^r\\)；从另外一个思路考虑，可以从\\(n\\)个元素和\\(m\\)个元素两堆中共取\\(r\\)个元素，根据加法原理和乘法原理总的方案数就是\\(\\displaystyle \\sum_{i=0}^{r}\\text{C}_{n}^{r-i} \\text{C}_{m}^{i}\\)，即： \\[\\text{C}_{n+m}^{r} = \\displaystyle \\sum_{i=0}^{r}\\text{C}_{n}^{r-i} \\text{C}_{m}^{i} \\tag{2}\\] 据此，公式\\((1)\\)还可以写作\\(\\text{C}_{n}^{m}=\\text{C}_{1}^{0}\\text{C}_{n-1}^{m}+\\text{C}_{1}^{1}\\text{C}_{n-1}^{m-1}\\)。 允许重复的组合和不相邻的组合 允许重复的组合 不相邻的组合 参考资料 《组合数学》第5版，清华大学出版社，卢开澄、卢华明著","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"算法分析与设计第二次作业题题解","slug":"算法分析与设计第二次作业题题解","date":"2021-09-30T08:59:02.000Z","updated":"2022-10-17T03:49:39.189Z","comments":true,"path":"2021-09-30-算法分析与设计第二次作业题题解/","link":"","permalink":"http://example.com/2021-09-30-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"题目发布于2021年9月30日上午十点。","text":"题目发布于2021年9月30日上午十点。 Problem A 题目描述 如果一个质数能被表示为三个不同的质数的和的形式，那么我们称它为立方质数。 现在给你一个数\\(n(n \\leq 1000)\\)，判断它是不是立方质数。 题解 观察\\(n\\)的范围，直接暴力枚举即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;bool is_prime(int n) &#123; if (!(n % 2)) &#123; return false; &#125; if (n == 1) &#123; return false; &#125; for (int i = 3; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; vector&lt;int&gt; primeList; int n; cin &gt;&gt; n; if (!is_prime(n)) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; &#125; for (int i = 2; i &lt;= n; i++) &#123; if (is_prime(i)) &#123; primeList.push_back(i); &#125; &#125; int l = primeList.size(); for (int i = 0; i &lt; l; i++) &#123; for (int j = i + 1; j &lt; l; j++) &#123; for (int k = j + 1; k &lt; l; k++) &#123; if (n == primeList[i] + primeList[j] + primeList[k]) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0;&#125; Problem B 题目描述 有\\(n\\)盏灯，编号为\\(1,2,\\dots,n\\)，初始灯都是关着的。有\\(n\\)个人，第\\(i\\)个人会打开所有编号为\\(i\\)的倍数的灯，那么最后有几盏灯是亮着的？ 题解 实际上，仔细读题发现，最后只有被按了奇数次的灯会亮着，也就是说，本题是求在区间\\([1, n]\\)中的整数\\(i\\)满足条件当且仅当\\(i\\)恰好有奇数个不同的因数。大于\\(1\\)的任意一个正整数的因数都是成对出现的，除非这个数是完全平方数。说到底，这个题就是要求\\([1, n]\\)中有多少个完全平方数。直接返回\\(\\lfloor \\sqrt{n} \\rfloor\\)即可。 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int i; for(i = 1; i * i &lt;= n; i++)&#123;&#125; cout &lt;&lt; i - 1 &lt;&lt; endl; return 0;&#125; Problem C 题目描述 小明刚买了一个机械键盘，但他在用机械键盘打字的时候发现键盘的Home键和End键坏掉了，于是他在打字的时候光标有时会突然跑到行首，有时又会突然跑到行尾，现在给你键盘的输入，求最后屏幕上的字符串。 题解 实际上需要费脑筋的是输入多个home的情况。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt; #define FRONT true#define BACK falseusing namespace std;int main() &#123; string s, fr, ans; cin &gt;&gt; s; bool mode = BACK; for (auto c : s) &#123; if (c == &#x27;[&#x27;) &#123; mode = FRONT; ans = fr + ans; fr.clear(); &#125; else if (c == &#x27;]&#x27;) &#123; mode = BACK; &#125; else &#123; if (mode == BACK) &#123; ans.push_back(c); &#125; else &#123; fr.push_back(c); &#125; &#125; &#125; ans = fr + ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem D 题目描述 对于数\\(7331\\)而言，\\(7,73,733,7331\\)都是质数，因此\\(7331\\)被称作长度为\\(4\\)的特殊质数。 输入为\\(N(1 \\leq N \\leq 8)\\)，求出所有长度为\\(N\\)的特殊质数。 题解 实际上可以使用宽搜求解。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;queue&gt;int main() &#123; int N; cin &gt;&gt; N; queue&lt;int&gt; ans(&#123;2, 3, 5, 7&#125;); int lastCount = 4; int curCount = 0; for (int i = 2; i &lt;= N; i++) &#123; curCount = 0; for (int j = 1; j &lt;= lastCount; j++) &#123; int cur = ans.front(); ans.pop(); cur *= 10; for (int k = 1; k &lt;= 9; k += 2) &#123; if (is_prime(cur + k)) &#123; ans.push(cur + k); curCount++; &#125; &#125; &#125; lastCount = curCount; &#125; while(!ans.empty()) &#123; cout &lt;&lt; ans.front() &lt;&lt; endl; ans.pop(); &#125; return 0;&#125; Problem E 题目描述 输入一个\\(32\\)位无符号整数，输出其高\\(16\\)位与低\\(16\\)位交换后的结果。 题解 12345678910#include &lt;iostream&gt;#define base 65536 //2^16using namespace std;int main()&#123; size_t n; cin &gt;&gt; n; size_t low = n / base, high = n % base; cout &lt;&lt; high * base + low &lt;&lt; endl; return 0;&#125; Problem F 题目描述 输入两个正整数\\(x_0,y_0(2≤x_0≤100000，2≤y_0≤1000000)\\)，求出满足下列条件的\\(P,Q\\)的个数： （1）\\(P,Q\\)都是正整数； （2）要求\\(P,Q\\)以\\(x_0\\)为最大公约数，以\\(y_0\\)为最小公倍数。 试求满足条件的所有可能的两个正整数的个数。 题解 设\\(P=k_1x_0, Q=k_2x_0（k_1与k_2互质）\\), 则依题意\\(k_1k_2x_0=y_0\\)，也就是说\\(k_1k_2=\\displaystyle \\frac{y_0}{x_0}\\)。若\\(x_0\\)不能整除\\(y_0\\)，则满足要求的个数为0；否则只要统计\\(\\displaystyle \\frac{y_0}{x_0}\\)的互质因数的组数即可（也就是所有的非平方根因数的个数）。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int gcd(int a, int b) &#123; return a % b == 0 ? b : gcd(b, a % b);&#125;int main() &#123; int x0, y0; cin &gt;&gt; x0 &gt;&gt; y0; if (y0 % x0) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; int p = y0 / x0; int ans = 0; for (int i = 1; i * i &lt; p; i++) &#123; if (p % i == 0 &amp;&amp; gcd(i, p / i) == 1) &#123; ans += 2; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"网站建设与维护纪实","slug":"网站建设与维护纪实","date":"2021-09-28T11:49:50.000Z","updated":"2022-10-20T04:24:15.616Z","comments":true,"path":"2021-09-28-网站建设与维护纪实/","link":"","permalink":"http://example.com/2021-09-28-%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E4%B8%8E%E7%BB%B4%E6%8A%A4%E7%BA%AA%E5%AE%9E/","excerpt":"本页主要记录网页的建设与维护的过程，并分享一些经验。","text":"本页主要记录网页的建设与维护的过程，并分享一些经验。 2021年9月28日 网页出现乱码问题，经查证是编码问题，查找资料后在对 WinSCP 的登陆设置与登陆后的编辑设置中进行修改后问题解决。 要使用 Markdown 进行公式编辑就需要在每篇博客的头部加上如下代码。 1mathjax: true 最终得到的效果为：\\(e^{i\\pi}+1=0\\)。 以上内容为 Volantis-4.3.1 中的配置方式，事实上，在 Volantis-5.7.6 中，配置方式如下。 12plugins: - mathjax 2021年9月29日 经大佬的提示，我将网站中的图片进行压缩，转为 webp 格式。 2021年11月9日 经过查找资料后，我将网站的代码字体更换为 Fira Code，实际上流程很简单。 在腾讯云服务器的 Ubuntu 系统中使用如下命令安装 Fira Code 字体。 1sudo apt install fonts-firacode 随后修改 _config.volantis.yml 中的 codefont 之后即可使用字体，如下所示。 1234567891011121314# file: _config.volantis.yml# ... fontfamily: codefont: fontfamily: &#x27;Fira Code&#x27; logofont: fontfamily: &#x27;&quot;Times New Roman&quot;, SimSun&#x27; weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;Times New Roman&quot;, SimSun&#x27; weight: normal style: normal# ... 2022年10月19日 观察到博客翻页功能的内容不够美观，于是将 article.ejs 中部分行进行了注释。 123456789&lt;!-- file: blog-root-path/themes/volantis/layout/_partial/article.ejs --&gt; &lt;!-- ... --&gt; &lt;-- line: 154, 160 --&gt; &lt;!--&lt;p class=&#x27;content&#x27;&gt;&lt;%- prev.exp %&gt;&lt;/p&gt;--&gt; &lt;!-- ... --&gt; &lt;-- line: 173, 179 --&gt; &lt;!--&lt;p class=&#x27;content&#x27;&gt; &lt;%- truncate(strip_html(page.prev.content), &#123;length: 100&#125;) %&gt;&lt;/p&gt;--&gt; &lt;!-- ... --&gt;","categories":[{"name":"网站相关","slug":"网站相关","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"算法日常练习3","slug":"算法日常练习3","date":"2021-09-28T11:49:13.000Z","updated":"2022-10-17T03:22:19.186Z","comments":true,"path":"2021-09-28-算法日常练习3/","link":"","permalink":"http://example.com/2021-09-28-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A03/","excerpt":"2021年9月28日练习。","text":"2021年9月28日练习。 LintCode 1300 事实上，当\\(n \\leq 3\\)时，总是能赢；\\(n \\geq 4\\)时，只要\\(n\\)是4的倍数一定输，其他情况我一定赢，因此只要返回 (n%4!=0) 即可。 1234567891011class Solution &#123;public: /** * @param n: an integer * @return: whether you can win the game given the number of stones in the heap */ bool canWinBash(int n) &#123; return (n%4!=0);//在c++中自动将非零的数转换为true &#125;&#125;; LintCode 1609 快慢指针基本题目。 123456789101112131415161718192021222324252627282930313233/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param head: the head node * @return: the middle node */ ListNode * middleNode(ListNode * head) &#123; if(!head || !head-&gt;next)&#123; return head; &#125; else&#123; ListNode* f=head,*s=head; while(f&amp;&amp;f-&gt;next)&#123; f = f-&gt;next-&gt;next; s=s-&gt;next; &#125; return s; &#125; &#125;&#125;; 北京北站的故事 题目描述 北京北站现有\\(n\\)节车厢从A方向驶入，并按进站顺序依次编号，站长要求这些车厢按照指定的顺序从B 向使出。Qingyong从《交通运输概论》课程学习到，完成站长的任务需要借助中转站（记为C方向）。假设C可以停放任意数量的车厢，但是C末端封闭，因此，驶入C站的车厢必须按照相反的顺序驶出。Qingyong进一步限定允许的操作如下： 让A方向最前面的车厢从B方向驶出车站； 让A方向最前面的车厢驶入中转站C； 让中转站 C 中最后驶入的车厢从 B 方向驶出车站。 请帮助Qingyong判断能否让车厢按照站长给定的顺序驶出北京北站。 输入数据 输入共包括两行。 第一行为一个正整数\\(n\\)，代表车厢总数，\\(n &lt; 100000\\)。 第二行有\\(n\\)个正整数，代表站长要求的车厢驶出车站顺序。 输出数据 Yes 或者 No。 样例输入 1254 5 3 2 1 样例输出 1Yes 实际上这个题目考察如何用栈调整队列中元素的顺序。 设置两个变量 in_num 与 out_num 分别代表当前处于队首的车辆编号以及当前需要出队的车辆编号： 当 in_num == out_num 时， in_num++； 当 in_num &gt; out_num 时，需要将所有在\\([\\text{in_num} &gt; \\text{out_num - 1}]\\)区间范围内的车辆编号全部入栈，然后更新 in_num 为 out_num + 1； 否则，需要在栈中取栈顶元素，若栈非空且栈顶元素等于 out_num ，则将栈顶元素出栈；否则不能满足要求。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; stack&lt;int&gt; s; int in_num = 1, out_num; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; out_num; if (in_num == out_num) &#123; in_num++; &#125; else if(out_num &gt; in_num)&#123; for(int j = in_num; j &lt; out_num; j++)&#123; s.push(j); &#125; in_num = out_num + 1; &#125; else &#123; if (!s.empty() &amp;&amp; s.top() == out_num) &#123; s.pop(); &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0;&#125; 割绳子 题目描述 现有\\(N\\)条绳子，它们的长度分别为\\(L_1,L_2,\\dots,L_n\\)，如果从它们中切割出\\(K\\)条长度相同的绳子，问这\\(K\\)条绳子每条最长能有多长？ 输入格式 输入共有两行。 第一行包含两个正整数\\(N\\)和\\(K\\)，用一个空格分隔。 第二行包含\\(N\\)个数，依次表示\\(N\\)条绳子的长度，两数间用一个空格分隔。每条绳子长度的小数不超过两位。 题目数据满足\\(1 \\leq N \\leq 1000,1 \\leq K \\leq 1000，1 \\leq L_i \\leq 10000\\)。 输出格式 仅包含一个数，表示所得\\(K\\)断绳子的最大长度，输出四舍五入保留小数点后两位。 题目分析 注意精度问题和搜索效率即可，使用二分查找就可以解决本题目。 123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool valid(vector&lt;int&gt;&amp;length, int mid, int k) &#123; for (int i = 0; i &lt; length.size(); i++) &#123; k -= length[i] / mid; &#125; return k &lt;= 0;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; length(n); int max_len = 0; for (int i = 0; i &lt; n; i++) &#123; double temp; cin &gt;&gt; temp; length[i] = temp * 100; max_len = max(max_len, length[i]); &#125; int l = 1, r = max_len; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (valid(length, mid, k)) &#123; ans = max(mid, ans); l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans / 100.0 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法日常练习2","slug":"算法日常练习2","date":"2021-09-27T01:12:10.000Z","updated":"2022-10-17T03:27:50.169Z","comments":true,"path":"2021-09-27-算法日常练习2/","link":"","permalink":"http://example.com/2021-09-27-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A02/","excerpt":"2021年9月27日练习。","text":"2021年9月27日练习。 LintCode 167 注意进位的问题，最后一步如果有进位需要多加一个结点，实质上考察了对有进位加法的步骤的考察。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param l1: the first list * @param l2: the second list * @return: the sum list of l1 and l2 */ ListNode * addLists(ListNode * l1, ListNode * l2) &#123; ListNode* traverse1 = l1, *traverse2 = l2; ListNode* ans = new ListNode(), *tail = ans; int c = 0; while(l1 &amp;&amp; l2)&#123; int cur = l1-&gt;val + l2-&gt;val + c; ListNode* tmp = new ListNode(cur % 10); c = cur / 10; tail-&gt;next = tmp; tail = tmp; l1=l1-&gt;next; l2=l2-&gt;next; &#125; while(l1)&#123; int cur = l1-&gt;val + c; ListNode* tmp = new ListNode(cur % 10); c = cur / 10; tail-&gt;next = tmp; tail = tmp; l1=l1-&gt;next; &#125; while(l2)&#123; int cur = l2-&gt;val + c; ListNode* tmp = new ListNode(cur % 10); c = cur / 10; tail-&gt;next = tmp; tail = tmp; l2=l2-&gt;next; &#125; if(c)&#123; ListNode* tmp = new ListNode(c); tail-&gt;next = tmp; tail = tmp; &#125; ListNode* del = ans; ans = ans-&gt;next; delete del; return ans; &#125;&#125;; LintCode 669 1234567891011121314151617181920212223242526class Solution &#123;public: /** * @param coins: a list of integer * @param amount: a total amount of money amount * @return: the fewest number of coins that you need to make up */ int coinChange(vector&lt;int&gt; &amp;coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, 200000000); dp[0] = 0; for(int i = 1; i &lt;= amount;i++)&#123; //求min for(int j = 0; j &lt;= coins.size(); j++)&#123; if(i - coins[j] &gt;= 0 &amp;&amp; dp[i-coins[j]] != 200000000 &amp;&amp; dp[i-coins[j]] + 1 &lt; dp[i])&#123; dp[i] = dp[i - coins[j]] + 1; &#125; &#125; &#125; if(dp[amount] &gt;= 200000000)&#123; return -1; &#125; else&#123; return dp[amount]; &#125; &#125;&#125;; LintCode 114 12345678910111213141516171819202122class Solution &#123;public: /** * @param m: positive integer (1 &lt;= m &lt;= 100) * @param n: positive integer (1 &lt;= n &lt;= 100) * @return: An integer */ int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 || j == 0)&#123; dp[i][j] = 1; &#125; else&#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; LintCode 116 1234567891011121314151617181920class Solution &#123;public: /** * @param A: A list of integers * @return: A boolean */ bool canJump(vector&lt;int&gt; &amp;A) &#123; int n = A.size(); vector&lt;bool&gt; dp(n, false); dp[0] = true; for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(dp[j] &amp;&amp; j + A[j] &gt;= i)&#123; dp[i] = true; &#125; &#125; &#125; return dp[n - 1]; &#125;&#125;; LintCode 115 本题需要注意边界条件。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: /** * @param obstacleGrid: A list of lists of integers * @return: An integer */ int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt; &amp;obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1])&#123; return 0; &#125; else&#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(obstacleGrid[i][j])&#123; continue; &#125; else&#123; if(i == 0 &amp;&amp; j == 0)&#123; dp[i][j] = 1; &#125; else&#123; if(i &gt;= 1)&#123; dp[i][j] += dp[i - 1][j]; &#125; if(j &gt;= 1)&#123; dp[i][j] += dp[i][j - 1]; &#125; &#125; &#125; &#125; &#125; return dp[m-1][n-1]; &#125; &#125;&#125;; LintCode 515 123456789101112131415161718192021222324252627class Solution &#123;public: /** * @param costs: n x 3 cost matrix * @return: An integer, the minimum cost to paint all houses */ int minCost(vector&lt;vector&lt;int&gt;&gt; &amp;costs) &#123; int n = costs.size(); if(n == 0)&#123; return 0; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(3, 0)); for(int i = 0; i &lt;n; i++)&#123; if(!i)&#123; dp[i][0]=costs[i][0]; dp[i][1]=costs[i][1]; dp[i][2]=costs[i][2]; &#125; else&#123; dp[i][0] = min(costs[i][0] + dp[i-1][1], costs[i][0]+dp[i-1][2]); dp[i][1] = min(costs[i][1] + dp[i-1][2], costs[i][1]+dp[i-1][0]); dp[i][2] = min(costs[i][2] + dp[i-1][0], costs[i][2]+dp[i-1][1]); &#125; &#125; return min(dp[n-1][0],min(dp[n-1][1],dp[n-1][2])); &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法日常练习1","slug":"算法日常练习1","date":"2021-09-26T08:00:18.000Z","updated":"2022-10-17T03:27:53.616Z","comments":true,"path":"2021-09-26-算法日常练习1/","link":"","permalink":"http://example.com/2021-09-26-%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A01/","excerpt":"2021年9月26日练习。","text":"2021年9月26日练习。 LintCode 1270 实际上就是判断组成字符串 ransomNote 字符集合是否是组成字符串 magazine 字符集合的子集。 C++ 中可以使用 includes() 函数进行操作，但是注意需要对元素进行降序排序。 1234567891011121314class Solution &#123;public: /** * @param ransomNote: a string * @param magazine: a string * @return: whether the ransom note can be constructed from the magazines */ bool canConstruct(string &amp;ransomNote, string &amp;magazine) &#123; string s1 = ransomNote, s2 = magazine; sort(s1.begin(), s1.end(), less&lt;char&gt;()); sort(s2.begin(), s2.end(), less&lt;char&gt;()); return includes(s2.begin(), s2.end(), s1.begin(), s1.end()); &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法分析与设计第一次作业题题解","slug":"算法分析与设计第一次作业题题解","date":"2021-09-23T13:40:26.000Z","updated":"2022-10-20T05:12:24.210Z","comments":true,"path":"2021-09-23-算法分析与设计第一次作业题题解/","link":"","permalink":"http://example.com/2021-09-23-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"题目发布于2021年9月23日上午十点。","text":"题目发布于2021年9月23日上午十点。 Problem A 有形如\\(ax^3+bx^2+cx+d=0\\)这样的一个一元三次方程。给出该方程中各项的系数（\\(a,bc,d\\)均为实数），并约定该方程存在三个不同实根（根的范围为\\([-100,100]\\)），且根与根之差的绝对值不小于\\(1\\)。要求由小到大依次在同一行输出这三个实根（根与根之间留有空格），并精确到小数点后\\(2\\)位。 输入数据 输入该方程中各项的系数（\\(a,b,c,d\\)均为浮点数）。 输出数据 由小到大依次在同一行输出这三个实根（根与根之间留有空格），并精确到小数点后\\(2\\)位。 样例输入 11 -5 -4 20 样例输出 1-2.00 2.00 5.00 题解 二分法的题目。由于该一元三次方程必有三个实根，记\\(f(x)=ax^3+bx^2+cx+d\\)，则\\(f&#39;(x)\\)必有两个相异实根\\(x_1\\)与\\(x_2\\)，不妨记\\(x_1 &lt; x_2\\)，由三次函数的性质及题设可知：三个实根分别在\\((-100, x1),(x1, x2),(x2, 100)\\)三个区间内。 对三个区间运用二分法即可。注意输出时候要设置格式。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;double a, b, c, d;double f(double x) &#123; return (a * x * x * x + b * x * x + c * x + d);&#125;double find_solution(double start, double end) &#123; if (end - start &lt; 0.01) &#123; return (start + end) / 2; &#125; else &#123; double fl = f(start); double fm = f((start + end) / 2.0); if (fl * fm &lt; 0) &#123; return find_solution(start, (start + end) / 2.0 - 0.0001); &#125; else&#123; return find_solution((start + end) / 2.0 + 0.0001, end); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; double seg1 = -100, seg4 = 100; double seg2 = min((-b + sqrt(b * b - 3 * a * c)) / (3 * a), (-b - sqrt(b * b - 3 * a * c)) / (3 * a)); double seg3 = max((-b + sqrt(b * b - 3 * a * c)) / (3 * a), (-b - sqrt(b * b - 3 * a * c)) / (3 * a)); //cout &lt;&lt; seg2 &lt;&lt; &#x27; &#x27; &lt;&lt; seg3 &lt;&lt; endl; double x1, x2, x3; x1 = find_solution(seg1, seg2); x2 = find_solution(seg2, seg3); x3 = find_solution(seg3, seg4); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; x1 &lt;&lt; &#x27; &#x27; &lt;&lt; x2 &lt;&lt; &#x27; &#x27; &lt;&lt; x3 &lt;&lt; endl; return 0;&#125; Problem B 0-1背包问题的裸题。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int N, t; cin &gt;&gt; N &gt;&gt; t; vector&lt;int&gt; w, v; w.push_back(0); v.push_back(0); for(int i = 0; i &lt; N; i++)&#123; int like, cost; cin &gt;&gt; like &gt;&gt; cost; v.push_back(like); w.push_back(cost); &#125; vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(t + 1, 0)); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= t; j++) &#123; if (j &lt; w[i]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125; cout &lt;&lt; dp[N][t] &lt;&lt; endl; return 0;&#125; Problem C 暴力枚举。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 101;int arr[N];bool valid(int a, int b, int c) &#123; return a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a;&#125;int main() &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; int ans = -1; for(int i = 0; i &lt; n; i++) &#123; for(int j = i + 1; j &lt; n; j++) &#123; for(int k = j + 1; k &lt; n; k++) &#123; if(valid(arr[i], arr[j], arr[k])) &#123; ans = max(ans, arr[i] + arr[j] + arr[k]); &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem D 题目描述 在一个被分成\\(n \\times n\\)个格子的平原上，有一些格子有铁矿，两格铁矿如果相邻那么就认为他们属于同一个矿床，每个矿床都包含一个或更多个铁矿，问一共有几个矿床。两个格子只要有公共边或公共点就算相邻。 输入数据 输入包括\\(n+1\\)行。 第一行为一个正整数\\(n(n \\leq 1000)\\)。 接下来有\\(n\\)行，每行有\\(n\\)个字符，# 表示平原的对应位置有铁矿，* 代表没有。 输出数据 矿床个数。 样例输入 12345676*#*######*#**##****#*******###****** 样例输出 12 题解 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int totalCount = 0;const int dx[8] = &#123; 0, 0, -1, 1, 1, -1, 1, -1 &#125;, dy[8] = &#123;1, -1, 0, 0, 1, 1, -1, -1&#125;;void traverseMap(vector&lt;string&gt;&amp; field, int row, int col) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= field.size() || col &gt;= field.size() || field[row][col] == &#x27;*&#x27;) &#123; return; &#125; field[row][col] = &#x27;*&#x27;; for (int i = 0; i &lt; 8; i++) &#123; traverseMap(field, row + dx[i], col + dy[i]); &#125;&#125;void mineCount(vector&lt;string&gt;&amp; field) &#123; for (int i = 0; i &lt; field.size(); i++) &#123; for (int j = 0; j &lt; field.size(); j++) &#123; if (field[i][j] == &#x27;#&#x27;) &#123; totalCount++; traverseMap(field, i, j); &#125; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; if (n &gt; 0) &#123; vector&lt;string&gt; field(n); for (auto&amp; str : field) cin &gt;&gt; str; mineCount(field); &#125; cout &lt;&lt; totalCount &lt;&lt; endl; return 0;&#125; Problem E 优先队列裸题。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;priority_queue&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int N; cin &gt;&gt; N; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Q; for (int i = 0; i &lt; N; i++) &#123; int temp; cin &gt;&gt; temp; Q.push(temp); &#125; int ans = 0; for (int i = 0; i &lt; N - 1; i++) &#123; int tempSum = Q.top(); Q.pop(); tempSum += Q.top(); Q.pop(); Q.push(tempSum); ans += tempSum; &#125; cout &lt;&lt; ans &lt;&lt; endl; //priority_queue greater huffman 每次出堆的都是最小的元素 小顶堆 //想使得最小元素有最高优先级 //大顶堆出堆是最小元素与堆顶元素交换 交换后调整堆 每次出堆的都是当前最大的元素 //大顶堆 a[0]最大 //小顶堆 a[0]最小 //结论：priority_queue与vector排序方式一样 greater降序 less升序 逻辑上都是一样的 但是要看针对不同数据类型理解降序与升序 //vector的迭代顺序为0-&gt;vector.size()-1，优先队列不支持迭代 //记一下 //堆greater是小顶堆 return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"枚举算法学习","slug":"枚举算法学习","date":"2021-09-23T13:23:58.000Z","updated":"2022-10-20T05:08:02.012Z","comments":true,"path":"2021-09-23-枚举算法学习/","link":"","permalink":"http://example.com/2021-09-23-%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"枚举算法是最朴素的算法之一。","text":"枚举算法是最朴素的算法之一。 枚举算法也称之为穷举算法，就是按照问题本身的性质，一一列举出该问题所有可能的解，并在列举的过程中，逐一检验每个可能解是否是问题的真正解。若是则采纳这个解；否则抛弃它。 其中很重要的两点是不重、不漏，注意枚举算法是计算机可求解问题的本质方法，其特点为全面且实现简单，效率则相对较低，效率提升空间大。 例题 设\\(S\\)为由所有正整数按从小到大的顺序组成的序列，即\\(S=1234567891011 \\dots\\)，记\\(S\\)中第一次出现\\(1\\)为位置\\(1\\)，求S的第\\(n\\)位。 123456789101112131415161718192021222324252627282930int f(int n) &#123; //1、确定n所在的位数范围 int base = 1;//位数 int l = 1, step = 9, lnum = 1; for (; base &lt;= 8; base++) &#123; if (n &gt;= l &amp;&amp; n &lt;= l + step - 1) &#123; break; &#125; else &#123; l += step; step *= (10 * (base + 1)); step /= base; lnum *= 10; &#125; &#125; if (base &gt; 9) &#123; return -1; &#125; //2、计算在哪个数 int target = (n - l) / base + lnum; //3、计算在这个数的第几位 int targetIndex = (n - l + 1) % base; targetIndex = (!targetIndex ? base : targetIndex); vector&lt;int&gt; v; while (target)&#123; v.push_back(target % 10); target /= 10; &#125; return v[v.size() - targetIndex];&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"暴力枚举","slug":"暴力枚举","permalink":"http://example.com/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"}]}],"categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"},{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"机器学习/深度学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"语音识别","slug":"机器学习/深度学习/语音识别","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"},{"name":"essays","slug":"essays","permalink":"http://example.com/categories/essays/"},{"name":"网站相关","slug":"网站相关","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3/"},{"name":"NP问题","slug":"NP问题","permalink":"http://example.com/categories/NP%E9%97%AE%E9%A2%98/"},{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"},{"name":"读书笔记","slug":"NLP/读书笔记","permalink":"http://example.com/categories/NLP/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"概率论","slug":"概率论","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"计算技巧","slug":"计算技巧","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7/"},{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"暴力枚举","slug":"暴力枚举","permalink":"http://example.com/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"}]}