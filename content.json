{"meta":{"title":"一方の笔记本","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-09-14T02:25:37.601Z","updated":"2022-09-13T15:51:27.682Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2022-09-14T09:26:04.275Z","updated":"2022-09-14T09:26:04.275Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":".form-center { width: auto; display: table; margin-left: auto; margin-right: auto; } 关于本站&emsp;&emsp;本站基于 Hexo 框架，使用 Volantis-5.7.6 主题搭建，环境组件参数如下所示。 组件 版本及说明 npm 8.5.4 git 2.34.1.windows.1 Fira Code 代码字体 giscuss 评论系统 LeanCloud 数据统计服务 Github Page 部署 &emsp;&emsp; Hexo 的组件版本如下所示。 12345678910111213+-- hexo-deployer-git@3.0.0+-- hexo-generator-archive@1.0.0+-- hexo-generator-category@1.0.0+-- hexo-generator-index@2.0.0+-- hexo-generator-json-content@4.2.3+-- hexo-generator-tag@1.0.0+-- hexo-helper-qrcode@1.0.2+-- hexo-renderer-ejs@1.0.0+-- hexo-renderer-marked@4.1.0+-- hexo-renderer-stylus@2.1.0+-- hexo-server@2.0.0+-- hexo-theme-landscape@0.0.3`-- hexo@5.4.2 声明 本网站的所有原创内容均受 CC BY-NC-SA 4.0 许可协议的保护，不得用作商业用途，若转载请保留出处； 在浏览网站、或进行评论、交流等相关活动时，请遵守中华人民共和国宪法和法律，文明上网； 请您自觉遵守以上声明，否则，因浏览本站导致的任何问题，本站概不负责。"},{"title":"所有分类","date":"2022-09-12T14:18:31.774Z","updated":"2022-09-12T14:18:31.774Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-12T14:21:47.170Z","updated":"2022-09-12T14:21:42.198Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-12T14:10:37.471Z","updated":"2022-09-12T14:10:30.530Z","comments":true,"path":"essays/index.html","permalink":"http://example.com/essays/index.html","excerpt":"","text":"essay"},{"title":"我的朋友们","date":"2022-09-13T13:38:10.036Z","updated":"2022-09-13T13:38:10.036Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。"},{"title":"所有标签","date":"2022-09-12T14:18:17.131Z","updated":"2022-09-12T14:18:17.131Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-14T01:25:01.386Z","updated":"2022-09-14T01:25:01.386Z","comments":true,"path":"static/css/atom-one-dark.min.css","permalink":"http://example.com/static/css/atom-one-dark.min.css","excerpt":"","text":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}"},{"title":"","date":"2022-09-13T12:52:35.584Z","updated":"2022-09-13T12:52:35.577Z","comments":true,"path":"static/js/font_awesome.js","permalink":"http://example.com/static/js/font_awesome.js","excerpt":"","text":"window.FontAwesomeKitConfig = {\"asyncLoading\":{\"enabled\":false},\"autoA11y\":{\"enabled\":true},\"baseUrl\":\"https://ka-f.fontawesome.com\",\"baseUrlKit\":\"https://kit.fontawesome.com\",\"detectConflictsUntil\":null,\"iconUploads\":{},\"id\":83503769,\"license\":\"free\",\"method\":\"css\",\"minify\":{\"enabled\":true},\"token\":\"907ec27a36\",\"v4FontFaceShim\":{\"enabled\":true},\"v4shim\":{\"enabled\":true},\"v5FontFaceShim\":{\"enabled\":true},\"version\":\"6.2.0\"}; !function(t){\"function\"==typeof define&&define.amd?define(\"kit-loader\",t):t()}((function(){\"use strict\";function t(e){return(t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(e)}function e(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function n(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function o(t){for(var o=1;ot.length)&&(e=t.length);for(var n=0,o=new Array(e);n"}],"posts":[{"title":"一些杂七杂八的数学知识","slug":"一些杂七杂八的数学知识","date":"2022-09-14T12:18:39.000Z","updated":"2022-09-14T13:16:46.324Z","comments":true,"path":"2022/09/14/一些杂七杂八的数学知识/","link":"","permalink":"http://example.com/2022/09/14/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","excerpt":"&emsp;&emsp;这篇博客用于记录一些数学知识。","text":"&emsp;&emsp;这篇博客用于记录一些数学知识。 设 $a_n = \\displaystyle (1+\\frac{1}{n})^n$ ，求证 $\\forall n \\in \\text{N}^+, a_{n+1}&gt;a_n$ 。解法一&emsp;&emsp;$a_n=\\displaystyle \\prod_{i=1}^{n} (1 +\\frac{1}{n})=\\prod_{i=1}^{n} (1 +\\frac{1}{n})\\cdot 1 \\leq (\\frac{\\displaystyle \\sum_{i=1}^{n}(1+\\frac{1}{n})+1}{n+1})^{n+1}=(1+\\frac{1}{n+1})^{n+1}=a_{n+1}$ &emsp;&emsp;上式中的取等条件为$\\displaystyle \\frac{1}{n}+1=1$，这显然是不可能成立的，故$a_{n+1} &gt; a_{n}$。 &emsp;&emsp;这个解法使用了均值不等式，即$\\forall a_1, a_2,\\dots,a_n \\in \\text{R}$，$H_n \\leq G_n \\leq A_n\\leq Q_n$，其中四个均值分别为调和平均数、几何平均数、算数平均数和平方平均数，不等式取等条件都是$\\forall i,j\\in{1,2,\\dots,n},a_i=a_j$。上面的证明使用到了$G_n\\leq A_n$的变形，即$\\displaystyle \\prod_{i=1}^{n}a_i \\leq (\\frac{\\displaystyle \\sum_{i=1}^{n}a_i}{n})^n$。 解法二&emsp;&emsp;$\\displaystyle \\frac{a_{n+1}}{a_n} = (1-\\frac{1}{(n+1)^2})^n \\cdot \\frac{n+2}{n+1} \\geq (1-\\frac{n}{(n+1)^2}) \\cdot \\frac{n+2}{n+1} &gt; (1-\\frac{1}{n+2}) \\cdot \\frac{n+2}{n+1}=1$ &emsp;&emsp;以上证明使用了伯努利不等式，即$\\forall x &gt; -1$： $n\\geq1 \\Rightarrow (1+x)^n\\geq1+nx$； $n\\in[0,1] \\Rightarrow(1+x)^n\\leq1+nx$。 &emsp;&emsp;此外，$\\displaystyle \\frac{n}{(n+1)^2}=\\frac{1}{n+\\displaystyle\\frac{1}{n}+2}&lt;\\frac{1}{n+2}$。 解法三&emsp;&emsp; 设$y=e^{\\displaystyle x\\ln(1+\\frac{1}{x})}, x\\in \\text{R}^+$，则$f’(x)=[\\displaystyle\\ln(1+\\frac{1}{x})-\\frac{1}{x+1}]f(x)$。 &emsp;&emsp;设$g(x)=\\ln(1+x)-\\displaystyle\\frac{x}{1+x}$，则$g’(x)=\\displaystyle\\frac{x}{1+x} &gt; 0$，那么$f’(x)&gt;0$，那么$f(x)$在$\\text{R}^+$上单调递增，原命题显然。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"随笔栏的实现过程","slug":"随笔栏的实现过程","date":"2022-09-14T09:29:41.000Z","updated":"2022-09-14T09:31:10.180Z","comments":true,"path":"2022/09/14/随笔栏的实现过程/","link":"","permalink":"http://example.com/2022/09/14/%E9%9A%8F%E7%AC%94%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/","excerpt":"&emsp;&emsp;发现白羽老师的博客有一个随笔的专栏，想着学一下怎么做出来的。","text":"&emsp;&emsp;发现白羽老师的博客有一个随笔的专栏，想着学一下怎么做出来的。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-09-14T06:55:48.162Z","updated":"2022-09-13T13:59:38.970Z","comments":true,"path":"2022/09/14/hello-world/","link":"","permalink":"http://example.com/2022/09/14/hello-world/","excerpt":"&emsp;&emsp;记录一下网站的配置过程，方便以后查阅。","text":"&emsp;&emsp;记录一下网站的配置过程，方便以后查阅。 &emsp;&emsp;公式渲染和代码高亮的问题卡了一天，最后直接重用了旧版本的 Volantis 搭建的博客的代码。 闲谈&emsp;&emsp;一直有建立个人网站的想法，借着大三上学期选修课的机会终于是尝试动手了，2021年9月23日正式搭起了博客。为了应付课程（主要是有服务器配置的内容），我从腾讯云购买服务器与域名（有优惠的话第一年的价格还算比较美丽）。2022年9月份，收到了腾讯云关于服务器和域名快要到期的通知短信，终于又想起了自己原来还搞了小博客。个人网站是可以发布在 Github 上的，可以省下一笔不小的开支；如果希望域名能自定义则需要多花个域名的钱。此外，博客图片过多的话也可以考虑使用图床。 环境搭建&emsp;&emsp;以下内容均基于 Windows 10，必要的工具有 npm 、 Hexo 、 OpenSSH 以及 git 。 npm&emsp;&emsp;新版的 Node.js已经集成了 npm ，因此查找 Node.js 的安装教程即可。 Hexo&emsp;&emsp;如果 npm 已经安装完成，那么只需使用如下命令即可安装 Hexo 及其 Github 部署工具。 1npm install hexo-cli -g &amp;&amp; npm install hexo-deployer-git --save git 与 OpenSSH&emsp;&emsp;中文互联网上教程很多，并且基本没有什么太大的问题，在此不再赘述。 搭建仓库&emsp;&emsp;在 Github 上登陆账号并新建一个仓库即可，注意仓库名必须是 username.github.io ，其中 username 是 Github 上的用户名。 生成 SSH keys&emsp;&emsp;安装好 OpenSSH 后，使用如下命令创建公钥与私钥，其中 github-email 是 Github 账户的邮箱。 1ssh-keygen -t rsa -C github-email &emsp;&emsp;生成完成后，在 C:/Users/your-username/.ssh 目录下找到 id_rsa.pub 文件（即公钥），将其中的内容复制后在 Github 中的 SSH and GPG keys 一栏中选择 New SSH key 创建新的密钥即可。 Hexo 相关内容初始化&emsp;&emsp;在博客文件夹使用如下命令即可。 1hexo init Volantis 主题配置下载并安装主题&emsp;&emsp;我选择直接从 Github 下载主题源码，这种方式需要将源码文件夹放到 themes 下，随后需要： 复制主题中 _config.yml ，并将其更名为 _config.volantis.yml ，然后拷贝到博客根目录； 将主题源码的文件夹名改为 volantis ，并将根目录中 _config.yml 中 theme 更改为 volantis ，注意 yml 的书写规范。1theme: volantis #冒号后一个空格 字体更改我使用的配置如下所示。1234567891011121314151617#file: _contig.volantis.yml #for valantis, 2022/9/12 fontfamily: logofont: fontfamily: &#x27;&quot;Times New Roman&quot;, SimSun&#x27; name: &#x27;Varela Round&#x27; url: volantis-static/media/fonts/VarelaRound/VarelaRound-Regular.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;Times New Roman&quot;, SimSun&#x27; name: &#x27;UbuntuMono&#x27; url: volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &#x27;&quot;Fira Code&quot;&#x27; 数学公式渲染&emsp;&emsp;我最终采用的渲染器为 hexo-renderer-marked ，即 Hexo 自带的渲染器。在使用 Volantis-5.7.6 更换渲染器后，报出了如下的错误，一直没有找到解决的办法，这是我直接使用旧版本的其中一个原因。123456789101112131415161718ERRORSyntaxError: Unexpected identifier in &quot;D:\\\\code\\\\blog\\\\themes\\\\volantis\\\\layout\\\\layout.ejs&quot; at new Function (&lt;anonymous&gt;) at exports.compile (D:\\code\\blog\\node_modules\\hexo-renderer-mathjax\\node_modules\\ejs\\lib\\ejs.js:242:14) at Object.exports.render (D:\\code\\blog\\node_modules\\hexo-renderer-mathjax\\node_modules\\ejs\\lib\\ejs.js:284:66) at Hexo.&lt;anonymous&gt; (D:\\code\\blog\\node_modules\\hexo-renderer-mathjax\\index.js:14:24) at Hexo.tryCatcher (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Hexo.ret (eval at makeNodePromisifiedEval (C:\\Users\\17258\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\node_modules\\bluebird\\js\\release\\promisify.js:184:12), &lt;anonymous&gt;:13:39) at D:\\code\\blog\\node_modules\\hexo\\lib\\hexo\\render.js:81:22 at tryCatcher (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\promise.js:547:31) at Promise._settlePromise (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\promise.js:604:18) at Promise._settlePromiseCtx (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\promise.js:641:10) at _drainQueueStep (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:97:12) at _drainQueue (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:86:9) at Async._drainQueues (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:102:5) at Immediate.Async.drainQueues [as _onImmediate] (D:\\code\\blog\\node_modules\\bluebird\\js\\release\\async.js:15:14) at processImmediate (node:internal/timers:464:21) 代码高亮&emsp;&emsp;在使用 Volantis-5.7.6 实在是没有找到代码高亮的配置方法，还是用回了 4.3.1 版本，现在还需设置复制代码的按钮。评论区&emsp;&emsp;配置中。主题配置文件&emsp;&emsp;以后再弄（ 参考资料 【2021最新版】保姆级Hexo+github搭建个人博客","categories":[{"name":"网站相关","slug":"网站相关","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"组合数学学习","slug":"组合数学学习","date":"2021-11-17T03:04:14.000Z","updated":"2022-09-12T13:13:17.321Z","comments":true,"path":"2021/11/17/组合数学学习/","link":"","permalink":"http://example.com/2021/11/17/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/","excerpt":"&emsp;&emsp;赶紧来补补数学（","text":"&emsp;&emsp;赶紧来补补数学（ 卡特兰数&emsp;&emsp;最早了解到卡特兰数是通过统计$1 \\sim n$按序入栈，能构成的出栈序列的个数。 &emsp;&emsp;卡特兰数的通项公式为$C_n = \\frac{C_{2n}^n}{n+1},n\\in N^+$。","categories":[],"tags":[]},{"title":"C++的大整数类","slug":"C++的大整数类","date":"2021-11-13T04:55:35.000Z","updated":"2022-09-13T12:21:39.845Z","comments":true,"path":"2021/11/13/C++的大整数类/","link":"","permalink":"http://example.com/2021/11/13/C++%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E7%B1%BB/","excerpt":"&emsp;&emsp;这两天写高精度计算，发现C++缺少一个方便使用的大整数类，于是自己写了一个。","text":"&emsp;&emsp;这两天写高精度计算，发现C++缺少一个方便使用的大整数类，于是自己写了一个。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181//file: big_int.h#ifndef _BIG_INT_H#define _BIG_INT_H#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define __POSITIVE__ false#define __NEGATIVE__ trueclass big_int &#123;public: big_int() :sign(__POSITIVE__), nums(1, 0) &#123;&#125; big_int(int n) :sign(n &lt; 0) &#123; if (n == 0) nums.resize(1, 0); else &#123; if (n &lt; 0) n = -n; while (n) &#123; nums.emplace_back(n % 10); n /= 10; &#125; &#125; &#125; big_int(const std::string&amp; n) :sign(n[0] == &#x27;-&#x27;) &#123; if (n == &quot;0&quot;) nums.resize(1, 0); else &#123; int highest = sign; for (int i = n.size() - 1; i &gt;= highest; i--) &#123; nums.emplace_back(n[i] - &#x27;0&#x27;); &#125; &#125; &#125; big_int(const big_int&amp; _ano) :sign(_ano.sign), nums(_ano.nums) &#123;&#125; big_int operator+(const big_int&amp; _ano) const &#123; if (sign != _ano.sign) return *this - big_int(!_ano.sign, _ano.nums); std::vector&lt;int&gt; ans(std::max(_ano.nums.size(), nums.size()) + 1, 0); int i = 0, j = 0, k = 0; while (i &lt; nums.size() &amp;&amp; j &lt; _ano.nums.size()) ans[k++] = nums[i++] + _ano.nums[j++]; while (i &lt; nums.size()) ans[k++] = nums[i++]; while (j &lt; _ano.nums.size()) ans[k++] = _ano.nums[j++]; for (int i = 0, c = 0; i &lt; ans.size(); i++) &#123; ans[i] += c; c = ans[i] / 10; ans[i] %= 10; &#125; while (ans.size() &gt; 1 &amp;&amp; ans.back() == 0) ans.pop_back(); return big_int(sign, ans); &#125; big_int operator-(const big_int&amp; _ano) const &#123; if (sign != _ano.sign) return *this + big_int(!_ano.sign, _ano.nums); if (absolute_value_A_less_than_B(nums, _ano.nums)) return big_int(!sign, absolute_value_subtract(_ano.nums, nums)); else return big_int(sign, absolute_value_subtract(nums, _ano.nums)); &#125; big_int operator*(const big_int&amp; _ano) const &#123; return big_int(sign ^ _ano.sign, absolute_value_mutiply(_ano.nums, nums)); &#125; big_int operator/(const big_int&amp; _ano) const &#123; if (absolute_value_A_less_than_B(nums, _ano.nums)) return big_int(0); std::vector&lt;int&gt; res, temp, tempMul; for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; temp.push_back(nums[i]); std::reverse(temp.begin(), temp.end()); while (temp.size() &gt; 1 &amp;&amp; temp.back() == 0) temp.pop_back(); int j = 1; for (; j &lt;= 9; j++) &#123; std::vector&lt;int&gt; factor(1, j); tempMul = absolute_value_mutiply(factor, _ano.nums); if (absolute_value_A_less_than_B(temp, tempMul)) &#123; break; &#125; &#125; res.emplace_back(--j); tempMul = absolute_value_mutiply(std::vector&lt;int&gt;(1, j), _ano.nums); temp = absolute_value_subtract(temp, tempMul); std::reverse(temp.begin(), temp.end()); &#125; int i = 0; while (i &lt; res.size() - 1 &amp;&amp; res[i] == 0) i++; std::vector&lt;int&gt; ans(std::vector(res.begin() + i, res.end())); std::reverse(ans.begin(), ans.end()); return big_int(sign ^ _ano.sign, ans); &#125; big_int operator%(const big_int&amp; _ano) const &#123; return *this - *this / _ano * _ano; &#125; big_int&amp; operator=(const big_int&amp; _ano) &#123; sign = _ano.sign; nums = _ano.nums; return *this; &#125; big_int&amp; operator+=(const big_int&amp; _ano) &#123; *this = *this + _ano; return *this; &#125; big_int&amp; operator-=(const big_int&amp; _ano) &#123; *this = *this - _ano; return *this; &#125; big_int&amp; operator*=(const big_int&amp; _ano) &#123; *this = *this * _ano; return *this; &#125; big_int&amp; operator/=(const big_int&amp; _ano) &#123; *this = *this / _ano; return *this; &#125; big_int operator%=(const big_int&amp; _ano) &#123; *this = *this - *this / _ano * _ano; return *this; &#125; big_int operator++(int) &#123; big_int temp = *this; *this += 1; return temp; &#125; big_int&amp; operator++() &#123; *this += 1; return *this; &#125; bool operator&lt;(const big_int&amp; _ano) const &#123; if (sign == _ano.sign) return absolute_value_A_less_than_B(nums, _ano.nums); else return sign == __NEGATIVE__; &#125; bool operator==(const big_int&amp; _ano) const &#123; return sign == _ano.sign &amp;&amp; nums == _ano.nums; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const big_int&amp; _output);private: bool sign; std::vector&lt;int&gt; nums; bool absolute_value_A_less_than_B(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const &#123; if (A.size() != B.size()) return A.size() &lt; B.size(); else &#123; for (int i = A.size() - 1; i &gt;= 0; i--) &#123; if (A[i] != B[i]) return A[i] &lt; B[i]; &#125; &#125; return false; &#125; big_int(bool sign, const std::vector&lt;int&gt;&amp; nums) :sign(sign), nums(nums) &#123;&#125; std::vector&lt;int&gt; absolute_value_subtract(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const &#123; std::vector&lt;int&gt; ans(A); for (int i = 0, c = 0; i &lt; A.size(); i++) &#123; ans[i] -= c + (i &lt; B.size() ? B[i] : 0); c = ans[i] &lt; 0; ans[i] += (ans[i] &lt; 0 ? 10 : 0); &#125; while (ans.back() == 0 &amp;&amp; ans.size() &gt; 1) ans.pop_back(); return ans; &#125; std::vector&lt;int&gt; absolute_value_mutiply(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) const &#123; std::vector&lt;int&gt; ans(A.size() + B.size(), 0); for (int i = 0; i &lt; A.size(); i++) &#123; for (int j = 0; j &lt; B.size(); j++) &#123; ans[i + j] += A[i] * B[j]; &#125; &#125; for (int i = 0, c = 0; i &lt; ans.size(); i++) &#123; ans[i] += c; c = ans[i] / 10; ans[i] %= 10; &#125; while (ans.size() &gt; 1 &amp;&amp; ans.back() == 0) ans.pop_back(); return ans; &#125;&#125;;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const big_int&amp; _output) &#123; if (_output.sign == __NEGATIVE__) o &lt;&lt; &#x27;-&#x27;; for (int i = _output.nums.size() - 1; i &gt;= 0; i--) o &lt;&lt; _output.nums[i]; return o;&#125;inline big_int max(const big_int&amp; _a, const big_int&amp; _b)&#123; return _a &gt;= _b ? _a : _b;&#125;inline big_int min(const big_int&amp; _a, const big_int&amp; _b) &#123; return _a &lt;= _b ? _a : _b;&#125;#endif &emsp;&emsp;测试代码如下所示。 123456789101112131415//file: test.cpp#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;big_int.h&quot;using namespace std;const int N = 100;big_int fact[N + 1];int main() &#123; fact[0] = 1; for (int i = 1; i &lt;= N; i++) &#123; fact[i] = fact[i - 1] * i; &#125; cout &lt;&lt; fact[10] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法刷题日记7","slug":"算法刷题日记7","date":"2021-11-12T11:38:30.000Z","updated":"2022-09-13T11:54:33.276Z","comments":true,"path":"2021/11/12/算法刷题日记7/","link":"","permalink":"http://example.com/2021/11/12/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B07/","excerpt":"&emsp;&emsp;赶紧学学算法（","text":"&emsp;&emsp;赶紧学学算法（ 矩阵转置输出&emsp;&emsp;做题做的人有点麻，来道签到题（ 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;//矩阵转置输出using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; nums(n,vector&lt;int&gt;(m)); for (auto&amp; i : nums) &#123; for (auto&amp; j : i) &#123; cin &gt;&gt; j; &#125; &#125; for (int j = 0; j &lt; m; j++) &#123; for (int i = n - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; nums[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;//algo 1007#define square(x) ((x)*(x))using namespace std;int main() &#123; int N; double R, C = 0.0; cin &gt;&gt; N &gt;&gt; R; vector&lt;pair&lt;double, double&gt;&gt; points(N, pair&lt;double, double&gt;()); for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; points[i].first &gt;&gt; points[i].second; &#125; for (int i = 1; i &lt; N; i++) &#123; C += sqrt(square(points[i].first - points[i - 1].first) + square(points[i].second - points[i - 1].second)); &#125; C += sqrt(square(points[0].first - points[N - 1].first) + square(points[0].second - points[N - 1].second)); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2); cout &lt;&lt; C + acos(-1) * 2.0 * R &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;//algo 1054using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;bool&gt;&gt; land(n, vector&lt;bool&gt;(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int temp; cin &gt;&gt; temp; land[i][j] = temp; &#125; &#125; vector&lt;vector&lt;int&gt;&gt;dp(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (land[i][j]) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; &#125; &#125; &#125; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans = max(ans, dp[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;//algo 2039using namespace std;int product_counts(int i) &#123; int ans = 0; for (int j = 1; j &lt;= i; j++) &#123; if (i % j == 0) &#123; ans++; &#125; &#125; return ans;&#125;int main() &#123; int K; bool s = false; cin &gt;&gt; K; for (int i = 1; i &lt;= 2000; i++) &#123; if (product_counts(i) == K) &#123; cout &lt;&lt; i &lt;&lt; endl; s = true; &#125; &#125; cout &lt;&lt; (s ? &quot;&quot; : &quot;NO SOLUTION\\n&quot;); return 0;&#125; 12345678910111213141516import java.math.*;//algo 1083 java版本import java.util.*;public class Main &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); String s = input.nextLine(); BigInteger n = new BigInteger(s);//当2^(i) &lt;= n &lt; 2^(i+1)时，输出1+2*(n-2^i) BigInteger pow = new BigInteger(&quot;1&quot;); while(pow.compareTo(n) &lt;= 0)&#123; pow = pow.multiply(new BigInteger(&quot;2&quot;)); &#125; input.close(); System.out.print(n.multiply(new BigInteger(&quot;2&quot;)).subtract(pow).add(new BigInteger(&quot;1&quot;))); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;//algo 1083using namespace std;struct big_int &#123;//只在正数范围内进行求解 vector&lt;int&gt; nums;//实际数字的低位存在数组的低位较为容易计算 big_int():nums(vector&lt;int&gt;())&#123;&#125; big_int(int _init) :nums(vector&lt;int&gt;()) &#123; while (1) &#123; nums.emplace_back(_init % 10); _init /= 10; if (_init == 0) &#123; break; &#125; &#125; &#125; big_int(const string&amp; _init):nums(vector&lt;int&gt;()) &#123; for (int i = _init.size() - 1; i &gt;= 0; i--) &#123; nums.emplace_back(_init[i] - &#x27;0&#x27;); &#125; &#125; big_int operator*(const big_int&amp; ano)&#123; big_int ans(0); int n = nums.size(), m = ano.nums.size(); ans.nums.resize(m + n, 0); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans.nums[i + j] += nums[i] * ano.nums[j]; &#125; &#125; int c = 0; for (int i = 0; i &lt; m + n; i++) &#123; ans.nums[i] += c; c = ans.nums[i] / 10; ans.nums[i] %= 10; &#125; for (int i = m + n - 1; i &gt;= 0; i--) &#123; if (ans.nums[i] == 0) &#123; ans.nums.pop_back(); &#125; else &#123; break; &#125; &#125; if (c != 0) &#123; ans.nums.emplace_back(c); &#125; return ans; &#125; big_int pow(int n) &#123; big_int ans(1); for (int i = 1; i &lt;= n; i++) &#123; ans = ans * (* this); &#125; return ans; &#125; bool operator&lt;(const big_int&amp; _ano) const&#123; if (nums.size() != _ano.nums.size()) &#123; return nums.size() &lt; _ano.nums.size(); &#125; else &#123; int n = nums.size(); for (int i = n - 1; i &gt;= 0; i--) &#123; if (nums[i] &lt; _ano.nums[i]) &#123; return true; &#125; else if (nums[i] == _ano.nums[i]) &#123; continue; &#125; else &#123; return false; &#125; &#125; return false; &#125; &#125; bool operator==(const big_int&amp; _ano) const&#123; return _ano.nums == nums; &#125; bool operator&lt;=(const big_int&amp; _ano) const&#123; return *this &lt; _ano || *this == _ano; &#125; big_int operator+(const big_int&amp; _ano) const&#123; big_int ans; int n = nums.size(), m = _ano.nums.size(); int i = 0, j = 0, c = 0, k = 0; ans.nums.resize(max(m, n), 0); while (i &lt; n &amp;&amp; j &lt; m) &#123; ans.nums[k] += (c + nums[i] + _ano.nums[j]); c = ans.nums[k] / 10; ans.nums[k] %= 10; i++; j++; k++; &#125; while (i &lt; n) &#123; ans.nums[k] += (c + nums[i]); c = ans.nums[k] / 10; ans.nums[k] %= 10; i++; k++; &#125; while (j &lt; m) &#123; ans.nums[k] += (c + _ano.nums[j]); c = ans.nums[k] / 10; ans.nums[k] %= 10; j++; k++; &#125; if (c != 0) &#123; ans.nums.emplace_back(c); &#125; return ans; &#125; big_int operator-(const big_int&amp; _ano) const&#123;//*this &gt; _ano big_int ans; int n = nums.size(), m = _ano.nums.size(); int c = 0; ans.nums.resize(n, 0); for (int i = 0; i &lt; n; i++) &#123; int temp = (i &lt; m ? nums[i] - _ano.nums[i] + c : nums[i] + c); ans.nums[i] = (temp &gt;= 0 ? temp : temp + 10); c = (temp &gt;= 0 ? 0 : -1); &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; if (ans.nums[i] == 0) &#123; ans.nums.pop_back(); &#125; else &#123; break; &#125; &#125; return ans; &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, const big_int&amp; _output) &#123; for (int i = _output.nums.size() - 1; i &gt;= 0; i--) &#123; os &lt;&lt; _output.nums[i]; &#125; return os;&#125;int main() &#123; string n; cin &gt;&gt; n;//当2^(i) &lt;= n &lt; 2^(i+1)时，输出2n+1-2^(i+1) int i = 0; while (1) &#123; if (!(big_int(2).pow(i) &lt;= big_int(n) &amp;&amp; big_int(n) &lt; big_int(2).pow(i + 1))) &#123; i++; &#125; else &#123; break; &#125; &#125; cout &lt;&lt; big_int(2) * big_int(n) + big_int(1) - big_int(2).pow(i + 1) &lt;&lt; endl; return 0;&#125; 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;//约瑟夫环121报数版本using namespace std;int main() &#123; for (int n = 1; n &lt;= 1000; n++) &#123; list&lt;int&gt; l; for (int i = 1; i &lt;= n; i++) &#123; l.emplace_back(i); &#125; auto iter = l.begin(); iter++; while (l.size() &gt; 1) &#123; auto cur_out = iter; for (int i = 1; i &lt;= 2; i++) &#123;//学习list的使用 iter++; if (iter == l.end()) &#123; iter = l.begin(); &#125; &#125; l.erase(cur_out); &#125; cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &#x27;:&#x27; &lt;&lt; l.front() &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;//algo 1101using namespace std;//100分using ll = long long;ll ans = 0;int n, k;void dfs(int last_sum, int last_num,int cur_depth) &#123; if (cur_depth == k - 1) &#123; if (n - last_sum &gt;= last_num) &#123;//减少一层深度就过了 ans++; &#125; return; &#125; for (int i = last_num; i &lt;= n - last_sum; i++) &#123; dfs(last_sum + i, i, cur_depth + 1); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n / k + 1; i++) &#123; dfs(i, i, 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;//algo 1101using namespace std;//80分using ll = long long;ll ans = 0;int n, k;void dfs(int last_sum, int last_num, int cur_depth) &#123; if (cur_depth == k) &#123; if (last_sum == n) &#123; ans++; &#125; return; &#125; for (int i = last_num; i = n - last_sum; i++) &#123; dfs(last_sum + i, i, cur_depth + 1); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n / k + 1; i++) &#123; dfs(i, i, 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123; int n; cin &gt;&gt; n; ll ans = 1;//卡特兰数 for (int i = 2 * n; i &gt;= n + 2; i--) &#123; ans *= i; &#125; for (int i = n; i &gt;= 2; i--) &#123; ans /= i; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;//algo 1106using namespace std;using ll = long long;ll ans = 0;int n;void dfs(int stack_elements, int next_in) &#123; if (next_in &gt; n) &#123; ans++; return; &#125; else &#123; dfs(stack_elements + 1, next_in + 1);//进栈 if (stack_elements &gt; 0) &#123; dfs(stack_elements - 1, next_in);//出栈 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; dfs(0, 1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"概率论的一些知识点的总结","slug":"概率论的一些小技巧","date":"2021-11-11T11:13:52.000Z","updated":"2022-09-14T06:20:43.401Z","comments":true,"path":"2021/11/11/概率论的一些小技巧/","link":"","permalink":"http://example.com/2021/11/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"&emsp;&emsp;忽然想起之前学概率论的时候整理了不少计算的小技巧，正好拿来练练写公式。","text":"&emsp;&emsp;忽然想起之前学概率论的时候整理了不少计算的小技巧，正好拿来练练写公式。 常用的七个泰勒公式$$\\displaystyle \\sin x = \\sum\\limits_{n=0}^\\infty \\frac{(-1)^n}{(2n+1)!}x^{2n+1}=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-…,x\\in(-\\infty,+\\infty)$$ $$\\displaystyle \\cos x = \\sum\\limits_{n=0}^\\infty\\frac{(-1)^n}{(2n)!}x^{2n}=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-…,x\\in(-\\infty,+\\infty)$$ $$\\displaystyle e^x=\\sum\\limits_{n=0}^\\infty\\frac{x^n}{n!}=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+…,x\\in(-\\infty,+\\infty)$$ &emsp;&emsp;由以上三个公式可得欧拉公式：$\\displaystyle e^{ix}=i \\sin x+ \\cos x$。 $$\\displaystyle \\ln(1+x)= \\sum \\limits_{n=1}^\\infty\\frac{(-1)^{n+1}}{n}x^n=x-\\frac{x^2}{2}+\\frac{x^3}{3}-…,x\\in(-1,1]$$ &emsp;&emsp;由$\\ln(1+x)$的展开式可得$\\displaystyle \\ln2= \\sum \\limits_{n=1}^\\infty\\frac{(-1)^{n+1}}{n}$。 &emsp;&emsp;事实上，$\\ln(x+1)$的展开式可以由下式推出： $$\\displaystyle\\frac{1}{1+x}= \\sum \\limits_{n=0}^\\infty (-x)^n=1-x+x^2-…,x\\in(-1,1)$$ &emsp;&emsp;将上式中的 $x$ 代换为$(-x)$即可得到下式： $$\\displaystyle\\frac{1}{1-x} =\\sum \\limits_{n=0}^\\infty x^n=1+x+x^2+…,x\\in(-1,1)$$ &emsp;&emsp;事实上，$\\displaystyle\\frac{1}{1+x}$与$\\displaystyle\\frac{1}{1-x}$的泰勒展开式就是首项为$1$，公比为$\\mp x$的等比数列的前 $n$ 项和 $S_n$ 在$n\\to\\infty$的极限。关于等比级数还有一个常用的结论：当$|q|&lt;1$ 时，级数$\\displaystyle \\sum \\limits_{n=1}^\\infty a_1q^{n-1}$收敛于$\\displaystyle \\frac{a_1}{1-q}$。 &emsp;&emsp;还有一个相对其他六个不太常用的一个公式： $$\\displaystyle (1+x)^{\\alpha}=1+\\alpha x+\\frac{\\alpha(\\alpha-1)}{2!}x^2+…,x\\in(-1,1),a\\neq0$$ &emsp;&emsp;由第七个公式可得一个常用的等价无穷小：$(1+\\beta x)^{\\alpha}-1$~$\\alpha \\beta x,x\\to0$。 &emsp;&emsp;事实上，记住以上七个泰勒公式后，很多等价无穷小可以直接推出。 &emsp;&emsp;另外，同理第五个、第六个公式，有以下公式： $$\\displaystyle\\frac{1}{1+x^2}= \\sum \\limits_{n=0}^\\infty(-1)^nx^{2n}=1-x^2+…,x\\in(-1,1)$$ &emsp;&emsp;对上式积分有：$\\displaystyle\\int_0^x\\frac{1}{1+t^2}dt=\\int_0^x\\displaystyle \\sum \\limits_{n=0}^ \\infty(-1)^nt^{2n}dt$，等式左侧$=\\arctan x$，等式右侧$=\\displaystyle \\sum \\limits_{n=0}^ \\infty(-1)^{n}(\\frac{1}{2n+1}x^{2n+1})$，所以：$$\\arctan x =\\displaystyle \\sum \\limits_{n=0}^ \\infty(-1)^{n}(\\frac{1}{2n+1}x^{2n+1})=x-\\frac{x^3}{3}+\\frac{x^5}{5}-…,x\\in(-1,1)$$ 与$e^{-x}$有关的反常积分&emsp;&emsp;首先是最简单的一个积分：$\\displaystyle\\int_0^{+\\infty} e^{-x}dx=[-e^{-x}]_0^{+\\infty}=1$。 &emsp;&emsp;然后进行一些简单的推广：$\\displaystyle\\int_0^{+\\infty} x^n e^{-x}dx=n!,x\\in N$，当$n=0$时就是上面的积分，这个积分有很多种证明的方法，使用分部积分法加上第一数学归纳法或者待定系数法都可以证明，这里略去证明。当$n$换为另外一个实数时，以上积分的值需要进行推广，在实数域上就是伽马函数。值得注意的是$\\Gamma(x+1)=x\\Gamma(x)$，而$(n+1)!=(n+1)n!$。 &emsp;&emsp;随后再进行一些变换：$\\displaystyle\\int_0^{+\\infty} x^n e^{-\\lambda x}dx=\\frac{n!}{\\lambda ^ {n+1}},n\\in N,\\lambda\\in R^+$。有了上面的积分的结果，只需要进行一步换元，令$\\lambda x = t$很容易计算出上面的结果。 与$e^{-x^2}$有关的反常积分&emsp;&emsp;首先是最著名的高斯积分：$\\displaystyle \\int_{-\\infty}^{+\\infty}e^{-x^2}dx=\\sqrt{\\pi}$。求解这个积分最常见的方法是将其转换为二重积分。记$\\displaystyle I = \\int ^{+\\infty}_{-\\infty} e^{-x^2} dx$，则： $$\\displaystyle I^2 = \\int ^{+\\infty} _{-\\infty} e^{-x^2} dx\\int ^{+\\infty} _{-\\infty} e^{-y^2} dy = \\int ^{+\\infty} _{-\\infty} \\int ^{+\\infty} _{-\\infty}e^{-(x^2+y^2)}dxdy $$ &emsp;&emsp;随后进行极坐标换元有：$\\displaystyle I^2 = \\int_0^{2\\pi}d\\theta\\int ^{+\\infty} _0 \\rho e^{-\\rho^2}d\\rho=\\pi$，显然$I&gt;0$，因此$I=\\sqrt{\\pi}$。 &emsp;&emsp;此外，还有一个我很喜欢的广义积分：$\\displaystyle \\int_0^{+\\infty}\\frac{\\sin x}{x}dx=\\frac{\\pi}{2}$，这个积分被称为狄利克雷积分积分，使用拉普拉斯变换可以很容易求解这个积分。 &emsp;&emsp;正态分布是概率论中很重要的的一种分布，设$X$~$N(\\mu,\\sigma^2)$，则$X$的概率密度函数为$\\displaystyle f_X(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},x\\in(-\\infty,+\\infty),\\mu\\in R,\\sigma\\in R^+$，而由概率密度函数的意义有：$\\displaystyle \\int ^{+\\infty} _{-\\infty}f_X(x)dx=1$，因此有$\\displaystyle \\int ^{+\\infty} _{-\\infty}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx=1$。纯粹从求解题目的角度来讲，从概率密度函数定义的角度出发也是可以求解高斯积分的。令$\\mu=0,\\sigma=\\displaystyle\\frac{\\sqrt{2}}{2}$，代入上述概率密度函数的积分有：$\\displaystyle \\int ^{+\\infty} _{-\\infty}\\frac{1}{\\sqrt{\\pi}}e^{-x^2}dx=1$，结果很显然了。 &emsp;&emsp;设随机变量$X\\sim N(\\mu,\\sigma^2)$，则有： $$\\displaystyle E(X)=\\int ^{+\\infty} _{-\\infty}xf_X(x)dx=\\int ^{+\\infty} _{-\\infty}\\frac{x}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx{\\xlongequal{t=\\frac{x-\\mu}{\\sigma}}}\\int ^{+\\infty} _{-\\infty}\\frac{\\sigma t + \\mu}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{t^2}{2}}d(\\sigma t+\\mu)=\\mu\\int ^{+\\infty} _{-\\infty}\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt=\\mu$$ &emsp;&emsp;同理可求得$E(X^2)$： $$\\displaystyle E(X^2)=\\int ^{+\\infty} _{-\\infty}x^2 f_X(x)dx=\\int ^{+\\infty} _{-\\infty}\\frac{x^2}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx{\\xlongequal{t=\\frac{x-\\mu}{\\sigma}}}\\int ^{+\\infty} _{-\\infty}\\frac{(\\sigma t + \\mu)^2}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{t^2}{2}}d(\\sigma t+\\mu)=\\mu^2+\\frac{\\sigma^2}{\\sqrt{2\\pi}}\\int ^{+\\infty} _{-\\infty}t^2e^{-\\frac{t^2}{2}}dt$$ &emsp;&emsp;对于最后一部分的积分，有：$\\displaystyle \\int ^{+\\infty} _{-\\infty}t^2e^{-\\frac{t^2}{2}}dt=\\int^{+\\infty} _{-\\infty}e^{-\\frac{t^2}{2}}dt-[te^{-\\frac{t^2}{2}}]^{+\\infty} _{-\\infty}=\\sqrt{2\\pi}$，因此$E(X^2)=\\mu^2+\\sigma^2$。 &emsp;&emsp;又$D(X)=E(X^2)-[E(X)]^2$，故$D(X)=\\sigma^2$。 &emsp;&emsp;在求解正态分布的期望和方差时，我们又得到了一个非常有用的积分值$\\displaystyle \\int^{+\\infty} _{-\\infty}\\frac{x^2}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}dx=1$。事实上，可以求出标准正态分布的$n$阶原点矩。设$X\\sim N(0,1)$当$n$为偶数时，$E(X^n)=(n-1)!!$；当$n$为奇数时，$E(X^n)=0$。还有一个比较常用的值为$E(X^4)=3$。 大学物理中出现的一些积分$$\\displaystyle \\int_{-\\infty}^{+\\infty}x^{2n}e^{-bx^2}dx =2\\int^{+\\infty}_0(\\frac{t}{b})^ne^{-t}d(\\sqrt\\frac{t}{b})=\\frac{1}{(\\sqrt b)^{2n+1}}\\int_0^{+\\infty}t^{n-\\frac{1}{2}}e^{-t}dt=\\frac{1}{(\\sqrt b)^{2n+1}}\\Gamma(n+\\frac{1}{2})=\\displaystyle\\frac{(2n-1)!!}{2^{n+1}b^n}\\sqrt{\\frac{\\pi}{b}}$$ $$\\displaystyle \\int_{0}^{+\\infty}\\frac{x^3}{e^x-1}dx=\\int_{0}^{+\\infty}x^3\\frac{e^{-x}}{1-e^{-x}}dx=\\displaystyle \\int_0^{+\\infty}x^3 \\sum_{n=1}^{\\infty} e^{-n} dx=\\displaystyle \\sum_{n=1}^{\\infty}\\int_{0}^{+\\infty} x^3e^{-n}dx=3! \\cdot \\displaystyle \\sum_{n=1}^{\\infty}\\frac{1}{n^4}=\\frac{\\pi^4}{15}$$ $$\\displaystyle \\int^{+\\infty}{0}\\frac{x^3}{e^x-1}dx=\\displaystyle \\int_0^{+\\infty}x^3 \\sum{n=1}^{\\infty} e^{-n} dx=\\displaystyle \\sum_{n=1}^{\\infty}\\int_{0}^{+\\infty} x^3e^{-n}dx=3! \\cdot \\displaystyle \\sum_{n=1}^{\\infty}\\frac{1}{n^4}=\\frac{\\pi^4}{15}$$","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"计算技巧","slug":"计算技巧","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7/"}]},{"title":"算法刷题日记6","slug":"算法刷题日记6","date":"2021-11-11T00:52:28.000Z","updated":"2022-09-13T12:19:58.079Z","comments":true,"path":"2021/11/11/算法刷题日记6/","link":"","permalink":"http://example.com/2021/11/11/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B06/","excerpt":"日常练习","text":"日常练习 平面上最近点对问题&emsp;&emsp;给定平面上$n$个点及其横纵坐标（保证横纵坐标都是long long范围内的整数），求这$n$个点中距离最小的一对点，要求输出最小距离，保留三位小数。 &emsp;&emsp;最直接的想法当然是暴力枚举（ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define square(x) ((x)*(x))using namespace std;using ll = long long;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;ll&gt;&gt; points(n, vector&lt;int&gt;(2)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; points[i][0] &gt;&gt; points[i][1]; &#125; double ans = 0.0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; ans = max(ans, sqrt(square(points[i][0] - points[j][0]) + square(points[i][1] - points[j][1]))); &#125; &#125; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; &emsp;&emsp;但是当点的数量太多的时候，暴力枚举会超时，所以需要进行求解的优化。 &emsp;&emsp;对于本题来讲可以采用分治的策略。那么什么是分治策略呢？ &emsp;&emsp;事实上，二分查找就是分治策略的一种应用。要在排序好的数组中查找目标值，先取中间值，然后根据情况取左、右区间中的一个进行查找。当数组较大时，数组中的很大一部分空间并没有被遍历，因此二分查找确实是将时间复杂度降低了（由$O(n)$到$O(logn)$）。 &emsp;&emsp;但是分治策略对于有些问题是无效的，例如矩阵乘法问题，矩阵进行分块后再相乘并没有减少乘法的次数。使用分治策略求解平面上最近点对的问题可以降低时间复杂度吗？ &emsp;&emsp;答案是可以。分治策略中很关键的一点是如何降低从小规模问题的解构成大规模问题的解的时间复杂度。对于矩阵乘法问题，不论如何划分，”合“的过程的复杂度是无法降低的。现证明分治策略对于求平面最近点对的距离问题有效。 图1 证明分治策略有效（图源） &emsp;&emsp;如图1，设$\\delta_L$和$\\delta_R$分别是对平面的左右部分求出来的最小距离，取$\\delta = min(\\delta_L,\\delta_R)$。考虑划分位置$L$左右$\\delta$范围内的点，首先可以证明如果平面左右部分中各取一点，若所求得的距离$d \\leq \\delta$，那么这两点一定在虚线的区域，这是很显然的。然后证明，对于左侧任意一个点$P_1$，它若与右侧中的一点$P_2 \\in Right$满足$distance(P_1,P_2) \\leq \\delta$，那么$Right$中的点一定在$\\delta * 2\\delta$的一个矩形内，如图2所示，这个同样是显然的。 图2 核心部分证明 &emsp;&emsp;图2所示的矩形部分之多有6个点。即将这个举行划分为6个$\\frac {2\\delta}{3} * \\frac {\\delta}{2}$的矩形，由鸽巢原理，若点的个数大于6，则这6个矩形中至少有一个中有超过2个点，而每个矩形中2个点最远的距离是$\\sqrt{\\left(\\frac{2\\delta}{3}\\right)^2 + \\left(\\frac{\\delta}{2}\\right)^2}=\\frac{5\\delta}{6}&lt;\\delta$，而这是刚刚求解过的右半部分，显然这是不成立的，因此原假设不真。这也就证明了在进行局部解到整体解的合并的过程中需要枚举的点大大减少，时间复杂度确实降低了。 &emsp;&emsp;由这样的思路最终得出如下的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define square(x) ((x)*(x))#define MAX_SIZE 200050using db = double;using ll = long long;using namespace std;int n;struct point &#123; ll x, y; &#125;;vector&lt;point&gt;input;bool cmp1(point u, point v) &#123; return u.x == v.x ? u.y &lt; v.y : u.x &lt; v.x; &#125;bool cmp2(point u, point v) &#123; return u.y &lt; v.y; &#125;db distance(point u, point v) &#123; return square(u.x - v.x) + square(u.y - v.y); &#125;db sol(int l, int r)&#123; if (l &gt;= r) &#123; return LLONG_MAX; &#125; else if (r == l + 1) &#123; return distance(input[l], input[r]); &#125; else &#123; int mid = (l + r) &gt;&gt; 1, midx = input[mid].x; db d = min(sol(l, mid), sol(mid + 1, r)); vector&lt;point&gt; left_right; for (int i = l; i &lt; r; i++) &#123; if (square(input[i].x - midx) &lt;= d) &#123; left_right.emplace_back(input[i]); &#125; &#125; int ct = left_right.size(); sort(left_right.begin(), left_right.end(), cmp2); for (int i = 0; i &lt; ct; i++) &#123; for(int j = i + 1; j &lt; ct; j++)&#123; if (square(left_right[i].y - left_right[j].y) &gt; d) &#123; break; &#125; d = min(d, distance(left_right[i],left_right[j])); &#125; &#125; return d; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; input.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; input[i].x &gt;&gt; input[i].y; &#125; sort(input.begin(), input.end(), cmp1); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3); cout &lt;&lt; sqrt(sol(0, n - 1)) &lt;&lt; endl; return 0;&#125; 生日纪念日&emsp;&emsp;输入某个人的生日，他想知道自己的一万天纪念日是哪一天。输入为三个整数，分别为年、月、日并且保证日期绝对合法，输出格式为”年-月-日“。 &emsp;&emsp;最暴力的想法就是直接写一个日期的类，自加一万次（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;struct date &#123; int YY; int MM; int DD; date(int _YY = 1979, int _MM = 4, int _DD = 16) &#123; YY = _YY; MM = _MM; DD = _DD; &#125; void operator++(int)&#123; if (MM == 2) &#123; if (DD &lt;= 27) &#123; DD++; &#125; else if (DD == 28) &#123; if ((YY % 4 == 0 &amp;&amp; YY % 100 != 0) || YY % 400 == 0) &#123; DD++; &#125; else &#123; DD = 1; MM = 3; &#125; &#125; else if (DD == 29) &#123; DD = 1; MM = 3; &#125; &#125; else if(MM == 1 || MM == 3 || MM == 5 || MM == 7 || MM == 8 || MM == 10 || MM ==12) &#123; if (DD &gt;= 31) &#123; DD = 1; if (MM == 12) &#123; MM = 1; YY++; &#125; else &#123; MM++; &#125; &#125; else &#123; DD++; &#125; &#125; else &#123; if (DD &gt;= 30) &#123; DD = 1; MM++; &#125; else &#123; DD++; &#125; &#125; &#125;&#125;;int main() &#123; date t; cin &gt;&gt; t.YY &gt;&gt; t.MM &gt;&gt; t.DD; for (int i = 1; i &lt;= 10000; i++) &#123; t++; &#125; cout &lt;&lt; t.YY &lt;&lt; &#x27;-&#x27; &lt;&lt; t.MM &lt;&lt; &#x27;-&#x27; &lt;&lt; t.DD &lt;&lt; endl; return 0;&#125; &emsp;&emsp;稍微美化一下（ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int days_in_months[13] = &#123; 0,31,28,31,30,31,30,31,31,30,31,30,31 &#125;;struct date &#123; int YY; int MM; int DD; void operator++(int)&#123; DD++; if (DD &gt; days_in_months[MM]) &#123; MM++; DD = 1; if (MM &gt; 12) &#123; YY++; MM = 1; &#125; &#125; &#125;&#125;;bool leap_year(int YY) &#123; return ((YY % 4 == 0 &amp;&amp; YY % 100 !=0) || (YY % 400 == 0));&#125;int main() &#123; date t; cin &gt;&gt; t.YY &gt;&gt; t.MM &gt;&gt; t.DD; for (int i = 1; i &lt;= 10000; i++) &#123; if (leap_year(t.YY)) &#123; days_in_months[2] = 29; &#125; else &#123; days_in_months[2] = 28; &#125; t++; &#125; cout &lt;&lt; t.YY &lt;&lt; &#x27;-&#x27; &lt;&lt; t.MM &lt;&lt; &#x27;-&#x27; &lt;&lt; t.DD &lt;&lt; endl; return 0;&#125; &emsp;&emsp;事实上，还可以使用ctime库来做（还是调库香 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#pragma warning(disable:4996)using namespace std;int main() &#123; struct tm d, * nd; int year, month, day; cin &gt;&gt; year &gt;&gt; month &gt;&gt; day; d.tm_year = year - 1900; //tm_year等于实际年份减去1900 d.tm_mon = month - 1; //tm_mon中0代表一月 d.tm_mday = day;//tm_mday取值范围是[1,31] d.tm_hour = 0; d.tm_min = 0; d.tm_sec = 0; time_t tt = mktime(&amp;d) + 10000 * 24 * 60 * 60;//将时间转换为自1970年1月1日以来持续时间的秒数，发生错误时返回-1 nd = gmtime(&amp;tt);//返回tm结构的格林尼治时间 cout &lt;&lt; nd-&gt;tm_year + 1900 &lt;&lt; &#x27;-&#x27; &lt;&lt; nd-&gt;tm_mon + 1 &lt;&lt; &#x27;-&#x27; &lt;&lt; nd-&gt;tm_mday &lt;&lt; endl; return 0;&#125; 清帝之惑之乾隆&emsp;&emsp;实际上就是高精度计算问题，只不过输出有各种的坑（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;class big_int &#123;private: vector&lt;int&gt; num;public: big_int(unsigned int _init) :num(vector&lt;int&gt;()) &#123; while (_init) &#123; num.emplace_back(_init % 10); _init /= 10; &#125; &#125; big_int(const string&amp; _init):num(vector&lt;int&gt;()) &#123; int n = _init.size(); for (int i = _init.size() - 1; i &gt;= 0; i--) &#123; num.emplace_back(_init[i] - &#x27;0&#x27;); &#125; &#125; big_int(const big_int &amp; ano):num(ano.num) &#123;&#125; big_int(const vector&lt;int&gt;&amp; ano) :num(ano) &#123;&#125; int operator[](size_t idx) &#123; if (idx &gt;= num.size()) &#123; exit(-1); &#125; else &#123; return num[idx]; &#125; &#125; big_int operator*(const big_int&amp; ano) const&#123; int n = num.size(), m = ano.num.size(); vector&lt;int&gt; ans(m + n, 0); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans[i + j] += num[i] * ano.num[j]; &#125; &#125; for (int i = m + n - 1; i &gt;= 0; i--) &#123; if (ans[i] == 0) &#123; ans.pop_back(); &#125; else &#123; break; &#125; &#125; int c = 0; for (size_t i = 0; i &lt; ans.size(); i++) &#123; ans[i] += c; c = ans[i] / 10; ans[i] %= 10; &#125; if (c &gt; 0) &#123; ans.emplace_back(c); &#125; return big_int(ans); &#125; big_int pow(int n) const&#123; big_int ans(1); for (int i = 1; i &lt;= n; i++) &#123; ans = ans * num; &#125; return ans; &#125; const size_t size() const&#123; return num.size(); &#125;&#125;;int main() &#123; string R, processed_R; int n; size_t dot_pos = 0; while (cin &gt;&gt; R &gt;&gt; n) &#123; processed_R.clear(); for (int i = R.size() - 1; i &gt;= 0; i--) &#123; if (R[i] == &#x27;0&#x27;) &#123; R.pop_back(); &#125; else &#123; break; &#125; &#125; for (size_t i = 0; i &lt; R.size(); i++) &#123; if (R[i] != &#x27;.&#x27;) &#123; processed_R.push_back(R[i]); &#125; else &#123; dot_pos = i; &#125; &#125; big_int ans = big_int(processed_R).pow(n); dot_pos = n * (R.size() - dot_pos - 1); if (dot_pos &gt;= ans.size()) &#123; cout &lt;&lt; &#x27;.&#x27;; for (int i = dot_pos - 1; i &gt;= 0; i--) &#123; if (i &gt;= ans.size()) &#123; cout &lt;&lt; 0; &#125; else &#123; cout &lt;&lt; ans[i]; &#125; &#125; &#125; else&#123; for (int i = ans.size() - 1; i &gt;= 0; i--) &#123; if (i == dot_pos) &#123; cout &lt;&lt; ans[i]; if (i != 0) &#123; cout &lt;&lt; &#x27;.&#x27;; &#125; &#125; else &#123; cout &lt;&lt; ans[i]; &#125; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 最小非负值&emsp;&emsp;输入一个自然数$n(n&lt; 10^{1000})$，表示$1$到$n$共$n$个自然数排成一列，你要在每一个数前添上$+$或$-$,要使得添加符号后这个代数式的值最小且非负。 &emsp;&emsp;任意四个连续的自然数我们都可以让其和为$0$，因此题设要求的数列其实是一个周期数列。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int a; if (s.length() == 1) &#123; a = s[0] - &#x27;0&#x27;; &#125; else &#123; a = (s[s.length() - 1] - &#x27;0&#x27;) * 10 + s[s.length() - 2] - &#x27;0&#x27;; &#125; if (a % 4 == 1 || a % 4 == 2) &#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125; 求二叉树的先序序列&emsp;&emsp;已知中序和后序序列，求先序序列（其实数据结构里面已经学过一遍了，但是我忘了怎么写，回来复习一下 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;string in_order, post_order;void pre_order(int in_order_left, int in_order_right, int post_order_left, int post_order_right)&#123; if (in_order_left == in_order_right) &#123; return; &#125; int cur_root = -1; for (int i = 0; i &lt; in_order_right; i++) &#123; if (in_order[i] == post_order[post_order_right - 1]) &#123; cur_root = i;//中序遍历序列里根的位置 cout &lt;&lt; in_order[cur_root]; break; &#125; &#125; pre_order(in_order_left, cur_root, post_order_left, post_order_left + cur_root - in_order_left); pre_order(cur_root + 1, in_order_right, post_order_left + cur_root - in_order_left, post_order_right - 1);&#125;int main()&#123; cin &gt;&gt; in_order &gt;&gt; post_order; pre_order(0, in_order.size(), 0, post_order.size()); return 0;&#125; 最小差距&emsp;&emsp;给定一些不同的一位数字，你可以从这些数字中选择若干个，并将它们按一定顺序排列，组成一个整数，把剩下的数字按一定顺序排列，组成另一个整数。组成的整数不能以0开头（除非这个整数只有1位）。&emsp;&emsp;给定$6$个数字，$0,1,2,4,6,7$，你可以用它们组成一对数$10$和$2467$，当然，还可以组成其他的很多对数，$204$和$176$。这些对数中两个数差的绝对值最小的是$204$和$176$，为$28$。 &emsp;给定$N$个不同的$0$~$9$之间的数字，请你求出用这些数字组成的每对数中，差的绝对值最小的一对（或多对）数的绝对值是多少？ &emsp;&emsp;输入包括$(2T+1)$行，第一行包括一个数 $T(T≤1000)$，为测试数据的组数；接下来每组数据包括两行，第一行为一个数 $N(2≤N≤10)$， 表示数字的个数。下面一行为 N 个不同的一位数字。 &emsp;&emsp;一道贪心算法的题目，需要分奇数和偶数两种情况进行讨论（ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;int minDiff(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (nums.size() == 2) &#123; return nums[1] - nums[0]; &#125; else &#123; if (n % 2 == 0) &#123; int last = (nums[0] == 0 ? nums[2] - nums[1] : nums[1] - nums[0]); int ans = INT_MAX; for (int i = (nums[0] == 0 ? 2 : 1); i &lt; n; i++) &#123; if (nums[i] - nums[i - 1] &lt;= last) &#123;//进行枚举 last = nums[i] - nums[i - 1]; int big = nums[i], small = nums[i - 1]; vector&lt;bool&gt; visited(n, false); visited[i] = visited[i - 1] = true; int r = n / 2 - 1; int j = n - 1; while (r) &#123; if (!visited[j]) &#123; small = small * 10 + nums[j]; r--; visited[j] = true; &#125; j--; &#125; for (j = 0; j &lt; n; j++) &#123; if (!visited[j]) &#123; big = big * 10 + nums[j]; &#125; &#125; ans = min(ans, big - small); &#125; &#125; return ans; &#125; else &#123; int big = (nums[0] == 0 ? nums[1] : nums[0]), small = 0; vector&lt;bool&gt; visited(n, false); visited[nums[0] == 0 ? 1 : 0] = true; int r = (n - 1) / 2; int j = 0; while (r) &#123; if (!visited[j]) &#123; r--; visited[j] = true; big = big * 10 + nums[j]; &#125; j++; &#125; for (j = n - 1; j &gt;= 0; j--) &#123; if (!visited[j]) &#123; small = small * 10 + nums[j]; &#125; &#125; return big - small; &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int i = 0; i &lt; T; i++) &#123; int N; cin &gt;&gt; N; vector&lt;int&gt; nums(N); for (auto&amp; i : nums) &#123; cin &gt;&gt; i; &#125; sort(nums.begin(), nums.end(), less&lt;int&gt;()); cout &lt;&lt; minDiff(nums) &lt;&lt; endl; &#125; return 0;&#125; 密码破解&emsp;&emsp;已知数列数列 $12345678910111213…$ ，输入是一个数$n$， 表示求数列的第$n$ 位。 &emsp;&emsp;注意$i$位数共有$9*10^{i-1}$个。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;int main() &#123; int n; cin &gt;&gt; n; if (n &lt;= 9) &#123; cout &lt;&lt; n &lt;&lt; endl; return 0; &#125; else &#123; ll left = 1, right = 10, base = 9;//base不是10 int digit = 2; for (int i = 2; i &lt;= 10; i++) &#123; base *= 10; left = right; right = left + base * i; if (left &lt;= n &amp;&amp; n &lt; right) &#123; digit = i; break; &#125; &#125; int num = base / 10 + (n - left) / digit; int c = (n - left) / digit + 1; int k = (digit - 1) - (n - (left + (c - 1) * digit)); if (k == 0) &#123; k = digit - 1; &#125; while (k) &#123; num /= 10; k--; &#125; cout &lt;&lt; num % 10 &lt;&lt; endl; &#125; return 0;&#125; 参考资料求平面内最近点对 https://www.cnblogs.com/forward777/p/10360073.html 作者链接","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法分析与设计第五次作业题题解","slug":"算法分析与设计第五次作业题题解","date":"2021-11-09T09:08:53.000Z","updated":"2022-09-13T11:54:04.062Z","comments":true,"path":"2021/11/09/算法分析与设计第五次作业题题解/","link":"","permalink":"http://example.com/2021/11/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"&emsp;&emsp;我是何德何能来学了算法QAQ","text":"&emsp;&emsp;我是何德何能来学了算法QAQ Problem A题目描述&emsp;&emsp;给定$1×N$的单行矩阵，矩阵每个元素都是$-127$到$127$之间的整数。请找到一个连续子矩阵，使得其元素之和最大。例如行矩阵$[0,-2,-7,0,-2,11,-4,13,-5,-2]$，最大子矩阵和为$11+(-4)+13=20$。 输入数据&emsp;&emsp;多组测试数据，每组数据的第一行为一个整数$N(N \\leq 100)$，第二行包含$N$个整数，为行矩阵的$N$个元素，每个元素介于$-127$到$127$之间。 输出数据&emsp;&emsp;最大子矩阵之和，每组对应一行。 样例输入12100 -2 -7 0 -2 11 -4 13 -5 -2 样例输出120 题目分析&emsp;&emsp;求最大连续子序列之和的题目 题解1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int N; while (cin &gt;&gt; N) &#123; vector&lt;int&gt; nums(N); for (auto&amp; i : nums) &#123; cin &gt;&gt; i; &#125; vector&lt;int&gt; dp(N, INT_MIN); int ans = INT_MIN; dp[0] = nums[0]; for (int i = 1; i &lt; N; i++) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); ans = max(ans, dp[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem B题目描述&emsp;&emsp;给定$N×N$矩阵，矩阵元素都是$-127$到$127$之间的整数。请找到一个子矩阵，使得其元素之和最大。例如给定$4*4$矩阵$[[0,-2,-7,0],[9,2,-6,2],[-4,1,-4,1],[-1,8,0,-2]]$最大子矩阵为$[[9,2],[-4,1],[-1,8]]$最大子矩阵和为$9+2+(-4)+1+(-1)+8= 15$。 输入数据&emsp;&emsp;多组测试数据，每组测试数据的第一行整数$N (N \\leq 100)$。接下来N行元素，每行N个元素，每个元素介于$-127$到$127$之间。 输出数据&emsp;&emsp;最大子矩阵元素之和，每组测试数据对应一行。 样例输入1234540 -2 -7 09 2 -6 2-4 1 -4 1-1 8 0 -2 样例输出115 题目分析&emsp;&emsp;思想与A题类似，本题对输入的矩阵进行列的求和，然后用$i$和$j$对行进行遍历$(1 \\leq i \\leq j \\leq N)$，然后对于确定的$i$和$j$，使用$k$进行列的遍历，最后求出最大的结果即可。 题解123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int N; ios::sync_with_stdio(false); cin.tie(0); while (cin &gt;&gt; N) &#123; vector&lt;vector&lt;int&gt;&gt; nums(N + 1, vector&lt;int&gt;(N + 1)); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(N + 1, INT_MIN)); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; dp[i][j] = dp[i - 1][j] + nums[i][j]; &#125; &#125; int ans = nums[0][0]; for (int i = 1; i &lt;= N; i++) &#123; for (int j = i; j &lt;= N; j++) &#123; int _sum = 0; for (int k = 1; k &lt;= N; k++) &#123; _sum = max(dp[j][k] - dp[i - 1][k] + _sum, dp[j][k] - dp[i - 1][k]); ans = max(ans, _sum); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem C题目描述&emsp;&emsp;作为一个有很多游戏想买但囊中羞涩的大学生，小明决定在这个暑假开始打工赚钱。经过一段时间的寻找，他一共找到了$n$个打工的招聘广告，其中第$i$个打工的日期从$l_i$开始，到$r_i$为止，一共付给他$c_i$元钱。因为这些打工的时间都相互冲突，所以同一天小明最多参加一个打工，并且一个打工一旦开始，就必须一直工作到结束，不能中途退出。现在小明想要知道，这个暑假他打工最多能得到多少钱？ 输入数据&emsp;&emsp;第一行一个整数$n(1 \\leq n \\leq 1000000)$，表示招聘广告的数量。 接下来一共$n$行，每行3个整数$l_i,r_i,c_i(1 \\leq l_i ≤ r_i \\leq 1000000,1 \\leq c_i \\leq 1000000000)$，表示打工的开始时间，结束时间和报酬。 输出数据&emsp;&emsp;一行一个整数$k$，表示小明最多能够得到的钱数。 样例输入123431 2 33 4 32 3 5 样例输出16 题目分析&emsp;&emsp;这题目的思路可以从LintCode 515题中得到一些启发。如果采用动态规划的话，对于$n$项工作而言，每一项工作只有选和不选两种情况，设$dp[i][0]、dp[i][1]$为第$i$件工作接受或者不接受的条件下所获得的最大酬劳，那么最终的答案为$max(dp[n][0],dp[n][1])$。&emsp;&emsp;但是本题对于每项工作的选择是有后效性的，必须要满足时间的约束条件；而要使得获得的薪酬最大，应该尽可能多做一些工作。根据会场安排的问题可以想到应该按照工作的结束时间进行排序。但是我还不会会场安排问题，那就马上从零开始学习吧（ 会场安排问题&emsp;&emsp;假设某社团某一天要组织$𝑛$个活动$𝐸=\\begin{Bmatrix}1, 2,⋯,n\\end{Bmatrix}$，其中每个活动都要求使用同一礼堂，而且在同一时间内只有一个活动能使用这个礼堂。每个活动$i$都有一个要求使用礼堂的起始时间$s_i$和结束时间$f_i$，且有$s_i&lt;f_i$。如果选择了活动$i$，则它在半开时间区间$[s_i,f_i)$内占用资源。若区间$[s_i,f_i)$与区间$[s_j,f_j)$不相交，则称活动$i$与活动$j$是相容的。现在给定𝑛个活动的开始时间和结束时间，请设计一个活动安排方案，使得安排的相容活动数目最多。&emsp;&emsp;分析题目，要解决这个问题可以使用二进制枚举，但是时间复杂度是$O(2^n)$，不可以接受，因此换一个思路。使用贪心的策略大致有三个思路：(1)按照占用时间短优先；（2）按照开始时间早优先；（3）按照结束时间早优先。对于前两种情况，都可以找出反例证明贪心算法不成立：对于（1），反例为$[0,10),[9,14),[13,17)$，按照占用时间短优先的话应该先安排$[9,14)$，而最优安排显然是选另外两个；对于(2)，反例为$[0,10),[2,5),[6,7)$，显然。那么如何证明按照结束时间早的贪心策略是正确的呢？&emsp;&emsp;将集合$S$中的活动按照结束时间递增顺序排列，即记为$S=\\begin{Bmatrix}1,2,⋯,n \\end{Bmatrix}$；假设$A=\\begin{Bmatrix}j_1,j_2,…,j_m \\end{Bmatrix}$是$S$的一个最优解，其中活动也按照结束时间递增顺序排列。不妨设$B=\\begin{Bmatrix}A_1,A_2,⋯,A_c \\end{Bmatrix}$为该问题的最佳解构成的集合，显然对于任意一个有限的会场安排问题，总是存在最优解。现在需要证明对于贪心算法得出的这样的解$A$总满足$A \\in B$。&emsp;&emsp;设$k=1$时选择活动为$\\begin{Bmatrix}1\\end{Bmatrix}$，需要证明存在一个最优解包含$\\begin{Bmatrix}1\\end{Bmatrix}$，若$j_1=1$，那么最优解包含了$\\begin{Bmatrix}1\\end{Bmatrix}$；否则，用活动$1$替换最优解中的$j_1$，显然$A’=\\begin{Bmatrix} 1,j_2,…,j_m \\end{Bmatrix}$也是一个相容的活动集合（不要忘记$1$是结束时间最早的活动），也是一个最优的活动安排。&emsp;&emsp;当$k&gt;1$时，设$\\begin{Bmatrix}i_1,1_2,…,i_k \\end{Bmatrix}$是贪心算法前$k$步顺序选择的活动，那么存在一个最优解 : $A=\\begin{Bmatrix}i_1=1,1_2,…,i_k \\end{Bmatrix} \\bigcup B$。假设$S’$是$S$中与$\\begin{Bmatrix} i_1, i_2,⋯,i_k \\end{Bmatrix}$相容的活动，即$𝑆’=\\begin{Bmatrix} j | s[j]≥𝑓[i_k], j \\in 𝑆 \\end{Bmatrix} $那么$B$是$S^′$的一个最优解。 再用刚才关于活动1的替换等价性证明可知$𝑆′$ 的结束时间最早的活动$𝑖_{𝑘+1}$包含在某一个最优解$B′$中，则可以构造原问题的一个最优解为$A’=\\begin{Bmatrix} i_1=1,1_2,…,i_k,i_{k+1} \\end{Bmatrix} \\bigcup (B - \\begin{Bmatrix} i_{k+1} \\end{Bmatrix})$。&emsp;&emsp;最终的代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;struct activity &#123; int start; int end; bool operator&lt;(const activity&amp; b) const&#123; return end &lt; b.end; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; if (n &lt; 1) &#123; return 0; &#125; vector&lt;activity&gt; act(n); for (auto&amp; i : act) &#123; cin &gt;&gt; i.start &gt;&gt; i.end; &#125; sort(act.begin(), act.end()); int ans = 1;//选择第一个活动 int last_selected = 0; for (int i = 1; i &lt; n; i++) &#123; if (act[i].start &gt;= act[last_selected].end) &#123; last_selected = i; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;/*测试用例1（答案为2）30 102 57 9测试用例2（答案为2）30 43 54 9*/ &emsp;&emsp;网上查找了一些代码后发现本题或许可以使用树状数组来解决，那就马上从零开始学习吧（ 树状数组&emsp;&emsp;树状数组可以解决大部分基于区间上的更新以及求和问题。设结点编号为$x$，那么该节点维护的值为$(x-lowbit(x),x]$的和，其中$lowbit(x)=x^k$，其中$k$为$x$最低位1所在的二进制位。这种情况下要求树状数组的编号范围是$[1,2^n]$。&emsp;&emsp;$lowbit$值一般使用$x$&amp;$-x$的方式计算，这一点利用了补码的运算性质，证略。&emsp;&emsp;本题目使用树状数组进行了工作结束日期的统计。&emsp;&emsp;最后改完代码后发现用vector空间会爆掉，所以直接使用空间足够大的数组即可。 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define MAX_SIZE 1000005//#define comparator(T, E) [](T&amp; a, T&amp; b) &#123; return a.E &lt; b.E; &#125;using ll = long long;using namespace std;struct adver &#123; int start; int end; int income;&#125;;ll dp[MAX_SIZE][2];ll temp[MAX_SIZE];adver adver_info[MAX_SIZE];int lowbit(int i) &#123; return i &amp; (-i);&#125;int sum(int i) &#123;//统计结束日期小于i的工作数量 int s = 0; while (i &gt; 0) &#123; s += temp[i]; i -= lowbit(i); &#125; return s;&#125;void add(int i) &#123;//添加一个结束日期为i的工作 if (i &gt; 0)&#123; while (i &lt; MAX_SIZE) &#123; temp[i]++; i += lowbit(i); &#125; &#125;&#125;bool cmp(adver&amp; a, adver&amp; b) &#123;//排序依据 return a.end &lt; b.end;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin &gt;&gt; n; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; adver_info[i].start &gt;&gt; adver_info[i].end &gt;&gt; adver_info[i].income; &#125; sort(adver_info + 1, adver_info + n + 1, cmp); //sort(adver_info + 1, adver_info + n + 1, [](adver&amp; a, adver&amp; b) &#123; return a.end &lt; b.end; &#125;); //sort(adver_info + 1, adver_info + n + 1, comparator(adver, end)); for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); ll s = sum(adver_info[i].start - 1); dp[i][1] = max(dp[s][0], dp[s][1]) + adver_info[i].income; add(adver_info[i].end); &#125; ans = max(dp[n][1], dp[n][0]); cout &lt;&lt; ans &lt;&lt; endl;&#125; Problem D题目描述&emsp;&emsp;给定一个信封，最多只允许粘贴$N$张邮票，计算在给定$M（N+M \\leq 10）$种邮票的情况下（假定所有的邮票数量都足够）,如何设计邮票的面值，能得到最大$max$ ，使得$[1,max]$的每一个邮资值都能得到？&emsp;&emsp;例如，$N=3，M＝2$，如果面值分别为1分、4分，则在1分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）：如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当$N=3，M＝2$时，7分就是可以得到连续的邮资最大值，所以$MAX=7$，面值分别为1分、3分。 &emsp;&emsp;样例输入：共一行，两个整数，分表为N与M的值。 输入数据&emsp;&emsp;一行，分别为$N,M$。 输出数据 两行。第一行为$m$种邮票的面值，按升序排列，各数之间用一个空格隔开。第二行为最大值，格式为：”MAX=%d”。 样例输入13 2 样例输出121 3MAX=7 题目分析&emsp;&emsp;对于已知邮票面值的情况下，可以使用动态规划求出最大的面值；要求出邮票的面值，可以使用深度优先搜索算法，每次在增加邮票面值时，所需要枚举的空间为上次求得的最大值+1到上一个枚举出来的邮票面值+1，上界很显然，由于邮票面值是要求递增的，因此在求的时候采用递增的策略即可，因此下界选择上一个枚举出来的邮票面值+1。 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int temp_denomination[15];int ans_denomination[15];//1~m储存结果int n, m;//n为最多可贴的邮票数；m为邮票种数int MAX = 0;int calculate_MAX(int cur_num) &#123;//计算num个面值的邮票的MAX if (cur_num == 0) &#123; return 0; &#125; else &#123;//有点像lintcode749 vector&lt;int&gt; dp(1001, INT_MAX); dp[0] = 0; int i = 0;//面值为1 3 输入为3 2 if (temp_denomination[1] == 1 &amp;&amp; temp_denomination[2] == 3) &#123; system(&quot;pause&quot;); &#125; while (dp[i] &lt;= n) &#123;//dp[i]总价为i分且面值由cur_num种时、所需要的邮票张数 i++; for (int j = 1; j &lt;= cur_num &amp;&amp; temp_denomination[j] &lt;= i; j++) &#123; dp[i] = min(dp[i - temp_denomination[j]] + 1, dp[i]); &#125; &#125; return i - 1; &#125;&#125;void dfs(int cur_num) &#123; if (cur_num == m) &#123;//深度优先搜索的最大深度为m，即只需要求出m个面值 int c = calculate_MAX(m);//利用动态规划计算MAX if (c &gt; MAX) &#123;//计算当前所得的MAX值，如果比之前的大就更新MAX与面值 for (int i = 1; i &lt;= m; i++) &#123; ans_denomination[i] = temp_denomination[i]; &#125; MAX = c; &#125; return; &#125; else &#123;//没有达到最大深度 int temp = calculate_MAX(cur_num);//计算当前所得的MAX值 for (int i = temp + 1; i &gt;= temp_denomination[cur_num] + 1; i--) &#123;//贪心算法的部分 temp_denomination[cur_num + 1] = i;//往下续，小面值已经不够用了，因此采用temp_MAX + 1 dfs(cur_num + 1); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; dfs(0); cout &lt;&lt; ans_denomination[1]; for (int i = 2; i &lt;= m; i++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; ans_denomination[i]; &#125; cout &lt;&lt; endl &lt;&lt; &quot;MAX=&quot; &lt;&lt; MAX &lt;&lt; endl; return 0;&#125; Problem E题目描述&emsp;&emsp;某国为了防御敌国的导弹袭击，研发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试验阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入数据&emsp;&emsp;输入数据只有一行，该行包含若干个数据，之间用半角逗号隔开，表示导弹依次飞来的高度（导弹最多有$20$枚，其高度为不大于$3×103$的正整数）。 输出数据&emsp;&emsp;输出数据只有一行，该行包含两个数据，之间用半角逗号隔开。第一个数据表示这套系统最多能拦截的导弹数；第二个数据表示若要拦截所有导弹至少要再添加多少套这样的系统。 样例输入1389,207,155,300,299,170,158,65 样例输出16,1 题目分析题解1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int h; char c; vector&lt;int&gt; height; while (1) &#123; cin &gt;&gt; h; c = getchar(); height.emplace_back(h); if (c == &#x27;\\n&#x27;) &#123; break; &#125; &#125; int n = height.size(); vector&lt;int&gt; dp(n, 1); int ans1 = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (height[i] &lt; height[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); ans1 = max(ans1, dp[i]); &#125; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; &#x27;,&#x27;; for (auto&amp; i : dp) &#123; i = 1; &#125; int ans2 = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (height[i] &gt; height[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); ans2 = max(ans2, dp[i]); &#125; &#125; &#125; cout &lt;&lt; ans2 - 1 &lt;&lt; endl; return 0;&#125; 参考资料树状数组详解 https://www.cnblogs.com/xenny/p/9739600.html 作者链接小明的打工计划 https://blog.csdn.net/zhuibushixi/article/details/109645759 作者链接","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"单调栈学习","slug":"单调栈学习","date":"2021-10-25T13:07:20.000Z","updated":"2022-09-13T11:49:15.832Z","comments":true,"path":"2021/10/25/单调栈学习/","link":"","permalink":"http://example.com/2021/10/25/%E5%8D%95%E8%B0%83%E6%A0%88%E5%AD%A6%E4%B9%A0/","excerpt":"&emsp;&emsp;单调栈可以用来降低一些查找问题的时间复杂度。","text":"&emsp;&emsp;单调栈可以用来降低一些查找问题的时间复杂度。 lintcode 1316&emsp;&emsp;本题对于算法的时间复杂度要求较高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: /** * @param arr: the arr * @return: the sum of the luck number */ static bool pairComByFirst(pair&lt;int, int&gt;a, pair&lt;int, int&gt;b) &#123; return a.first &lt; b.first; &#125; int luckNumber(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); int ans = 0; vector&lt;pair&lt;int, int&gt;&gt; a; for (int i = 0; i &lt; n; i++) &#123; a.emplace_back(pair&lt;int, int&gt;(arr[i], i)); &#125; sort(a.begin(), a.end(), pairComByFirst); vector&lt;int&gt; l(n, 0), r(n, 0); stack&lt;pair&lt;int, int&gt;&gt; s; pair&lt;int, int&gt; fir(0, 0); for (int i = 0; i &lt; n; i++) &#123; while (!s.empty()) &#123; fir = s.top(); if (a[i].second &lt; fir.second) &#123; l[fir.second] = a[i].first; s.pop(); &#125; else &#123; break; &#125; &#125; s.push(a[i]); &#125; while (!s.empty()) &#123; s.pop(); &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; while (!s.empty()) &#123; fir = s.top(); if (a[i].second &gt; fir.second) &#123; r[fir.second] = a[i].first; s.pop(); &#125; else &#123; break; &#125; &#125; s.push(a[i]); &#125; for (int i = 1; i &lt; n - 1; i++) &#123; if (l[i] &amp;&amp; r[i] &amp;&amp; l[i] % r[i] == 0) &#123; ans++; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法分析与设计第四次作业题解","slug":"算法分析与设计第四次作业题解","date":"2021-10-24T15:05:07.000Z","updated":"2022-09-13T11:54:01.200Z","comments":true,"path":"2021/10/24/算法分析与设计第四次作业题解/","link":"","permalink":"http://example.com/2021/10/24/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E8%A7%A3/","excerpt":"&emsp;&emsp;题目发布于2021年10月25日下午5点。","text":"&emsp;&emsp;题目发布于2021年10月25日下午5点。 &emsp;&emsp;本次题目主要都是动态规划，A题和B题都是换汤不换药的0-1背包问题，C题是求最大递增、递减子序列，D题是很基础的路径问题，E题也很易得递推方程，这次直接贴代码… Problem A12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int T, M; cin &gt;&gt; T &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(T + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123;//最好外层是物品件数 for (int j = T; j &gt;= cost[i]; j--) &#123;//内层是cost，此时顺向、逆向枚举均可 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[M][T] &lt;&lt; endl; return 0;&#125; Problem B1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int V, M; cin &gt;&gt; V &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i]; value[i] = cost[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(V + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123; for (int j = V; j &gt;= cost[i]; j--) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i]] + value[i]); &#125; &#125; cout &lt;&lt; V - dp[M][V] &lt;&lt; endl; return 0;&#125; &emsp;&emsp;此外，0-1背包问题还可以进行空间的优化。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int T, M; cin &gt;&gt; T &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i]; &#125; vector&lt;int&gt;dp(T + 1, 0); for (int i = 1; i &lt;= M; i++) &#123; for (int j = T; j &gt;= cost[i]; j--) &#123;//注意压缩空间后必须逆向枚举j dp[j] = max(dp[j], dp[j - cost[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; return 0;&#125; &emsp;&emsp;多重背包问题、完全背包问题与0-1背包问题类似。&emsp;&emsp;多重背包问题代码如下。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int V, M; cin &gt;&gt;V &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1), nums(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i] &gt;&gt; nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(V + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123; for (int j = cost[i]; j &lt;= V; j++) &#123; for (int k = 0; j &gt;= k * cost[i] &amp;&amp; k &lt;= nums[i]; k++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * cost[i]] + k * value[i]); &#125; &#125; &#125; cout &lt;&lt; dp[M][V] &lt;&lt; endl; return 0;&#125; &emsp;&emsp;完全背包问题代码如下。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int V, M; cin &gt;&gt;V &gt;&gt; M; vector&lt;int&gt;cost(M + 1), value(M + 1); for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; cost[i] &gt;&gt; value[i]; &#125; vector&lt;vector&lt;int&gt;&gt;dp(M + 1, vector&lt;int&gt;(V + 1, 0)); for (int i = 1; i &lt;= M; i++) &#123; for (int j = cost[i]; j &lt;= V; j++) &#123; for (int k = 0; j &gt;= k * cost[i]; k++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * cost[i]] + k * value[i]); &#125; &#125; &#125; /*或者可以这样 for (int i = 1; i &lt;= M; i++) &#123; for (int j = cost[i]; j &lt;= V; j++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - cost[i]] + value[i]); //与0-1背包问题的唯一不同就是后一项中dp那部分的下标由(i - 1, j - cost[i])变为了(i, j - cost[i]) &#125; &#125; */ cout &lt;&lt; dp[M][V] &lt;&lt; endl; return 0;&#125; Problem C&emsp;&emsp;$N$位同学站成一排，音乐老师要请其中的$(N-K)$位同学出列，使得剩下的$K$位同学排成合唱队形。&emsp;&emsp;合唱队形是指这样的一种队形：设$K$位同学从左到右依次编号为$1,2,…,K$，他们的身高分别为$T_1,T_2,…,T_K$，则他们的身高满足$T_1&lt;…&lt;T_i$且$T_i&gt; T_{i+1}&gt;…&gt;T_K(1 \\leq i \\leq K)$。&emsp;&emsp;你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int N; cin &gt;&gt; N; int K = 0; vector&lt;int&gt; T(1, -1); //第i位同学左侧最长单调增子序列、右侧最长单调减子序列的长度 for (int i = 0; i &lt; N; i++) &#123; int Ti; cin &gt;&gt; Ti; T.emplace_back(Ti); &#125; vector&lt;int&gt; dp_l(N + 1, 0), dp_r(N + 1, 0); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; if (T[i] &gt; T[j]) &#123; dp_l[i] = max(dp_l[i], dp_l[j] + 1); &#125; &#125; &#125; for (int i = N; i &gt;= 1; i--) &#123; for (int j = N; j &gt; i; j--) &#123; if (T[i] &gt; T[j]) &#123; dp_r[i] = max(dp_r[i], dp_r[j] + 1); &#125; &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; K = max(K, dp_l[i] + dp_r[i] + 1); &#125; cout &lt;&lt; N - K &lt;&lt; endl; return 0;&#125; Problem D123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int m, n, x, y;bool valid(int i, int j)&#123; return !((i == x &amp;&amp; j == y) || ((x - i) * (x - i) + (y - j) * (y - j) == 5));&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;//卒要从(0, 0)到(n, m)，马在(x, y)处不会动，马所能一步到达的位置和马自身的位置设定为不可达，卒只能向右或向下走，每次一步 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); dp[0][0] = valid(0, 0) ? 1 : 0; for(int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; if (i + j &amp;&amp; valid(i, j)) &#123; if (i == 0) &#123; dp[i][j] += dp[i][j - 1]; &#125; else if (j == 0) &#123; dp[i][j] += dp[i - 1][j]; &#125; else &#123; dp[i][j] += dp[i - 1][j]; dp[i][j] += dp[i][j - 1]; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl; return 0;&#125; Problem E123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m;//n人传球m次，只能传给编号相邻的同学，从1号开始发球，求有多少种传球方法最后球能回到1号同学手里；注意1-&gt;2算一次传球 vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); dp[0][1] = 1;//dp[i][j]代表第i次传到编号为j的同学处的方法数 for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int l = j &gt; 1 ? j - 1 : n; int r = j &lt; n ? j + 1 : 1; dp[i][j] = dp[i - 1][l] + dp[i - 1][r]; &#125; &#125; cout &lt;&lt; dp[m][1] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"排序算法","slug":"排序算法","date":"2021-10-14T02:32:29.000Z","updated":"2022-09-13T11:51:57.865Z","comments":true,"path":"2021/10/14/排序算法/","link":"","permalink":"http://example.com/2021/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"&emsp;&emsp;赶紧复习一下排序算法（","text":"&emsp;&emsp;赶紧复习一下排序算法（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167class my_sort &#123;public: /*交换排序：冒泡排序、快速排序*/ void bubble_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[i] &gt; arr[j]) &#123; swap(arr[i], arr[j]); &#125; &#125; &#125; &#125; void quick_sort(vector&lt;int&gt;&amp; arr) &#123; _quick_sort_(arr, 0, arr.size() - 1); &#125; /*二路归并排序*/ void merge_sort(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; temp(arr.size()); merge(temp, arr, 0, arr.size()); &#125; /*插入排序：（折半、简单）插入排序、希尔排序*/ void shell_sort(vector&lt;int&gt;&amp; arr) &#123; for (int seg = arr.size(); seg &gt; 0; seg /= 2) &#123; single_shell_sort(arr, seg); &#125; &#125; void insertion_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = 1; i &lt; n; i++) &#123; //for (int j = i - 1; j &gt;= 0; j--) &#123; // if (arr[j] &gt; arr[j + 1]) &#123; // swap(arr[j], arr[j + 1]); // &#125; //&#125; int l = 0, r = i; while (l &lt; r) &#123;//[0,i) int mid = l + (r - l) / 2; if (arr[mid] &lt; arr[i]) &#123; l = mid + 1; &#125; else &#123; r = mid; &#125; &#125; for (int j = i; j &gt;= l + 1; j--) &#123; swap(arr[j], arr[j - 1]); &#125; &#125; &#125; /*选择排序：简单选择排序、堆排序*/ void heap_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; heap_adjust(arr, i, n - 1); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; swap(arr[0], arr[i]); heap_adjust(arr, 0, i - 1); &#125; &#125; void selection_sort(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; swap(arr[i], arr[find_min(arr, i)]); &#125; &#125;private: void single_shell_sort(vector&lt;int&gt;&amp; arr, int dk) &#123; int n = arr.size(); for (int i = dk; i &lt; n; i++) &#123; if (arr[i] &lt; arr[i - dk]) &#123; int tmp = arr[i]; int j = 0; for (j = i - dk; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j -= dk) &#123; arr[j + dk] = arr[j]; &#125; arr[j + dk] = tmp; &#125; &#125; &#125; void heap_adjust(vector&lt;int&gt;&amp; arr, int start, int end) &#123; int dad = start; int son = dad * 2 + 1; while (son &lt;= end) &#123; if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) &#123; son++; &#125; if (arr[son] &lt; arr[dad]) &#123;//son比dad、son+1都小 return; &#125; else &#123; swap(arr[dad], arr[son]); dad = son; son = dad * 2 + 1; &#125; &#125; &#125; void _quick_sort_(vector&lt;int&gt;&amp; arr, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; else &#123; int i = start, j = end; int tmp = arr[start]; while (i &lt; j) &#123; for (; i &lt; j &amp;&amp; tmp &lt; arr[j];j--) &#123;&#125; if (i &lt; j) &#123; swap(arr[i], arr[j]); i++; &#125; for (; i &lt; j &amp;&amp; arr[i] &lt; tmp ;i++) &#123;&#125; if (i &lt; j) &#123; swap(arr[i], arr[j]); j--; &#125; &#125; _quick_sort_(arr, start, i - 1); _quick_sort_(arr, i + 1, end); &#125; &#125; int adjust_arr(vector&lt;int&gt;&amp; arr, int l, int r) &#123; int i = l + 1, j = r - 1, key = arr[l]; while (i &lt; j) &#123; for(; arr[i] &lt;= key &amp;&amp; i &lt; j; i++) &#123;&#125; swap(arr[l], arr[i]); for(; arr[j] &gt;= key &amp;&amp; i &lt; j; j--) &#123;&#125; swap(arr[l], arr[j]); &#125; return i; &#125; void merge(vector&lt;int&gt;&amp; temp, vector&lt;int&gt;&amp; arr, int l, int r) &#123;//[l,r) if (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; merge(temp, arr, l, mid); merge(temp, arr, mid, r); int i = l, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; r) &#123; temp[k] = (arr[i] &lt; arr[j] ? arr[i++] : arr[j++]); k++; &#125; while (j &lt; r) &#123; temp[k++] = arr[j++]; &#125; while (i &lt; mid) &#123; temp[k++] = arr[i++]; &#125; for (int i = 0; i &lt; k; i++) &#123; arr[i + l] = temp[i]; &#125; &#125; &#125; int find_min(vector&lt;int&gt;&amp; arr, int cur_index) &#123;//选择序号[i,n)中的最小值 int i = cur_index, n = arr.size(); for (int j = i; j &lt; n; j++) &#123; i = (arr[j] &lt; arr[i] ? j : i); &#125; return i; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"二分查找学习","slug":"二分查找学习","date":"2021-10-11T09:41:26.000Z","updated":"2022-09-13T11:49:58.907Z","comments":true,"path":"2021/10/11/二分查找学习/","link":"","permalink":"http://example.com/2021/10/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"&emsp;&emsp;折半查找的思想十分简单，其效率也很高，时间复杂度为对数级的$O(log(n))$；但是要将其运用到实际程序中却并不容易，需要考虑很多细节上的问题。 在数组中查找&emsp;&emsp;设$arr$为一个数组，$target$为目标值。假设$arr$已经是升序排序过的并且下文中默认这个条件。取$arr$的长度为$L$。 查找值&emsp;&emsp;假定需要在$arr$中查找是否存在等于$target$的元素，如果查找到了则返回对应元素的下标；否则返回$-1$。&emsp;&emsp;对于这种情况，返回结果的范围是${-1} \\bigcup [0, L-1]$，因此取初始区间$[l, r]$为$[0,L-1]$，若找到$target$直接返回$mid$，否则一直查找，最后返回$-1$即可。值得注意还有结束条件，由于查找的有效结果是一个值，因此要保证区间$[0,L-1]$中没有遗漏的值，那么必须保证没有找到的条件下，退出时的区间$[l,r]$满足$l &gt; r$，可以得出循环条件为$l \\leqslant r$。 12345678910111213141516int findVal(vector&lt;int&gt; arr, int target) &#123; int l = 0, r = arr.size() - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (arr[mid] == target) &#123; return mid; &#125; else if (arr[mid] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return -1;&#125; 查找界&emsp;&emsp;假定要查找$arr$中$target$的上确界，并且要求如果所有元素均大于等于$target$则返回$0$，如果所有元素均小于等于$target$则返回$L$。&emsp;&emsp;对于这种情况，返回结果的范围是$[0,L-1] \\bigcup {L} = [0,L]$，因此取初始区间$[l, r]$为$[0,L]$，若$target \\leqslant arr[mid]$，那么可能的结果区间为$[l,mid]$，则更新$r=mid$；否则更新区间为$[mid+1,r]$。由于最终退出循环时为一个区间$[l,r]$，其中$l \\leqslant r$，那么结束条件为$l \\leqslant r$，可以得出循环条件为$l&lt;r$，最终的返回值为$l$。 12345678910111213int findSupremum(vector&lt;int&gt; arr, int target) &#123; int l = 0, r = arr.size(); while (r - l &gt; 1) &#123; int mid = (l + r) / 2; if (arr[mid] &gt;= target) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;//返回第一个元素的下标&#125; &emsp;&emsp;查找下确界同理。 12345678910111213int findInfimum(vector&lt;int&gt; arr, int target) &#123; int l = 0, r = arr.size(); while (r - l &gt; 1) &#123; int mid = (l + r) / 2; if (arr[mid] &lt;= target) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return r;//返回最后一个元素的下标&#125; &emsp;&emsp;$findSupremum()$函数实现了查找第一个大于等于$target$的数的功能，$findInfimum()$实现了查找最后一个小于等于$target$的数的功能。通过更改$while$循环中$if$的条件可以更改查找的功能。","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"算法分析与设计第三次作业题解","slug":"算法分析与设计第三次作业题题解","date":"2021-10-11T03:31:14.000Z","updated":"2022-09-13T11:53:56.405Z","comments":true,"path":"2021/10/11/算法分析与设计第三次作业题题解/","link":"","permalink":"http://example.com/2021/10/11/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"题目发布于2021年10月11日零点。","text":"题目发布于2021年10月11日零点。 Problem A题目描述我们有n根的木棍。现在从这些木棍中切割出来m条长度相同的木棍，问这m根木棍最长有多长？ 题解实际上就是那个切绳子的问题…直接贴代码注意r要足够大，l最好不要取负数 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool isOk(vector&lt;int&gt;&amp;length, int mid, int k) &#123; for (int i = 0; i &lt; length.size(); i++) &#123; k -= length[i] / mid; &#125; return k &lt;= 0;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; length(n); int max_len = 0; for (int i = 0; i &lt; n; i++) &#123; double temp; cin &gt;&gt; temp; length[i] = temp * 100; max_len = max(max_len, length[i]); &#125; int l = 1, r = 1000000000; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (isOk(length, mid, k)) &#123; ans = max(mid, ans); l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; ans / 100.0 &lt;&lt; endl; return 0;&#125; Problem B题目描述有一条河，河中间有一些石头，已知石头的数量和相邻两块石头之间的距离。现在可以移除一些石头，问最多移除m块石头后（首尾两块石头不可以移除），相邻两块石头之间的距离的最小值最大是多少。 输入数据第一行输入两个数字，$n（2 \\leq n \\leq 1000）$为石头的个数，$m（0 \\leq m \\leq n-2）$为可移除的石头数目，随后$n-1$个数字，表示顺序和相邻两块石头的距离$d（d \\leq 1000）$ 题解这个题乍看很迷惑，事实上这个题可以用二分查找进行解决。逆向思考，判断任意两块石头之间的距离均大于等于$d$时，移除石头数$f(d)$是否满足$f(d) \\leq m$。直接使用vector可以避免用list删除时的各种麻烦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;bool valid(int mid, vector&lt;int&gt;&amp; stones, int m);int main() &#123; int n, m; int _max = 0; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; stones(n + 1, 0); for (int i = 2; i &lt;= n; i++) &#123; int temp; cin &gt;&gt; temp; stones[i] = stones[i - 1] + temp; &#125; int l = 0, r = 100000000; while (l &lt; r - 1) &#123; int mid = (l + r) / 2; if (valid(mid, stones, m)) &#123; l = mid; &#125; else &#123; r = mid; &#125; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125;/*我的思路：逐个遍历stones，遇到小的就优先和后面的合并总保证当前指针的位置之前都是合法的*/bool valid(int mid, vector&lt;int&gt;&amp;stones, int m) &#123; int count = 0, back = 2, fr = 1; while (back &lt; stones.size()) &#123; int d = stones[back] - stones[fr]; while (d &lt; mid) &#123; back++; count++; if (count &gt; m) &#123; return false; &#125; if (back == stones.size()) &#123; return fr != 1; &#125; d = stones[back] - stones[fr]; &#125; fr = back; back++; &#125; return true;&#125; Problem C题目描述楼梯有n阶，可以一步上一阶、两阶或三阶，问有多少种不同的走法由于答案很大，mod(1e9+7)输出 题解&emsp;&emsp;dp的题目，比较基础 123456789101112131415161718#include &lt;bits/stdc++.h&gt;#define MOD 1000000007using namespace std;int main()&#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; dp(4, 0);//dp(n + 1, 0)平台会报runtime error dp[1] = 1; dp[2] = 2; dp[3] = 4; for (int i = 4; i &lt;= n; i++) &#123; //dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD; long long tmp = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD; dp.emplace_back(tmp); &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125; Problem D题目描述&emsp;&emsp;一个快递公司要将n个包裹分别送到n个地方，并分配给邮递员小K一个事先设定好的路线，小K需要开车按照路线给的地点顺序相继送达，且不能遗漏一个地点。小K得到每个地方可以签收的时间段，并且也知道路线中一个地方到下一个地方的距离。若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收，但不能晚于签收的时间段，可以认为签收的过程是瞬间完成的。&emsp;&emsp;为了节省燃料，小K希望在全部送达的情况下，车的最大速度越小越好，就找到了你给他设计一种方案，并求出车的最大速度最小是多少。 输入数据&emsp;&emsp;第1行为一个正整数 n $(n&lt;2×10^4)$， 表示需要运送包裹的地点数。&emsp;&emsp;下面 n 行，第 i+1 行有 3 个正整数$x_i,y_i,s_i$， 表示按路线顺序给出第 i 个地点签收包裹的时间段为$[x_i,y_i]$， 即最早为距出发时刻$x_i$， 最晚为距出发时刻$y_i$， 从前一个地点到达第 i 个地点距离为 $s_i$， 且保证路线中$x_i$递增。&emsp;&emsp;可以认为 s1 为出发的地方到第 1 个地点的距离，且出发时刻为 0 。 题解&emsp;&emsp;还是二分查找的题目。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 0.00001;bool valid(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y, vector&lt;int&gt;&amp; s, long double mid);int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; x(n), y(n), s(n); long double ans = 0.0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; s[i]; &#125; long double l = 1, r = 1e9; while (r -l &gt;= eps) &#123; long double mid = (l + r) / 2; if (valid(x, y, s, mid)) &#123; ans = mid; r = mid; &#125; else &#123; l = mid; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;bool valid(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y, vector&lt;int&gt;&amp; s, long double mid) &#123; int n = x.size(); long double t = 0.0; for (int i = 0; i &lt; n; i++) &#123; t += s[i] / mid; t = (t &lt; x[i] ? x[i] : t); if (t &gt; y[i]) &#123; return false; &#125; &#125; return true;&#125; Problem E题目描述有ABC三根杆和一些圆盘，开始的时候圆盘从小到大摞在A杆上，小盘在上大盘在下，规定如果圆盘p摞在圆盘q上面，那么$r_p \\leq r_q$，$r_p$和$r_q$为p和q的半径。现在有若干个圆盘，半径从1到n，半径为i的圆盘有i个，每次操作可以移动一个圆盘，问把所有圆盘从A杆移动到C杆上最少需要几次操作。 由于最终答案可能很大，所以答案对1e9+7取模输出。 题解&emsp;&emsp;汉诺塔升级版，对于汉诺塔而言，初始状态A柱上从上往下数第$i$个盘子共需要被移动$2^{n-i}$次；对于该问题而言，初始状态A柱上从上往下数第$i$个盘子共需要被移动$i * 2^{n-i}$次，用快速幂求解就行。&emsp;&emsp;值得注意的是，快速幂中x要取long long才够用。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define MOD 1000000007using namespace std;long long fast_pow(unsigned long long x, unsigned int y) &#123;//注意x要long long才够，size_t与long都不够 long long ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = (ans * x) % MOD; &#125; x = ((x % MOD) * (x % MOD)) % MOD; y &gt;&gt;= 1; &#125; return ans % MOD;&#125;int main() &#123; int n; cin &gt;&gt; n; long long ans = 0; for (int r = 1; r &lt;= n; r++) &#123; ans = (ans + (r * fast_pow(2, n - r) % MOD)) % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法刷题日记5","slug":"算法刷题日记5","date":"2021-10-08T01:59:35.000Z","updated":"2022-09-13T11:54:43.044Z","comments":true,"path":"2021/10/08/算法刷题日记5/","link":"","permalink":"http://example.com/2021/10/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B05/","excerpt":"","text":"algo 1002&emsp;&emsp;记得我第一次用这个平台还是2020年的暑假小学期的时候，当时想按顺序做几道题，但是到这个题目就卡住了…思索很久也没有答案，正好最近在学dp，于是终于把这个题自己解了出来…（其实是看了好多大佬的代码 题目描述在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0，1，……，L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。对于30%的数据，$L \\leq 10000$；对于全部的数据，$L \\leq 10^9$。 输入数据输入的第一行有一个正整数$L (1≤L≤10^9)$， 表示独木桥的长度。第二行有三个正整数$S,T,M$， 分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中$1≤S≤T≤10,1≤M≤100$。第三行有$M$个不同的正整数分别表示这$M$个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。 输出数据输出只包括一个整数，表示青蛙过河最少需要踩到的石子数。 样例输入102 3 52 3 5 6 7 样例输出2 题目分析&emsp;&emsp;阅读题目可知只要跳过$L$即可，记到达某一位置$i$所需踩的最少的石头数记作$dp[i]$，其中$i \\in [0, L-1+T]$，当前到达当前位置所需的代价与之前$S$到$T$的位置有关。因此很容易写出状态转移方程$dp[i]=min(dp[i-j])$，其中$S \\leq i-j \\leq T$。再看题目中$L$的数据范围可知对于70%的数据需要进行空间的压缩。由$S$和$T$的范围，记$MOD=lcm(1,…,10)$，则$MOD=2520$。之所以这样做的原因是要求出从任一位置$i$一定能前进的距离的最大值，也就是说可以任取$i$一定能从$i$跳至$(i+MOD)$处。由此可以对距离进行压缩，压缩至大约50万的范围内，可以使用dp。最终在区间$[L,L+T-1]$的范围内找出最小值输出即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MOD 2520using namespace std;int main() &#123; int L; cin &gt;&gt; L; int S, T, M; cin &gt;&gt; S &gt;&gt; T &gt;&gt; M; vector&lt;int&gt; stones; for (int i = 0; i &lt; M; i++) &#123; int temp; cin &gt;&gt; temp; stones.emplace_back(temp); &#125; sort(stones.begin(), stones.end(), less&lt;int&gt;()); vector&lt;bool&gt; compressed(MOD * 107); vector&lt;int&gt; dis; for (int i = 1; i &lt; M; i++) &#123; dis.push_back((stones[i] - stones[i - 1]) % MOD); &#125; stones[0] = stones[0] % MOD; stones[0] += (stones[0] == 0 ? MOD : 0); compressed[stones[0]] = true; for (int i = 1; i &lt; M; i++) &#123; stones[i] = stones[i - 1] + dis[i - 1]; compressed[stones[i]] = true; &#125; L = stones[M - 1]; vector&lt;int&gt; dp(L + T + 1, 107); dp[0] = 0; for (int i = 1; i &lt;= L + T; i++) &#123; for (int j = S; j &lt;= T; j++) &#123; if (i - j &gt;= 0) &#123; dp[i] = min(dp[i - j], dp[i]) + (compressed[i] == true ? 1 : 0); &#125; &#125; &#125; int ans = 10e9; for (int i = L; i &lt; L + T; i++) &#123; ans = min(ans, dp[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"算法刷题日记4","slug":"算法刷题日记4","date":"2021-10-04T14:34:24.000Z","updated":"2022-09-13T11:54:45.383Z","comments":true,"path":"2021/10/04/算法刷题日记4/","link":"","permalink":"http://example.com/2021/10/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B04/","excerpt":"","text":"Algo 1355&emsp;&emsp;火柴棒拼等式，经典的枚举问题。首先确定$1111+1=1112$共需要27根火柴，而题设说明$n\\leq24$，故枚举范围可知。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int costs[10] = &#123; 6,2,5,5,4,5,6,3,7,6 &#125;;int cost(int n) &#123; int c = 0; while (1) &#123; c += costs[n % 10]; n /= 10; if (n == 0) &#123; break; &#125; &#125; return c;&#125;int main() &#123; int n, ans = 0; cin &gt;&gt; n; if (n &gt;= 13) &#123; int avail_matches = n - 4;//可用来做数字的只有这些火柴 //至多20根 1111+1=1112 16+5=21 for (int i = 0; i &lt;= 1111; i++) &#123; for (int j = 0; j &lt;= 1111; j++) &#123; if (cost(i) + cost(j) + cost(i + j) == avail_matches) &#123; ans++; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; &emsp;&emsp;平台上写的是要求读写文件，实际上却得用cout进行流输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;const int costs[10] = &#123; 6,2,5,5,4,5,6,3,7,6 &#125;;int cost(int n)&#123; int c = 0; while (1) &#123; c += costs[n % 10]; n /= 10; if (n == 0) &#123; break; &#125; &#125; return c;&#125;int main() &#123; int n, ans = 0; //read file fstream File; File.open(&quot;matches.in&quot;); if (!File) &#123; cout &lt;&lt; &quot;打开失败&quot; &lt;&lt; endl; exit(-1); &#125; File &gt;&gt; n; File.close(); if (n &gt;= 13) &#123; int avail_matches = n - 4;//可用来做数字的只有这些火柴 //至多20根 1111+1=1112 16+5=21 for (int i = 0; i &lt;= 1111; i++) &#123; for (int j = 0; j &lt;= 1111; j++) &#123; if (cost(i) + cost(j) + cost(i + j) == avail_matches) &#123; ans++; &#125; &#125; &#125; &#125; //write ans File.open(&quot;matches.out&quot;, ios::out); if (!File) &#123; cout &lt;&lt; &quot;打开失败&quot; &lt;&lt; endl; exit(-1); &#125; File &lt;&lt; ans; File.close(); return 0;&#125; lintcode 1316&emsp;&emsp;主要是检索超时，经提示应该是需要使用单调栈解决问题，明日再解… 12345678910111213141516171819202122232425262728293031class Solution &#123;//超时public: /** * @param arr: the arr * @return: the sum of the luck number */ int luckNumber(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); int ans = 0; for (int i = 1; i &lt; n - 1; i++) &#123; int l_min = 40001, r_max = 0; bool l_find = false, r_find = false; for (int j = 0; j &lt;= i - 1; j++) &#123; if (arr[j] &gt; arr[i]) &#123; l_min = min(l_min, arr[j]); l_find = true; &#125; &#125; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[j] &lt; arr[i]) &#123; r_max = max(r_max, arr[j]); r_find = true; &#125; &#125; if (l_find &amp;&amp; r_find &amp;&amp; l_min % r_max == 0) &#123; ans++; &#125; &#125; return ans; &#125;&#125;; 和为k&emsp;&emsp;排序后利用双指针就能解决问题，时间复杂度为$O(n^2+nlogn)=O(nlogn)$。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, k, ans = 0; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; v(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i]; &#125; sort(v.begin(), v.end(), less&lt;int&gt;()); int i = 0, j = n - 1; while(i &lt; j)&#123; if (v[i] + v[j] == k) &#123; ans++; i++;//这个地方不好 20211007 j--; &#125; else if(v[i] + v[j] &lt; k) &#123; i++; &#125; else &#123; j--; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Algo1225&emsp;&emsp;给定一个自然数$M$，求满足和恰为$M$的连续自然数的组数，要求从开始数排序从小到大依次输出起始数与最终数。实际上就是等差数列性质及分解因数。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;stack&gt;//vector可以使用emplace_back()方法代替push_back()方法using namespace std;int main() &#123; int M; cin &gt;&gt; M; stack&lt;pair&lt;int, int&gt;&gt; s; for (int i = 2; i * i &lt;= 2 * M; i++) &#123; if (2 * M % i == 0 &amp;&amp; ((M * 2 / i + i) % 2 == 1)) &#123;// s.push(pair&lt;int, int&gt;((2 * M / i - i + 1) / 2, (2 * M / i + i - 1) / 2)); &#125; &#125; while (!s.empty()) &#123; cout &lt;&lt; s.top().first &lt;&lt; &#x27; &#x27; &lt;&lt; s.top().second &lt;&lt; endl; s.pop(); &#125; return 0;&#125; 幸运数&emsp;&emsp;定义幸运数为因数只有3、5、7的因数的正整数，输入一个正整数，求出小于这个数的幸运数个数。对数运算估计范围后暴力枚举+快速幂应该就可以解决。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;//有问题 20211007#include &lt;queue&gt;using namespace std;unsigned long long fast_pow(unsigned long long x, unsigned long long y) &#123;//快速幂，学学位运算 unsigned long long ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans *= x; &#125; x *= x; y &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; int ans = 0; //const unsigned long long lim = 1000000000000; unsigned long long lim; cin &gt;&gt; lim; for (int i = 0; i &lt;= 26; i++) &#123; for (int j = 0; j &lt;= 18; j++) &#123; for (int k = 0; k &lt;= 15; k++) &#123; if(fast_pow(3,i) * fast_pow(5, j) * fast_pow(7, k) &lt; lim)&#123; ans++; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"数论算法学习笔记","slug":"数论算法学习笔记","date":"2021-10-01T01:49:12.000Z","updated":"2022-09-13T11:52:33.368Z","comments":true,"path":"2021/10/01/数论算法学习笔记/","link":"","permalink":"http://example.com/2021/10/01/%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"整理学习数论的所思所想。","text":"整理学习数论的所思所想。 求最大公约数（gcd）与最小公倍数（lcm）求两个数的最大公约数暴力枚举&emsp;&emsp;求最大公约数的最朴素的想法就是暴力枚举。 12345678910int gcd1(int a, int b) &#123;//假定输入的a，b都是正数 int ans = 1; int _max = max(a, b), _min = a + b - _max; for (int i = 2; i &lt;= _min; i++) &#123; if (_max % i == 0 &amp;&amp; _min % i == 0) &#123; ans = i; &#125; &#125; return ans;&#125; 辗转相除法&emsp;&emsp;还可以使用辗转相除法。证明如下：&emsp;&emsp;设$a=kb+r$，其中$a, b, k, r\\in Z，r=amod(b)$。设$d$为$a$与$b$的一个公约数，由$a=kb+r$有：$r=a-kb$，等式两边同除$d$得：$r/d=a/r-kb/d$，显然式中任意一项都是整数，则$r$也是$a mod(b)$的因子。$gcd(a, b)=gcd(b, a mod(b))$得证。&emsp;&emsp;事实上$gcd(a,b)=gcd(b,a)$，在程序中也是这样的。以gcd2函数为例，如果$b&gt;a$，则$amod(b)=a$，下一步进行的是求$b$与$a$的最大公约数。因此使用欧几里得算法不需要考虑两个数的大小。 12345678910111213int gcd2(int a, int b) &#123; return a % b == 0 ? b : gcd2(b, a % b);&#125;int gcd3(int a, int b) &#123; int r = a; while (r != 0) &#123; r = a % b;//取余数 a = b;//大数更新为小数 b = r;//小数更新为余数 &#125; return a;&#125; 更相减损法&emsp;&emsp;实际上，更相减损法与辗转相除法实质是一样的，而且前者所需的计算次数通常更多。更相减损法的原理是$gcd(a,b)=gcd(min(a,b),max(a,b)-min(a,b))$。 123456789101112131415161718192021222324252627282930313233343536int gcd4(int a, int b) &#123; if (a == b) &#123; return a; &#125; if (a &gt; b) &#123; return gcd4(b, a - b); &#125; else&#123; return gcd4(a, b - a); &#125;&#125;int gcd5(int a, int b) &#123; if (a == b) &#123; return a; &#125; int _max = max(a, b), _min = a + b - _max; while(_max != _min)&#123; int tmp1 = _max - _min, tmp2 = _min; _max = max(tmp1, tmp2); _min = tmp1 + tmp2 - _max; &#125; return _min;&#125;int gcd6(int a, int b) &#123; while(a!=b)&#123; if (a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return a;&#125; &emsp;&emsp;显然，更相减损法是需要考虑两个数之间的大小的。 求两个数的最小公倍数&emsp;&emsp;事实上，求最小公倍数可以使用分解质因数法，也可以利用最小公倍数与最大公约数之间的关系求解。 分解质因数法12345678910111213141516171819202122232425262728293031323334353637bool is_prime(int n)&#123; if (n == 2) &#123; return true; &#125; if (n % 2 == 0 || n &lt; 2) &#123; return false; &#125; for (int i = 3; i * i &lt;= n; i += 2) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125;int lcm1(int a, int b) &#123; int _max = max(a, b); int _lcm = 1; for (int i = 2; i &lt;= _max; i++) &#123; if (is_prime(i)) &#123; while (a % i == 0 &amp;&amp; b % i == 0) &#123; _lcm *= i; a /= i; b /= i; &#125; while (a % i == 0)&#123; _lcm *= i; a /= i; &#125; while (b % i == 0) &#123; _lcm *= i; b /= i; &#125; &#125; &#125; return _lcm;&#125; 利用最大公约数&emsp;&emsp;具体原理详见算法分析与设计第二次题解中F题的分析。 123int lcm2(int a, int b)&#123; return a * b / gcd1(a, b);&#125; 求一个正整数的因数个数以及比它小并且与它互质的数的个数求一个正整数的因数个数&emsp;&emsp;由算术基本定理可知：每个正整数的标准分解式都是唯一的。考虑任意一个正整数$n$，记$n=\\prod{p_i^{\\alpha_i}}$，那么$n$的因数$k$的形式必定为$n=\\prod{p_k^{\\beta_k}}$。当$i=k$时，有$0\\leq\\beta_k\\leq\\alpha_i$，每一个质因数$p_k（p_i）$的次数$\\beta_k$可取$0$到$\\alpha_i$，即共有$(\\alpha_i+1)$种取法，因此总的因数个数$d(n)$为$d(n)=\\prod({\\alpha_i + 1})$。","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"数学","slug":"算法学习/数学","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"算法分析与设计第二次作业题题解","slug":"算法分析与设计第二次作业题题解","date":"2021-09-30T08:59:02.000Z","updated":"2022-09-13T11:53:51.182Z","comments":true,"path":"2021/09/30/算法分析与设计第二次作业题题解/","link":"","permalink":"http://example.com/2021/09/30/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"题目发布于2021年9月30日上午十点。","text":"题目发布于2021年9月30日上午十点。 Problem A题目描述如果一个质数能被表示为三个不同的质数的和的形式，那么我们称它为立方质数。现在给你一个数n（n≤1000），判断它是不是立方质数。 题解一看n的范围，直接暴力枚举即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;bool is_prime(int n) &#123; if (!(n % 2)) &#123; return false; &#125; if (n == 1) &#123; return false; &#125; for (int i = 3; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; vector&lt;int&gt; primeList; int n; cin &gt;&gt; n; if (!is_prime(n)) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; &#125; for (int i = 2; i &lt;= n; i++) &#123; if (is_prime(i)) &#123; primeList.push_back(i); &#125; &#125; int l = primeList.size(); for (int i = 0; i &lt; l; i++) &#123; for (int j = i + 1; j &lt; l; j++) &#123; for (int k = j + 1; k &lt; l; k++) &#123; if (n == primeList[i] + primeList[j] + primeList[k]) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0;&#125; Problem B题目描述有n盏灯，编号都是1-n，初始灯都是关着的。有n个人，第1个人会打开所有的灯，第2个人会按下所有编号为2的倍数的灯的开关（这些灯将被关掉），第3个人会按下所有编号为3的倍数的开关，以此类推，第n个人会按下所有编号为n的倍数的开关。问最后有几盏灯是亮着的。 题解实际上，仔细读题发现，最后只有被按了奇数次的灯会亮着，也就是说，在区间$[1, n]$中的整数i满足条件当且仅当i恰好有奇数个不同的因数。大于1的任意一个正整数的因数都是成对出现的，除非这个数是完全平方数。说到底，这个题就是要求$[1, n]$中有多少个完全平方数。直接返回n的平方根的下界即可。 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int i; for(i = 1; i * i &lt;= n; i++)&#123;&#125; cout &lt;&lt; i - 1 &lt;&lt; endl; return 0;&#125; Problem C题目描述小明刚买了一个机械键盘，但他在用机械键盘打字的时候发现键盘的Home键和End键坏掉了，于是他在打字的时候光标有时会突然跑到行首，有时又会突然跑到行尾，现在给你键盘的输入，求最后屏幕上的字符串。 题解经典的一个问题，记得最早看到应该是在一本C语言的算法书上看到的。实际上需要费脑筋的是输入多个home的情况。AC后发现，就我自己实现的算法而言，把list换成vector好像也没啥区别… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;list&gt;#define FRONT true#define BACK falseint main() &#123; string s, fr; int c = 0; cin &gt;&gt; s; list&lt;char&gt; l; stack&lt;string&gt; S; bool sign = BACK; for (size_t i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;[&#x27;) &#123; sign = FRONT; c++; if (fr != &quot;&quot; &amp;&amp; c &gt; 1) &#123; S.push(fr); fr.clear(); &#125; continue; &#125; else if (s[i] == &#x27;]&#x27;) &#123; sign = BACK; continue; &#125; else if (sign == FRONT) &#123; fr.push_back(s[i]); &#125; else &#123; l.push_back(s[i]); &#125; &#125; if (fr != &quot;&quot;) &#123; S.push(fr); &#125; while (!S.empty())&#123; cout &lt;&lt; S.top(); S.pop(); &#125; for (auto i : l) &#123; cout &lt;&lt; i; &#125; cout &lt;&lt; endl; return 0;&#125; &emsp;&emsp;看了几位大佬的代码后进行了些修改…. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt; #define FRONT true#define BACK falseusing namespace std;int main() &#123; string s, fr, ans; cin &gt;&gt; s; bool mode = BACK; for (auto c : s) &#123; if (c == &#x27;[&#x27;) &#123; mode = FRONT; ans = fr + ans; fr.clear(); &#125; else if (c == &#x27;]&#x27;) &#123; mode = BACK; &#125; else &#123; if (mode == BACK) &#123; ans.push_back(c); &#125; else &#123; fr.push_back(c); &#125; &#125; &#125; ans = fr + ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem D题目描述农民约翰的母牛总是生产出最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。农民约翰确定他卖给买方的是真正的质数肋骨,是因为从右边开始切下肋骨,每次还剩下的肋骨上的数字都组成一个质数,举例来说:7 3 3 1全部肋骨上的数字 7331是质数;三根肋骨 733是质数;二根肋骨 73 是质数;当然,最后一根肋骨 7 也是质数。7331 被叫做长度 4 的特殊质数。写一个程序对给定的肋骨的数目 N (1&lt; =N&lt; =8),求出所有的特殊质数。数字1不被看作一个质数。 题解&emsp;&emsp;我思考的结果是从1位特殊质数依此向上计算，这样循环次数较少；使用队列能更方便处理从小到大排序。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;queue&gt;int main() &#123; int N; cin &gt;&gt; N; queue&lt;int&gt; ans(&#123;2, 3, 5, 7&#125;); int lastCount = 4; int curCount = 0; for (int i = 2; i &lt;= N; i++) &#123; curCount = 0; for (int j = 1; j &lt;= lastCount; j++) &#123; int cur = ans.front(); ans.pop(); cur *= 10; for (int k = 1; k &lt;= 9; k += 2) &#123; if (is_prime(cur + k)) &#123; ans.push(cur + k); curCount++; &#125; &#125; &#125; lastCount = curCount; &#125; while(!ans.empty()) &#123; cout &lt;&lt; ans.front() &lt;&lt; endl; ans.pop(); &#125; return 0;&#125; &emsp;&emsp;查看其他AC的同学的代码后发现可以使用递归的写法，其实两种方法本质上是一样的，只是递归写法与非递归写法的差别。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;bool is_prime(int n) &#123; if (n == 2) &#123; return true; &#125; if (n % 2 == 0 || n &lt; 2) &#123; return false; &#125; for (int i = 3; i * i &lt;= n; i += 2) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125;void DFS(int curDidCapa, int N, int lastNum) &#123; if (curDidCapa == N) &#123; cout &lt;&lt; lastNum &lt;&lt; endl; &#125; else &#123; for (int i = 1; i &lt;= 9; i += 2) &#123; int curNum = i + lastNum * 10; if (is_prime(curNum)) &#123; DFS(curDidCapa + 1, N, curNum); &#125; &#125; &#125;&#125;int main() &#123; int N; cin &gt;&gt; N; int start[4] = &#123; 2,3,5,7 &#125;; for (auto i : start) &#123; DFS(1, N, i); &#125; return 0;&#125; Problem E题目描述给出一个小于2^32的正整数。这个数可以用一个32位的二进制数表示（不足32位用0补足）。我们称这个二进制数的前16位为“高位”，后16位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。 例如，数1314520用二进制表示为0000 0000 0001 0100 0000 1110 1101 1000（添加了11个前导0补足为32位），其中前16位为高位，即0000 0000 0001 0100；后16位为低位，即0000 1110 1101 1000。将它的高低位进行交换，我们得到了一个新的二进制数0000 1110 1101 1000 0000 0000 0001 0100。它即是十进制的249036820。 题解&emsp;&emsp;只要注意int会有正负…使用unsigned int 或 size_t即可 12345678910#include &lt;iostream&gt;#define base 65536 //2^16using namespace std;int main()&#123; size_t n; cin &gt;&gt; n; size_t low = n / base, high = n % base; cout &lt;&lt; high * base + low &lt;&lt; endl; return 0;&#125; Problem F题目描述输入二个正整数$x_0,y_0(2≤x_0≤100000，2≤y_0≤1000000)$，求出满足下列条件的P、Q的个数。条件：1、P、Q是正整数；2、要求P、Q以$x_0$为最大公约数，以$y_0$为最小公倍数。试求满足条件的所有可能的两个正整数的个数。 题解设$P=k_1x_0, Q=k_2x_0（k_1与k_2互质）$, 则依题意$k_1k_2x_0=y_0$，也就是说$k_1k_2=y_0/x_0$。若$x_0$不能整除$y_0$，则满足要求的个数为0；否则只要统计$y_0/x_0$的互质因数的组数即可（也就是所有的非平方根因数的个数）。本题还有一点就是要求最大公约数。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int gcd(int a, int b) &#123; return a % b == 0 ? b : gcd(b, a % b);&#125;int main() &#123; int x0, y0; cin &gt;&gt; x0 &gt;&gt; y0; if (y0 % x0) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; int p = y0 / x0; int ans = 0; for (int i = 1; i * i &lt; p; i++) &#123; if (p % i == 0 &amp;&amp; gcd(i, p / i) == 1) &#123; ans += 2; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"机器学习——回归任务与线性判别分析实验","slug":"机器学习——回归任务与线性判别分析实验","date":"2021-09-30T00:27:43.000Z","updated":"2022-09-13T11:50:58.125Z","comments":true,"path":"2021/09/30/机器学习——回归任务与线性判别分析实验/","link":"","permalink":"http://example.com/2021/09/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92%E4%BB%BB%E5%8A%A1%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/","excerpt":"这次实验内容较为简单，主要就是在老师提供的代码的基础上填充关键部分即可","text":"这次实验内容较为简单，主要就是在老师提供的代码的基础上填充关键部分即可 机器学习第三章实验内容详细内容见第二周实验内的jupyter notebook。 一、实验内容1.1 一元线性回归使用Kaggle房价预测数据集：1、打乱数据顺序，取前70%的数据作为训练集，后30%的数据作为测试集2、分别以LotArea, BsmtUnfSF, GarageArea三种特征作为模型的输入，SalePrice作为模型的输出3、在训练集上，使用最小二乘法求解模型参数（需自己实现，不允许第三方库完成）4、计算三个模型在测试集上的MAE和RMSE这两种指标的大小（需自己实现，不允许第三方库完成）5、分别绘制模型的在训练集和测试集上的曲线6、选做：尝试去除训练集中的异常值或离群值后再次训练模型，绘制模型的预测曲线，观察模型在测试集上预测能力的变化 1.2 多元线性回归/对数线性回归（二选一）1、多元线性回归使用多个特征作为输入完成房价预测问题，计算模型在十折交叉验证上MAE和RMSE的值，比较不同的特征组合在模型预测能力上的影响。模型可使用sklearn.linear_model.LinearRegression 选做：多项式回归（一元线性回归的扩展），尝试对部分特征进行变换，如将其二次幂，三次幂作为特征输入模型，观察模型在预测能力上的变化。 2、对数线性回归尝试使用对数线性回归完成房价预测问题，特征自选，比较模型十折交叉验证的MAE与RMSE。模型可使用sklearn.linear_model.LinearRegression 1.3 对数几率回归1、使用对数几率回归完成垃圾邮件分类问题和Dota2结果预测问题2、计算十折交叉验证下的精度(accuracy)，查准率(precision)，查全率(recall)，F1值。3、模型可使用sklearn.linear_model.LogisticRegression 1.4 线性判别分析1、使用线性判别分析完成垃圾邮件分类问题和Dota2结果预测问题2、计算十折交叉验证下的精度(accuracy)，查准率(precision)，查全率(recall)，F1值。3、模型可使用sklearn.discriminant_analysis.LinearDiscriminantAnalysis 1.5 综合题（选做）任务要求：白葡萄酒质量共分为7个等级，对白葡萄酒质量进行预测。1、使用精度作为评价指标2、使用一元线性回归、多元线性回归、对数线性回归等线性回归模型对葡萄酒质量进行预测，计算其十折交叉验证的精度。3、使用对数几率回归、线性判别分析对葡萄酒质量进行预测，计算其十折交叉验证的精度。4、对比不同模型的预测能力。 二、数据介绍2.1 kaggle房价预测数据集文件名：1、原始数据：kaggle_hourse_price_train.csv2、字段说明：kaggle房价预测字段说明.txt3、预处理脚本：preprocess.py4、处理后数据：kaggle房价预测处理后数据.csv 数据来源：https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data 数据预处理步骤：该数据集是真实数据集，含有大量的缺失值和噪声数据，提供的预处理脚本只对含缺失值的特征进行丢弃处理，学生可根据自己的需要进行其他方式的处理。3.2 白葡萄酒质量数据集文件名：1、原始数据：winequality-white.csv2、字段说明：葡萄酒字段说明.txt 数据来源：http://archive.ics.uci.edu/ml/datasets/Wine+Quality 数据无需预处理，读取即可使用import pandas as pddata = pd.read_csv(‘data/wine_quality/winequality-white.csv’, delimiter=”;”)2.3 spambase垃圾邮件数据集文件名：1、原始数据：spambase.data2、字段说明：spambase数据说明.txt 数据来源：http://archive.ics.uci.edu/ml/datasets/spambase 数据无需预处理，读取即可使用import numpy as npdata = np.loadtxt(‘data/spambase/spambase.data’, delimiter = “,”)2.4 Dota2 Games Results Data Set Dota2游戏结果数据集文件名：1、原始数据：dota2Train.csv2、字段说明：dota2比赛结果字段说明.txt 数据来源：http://archive.ics.uci.edu/ml/datasets/Dota2+Games+Results 数据无需预处理，读取即可使用import numpy as npdata = np.loadtxt(‘data/dota2Dataset/dota2Train.csv’, delimiter=’,’)","categories":[{"name":"课业","slug":"课业","permalink":"http://example.com/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"计网第二章课后习题","slug":"计网第二章课后习题","date":"2021-09-29T11:16:08.000Z","updated":"2022-09-14T01:43:05.310Z","comments":true,"path":"2021/09/29/计网第二章课后习题/","link":"","permalink":"http://example.com/2021/09/29/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"网站建设与维护纪实","slug":"网站建设与维护纪实","date":"2021-09-28T11:49:50.000Z","updated":"2022-09-13T11:54:58.439Z","comments":true,"path":"2021/09/28/网站建设与维护纪实/","link":"","permalink":"http://example.com/2021/09/28/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E4%B8%8E%E7%BB%B4%E6%8A%A4%E7%BA%AA%E5%AE%9E/","excerpt":"本页主要记录网页的建设与维护的过程，并分享一些经验。","text":"本页主要记录网页的建设与维护的过程，并分享一些经验。 2021年9月28日&emsp;&emsp;网页出现乱码问题，经查证是编码问题，查找资料后在对WinSCP的登陆设置与登陆后的编辑设置中进行修改后问题解决。&emsp;&emsp;要使用Markdown语言进行公式编辑就需要在每篇博客的头部加上如下代码。 1mathjax: true # important &emsp;&emsp;最终得到的效果为：$e^{i\\pi}+1=0$. 2021年9月29日&emsp;&emsp;经大佬的提示，我将网站中的图片进行压缩，转为webp格式… 2021年11月9日&emsp;&emsp;经过查找资料后，我将网站的代码字体更换为Fira Code，实际上流程很简单。&emsp;&emsp;在Ubuntu系统使用如下命令安装Fira Code字体，随后修改_config.volantis.yml中的codefont之后即可使用字体。 1sudo apt install fonts-firacode","categories":[],"tags":[]},{"title":"LintCode刷题日记3","slug":"LintCode刷题日记3","date":"2021-09-28T11:49:13.000Z","updated":"2022-09-13T11:55:11.010Z","comments":true,"path":"2021/09/28/LintCode刷题日记3/","link":"","permalink":"http://example.com/2021/09/28/LintCode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B03/","excerpt":"","text":"题目1300&emsp;&emsp;事实上，当n小于等于3时，我总是能赢；n大于等于4时，只要n是4的倍数我一定输，其他情况我一定赢，因此只要返回$(n%4!=0)$即可。 1234567891011class Solution &#123;public: /** * @param n: an integer * @return: whether you can win the game given the number of stones in the heap */ bool canWinBash(int n) &#123; return (n%4!=0);//在c++中自动将非零的数转换为true &#125;&#125;; 题目1609&emsp;&emsp;快慢指针基本题目 123456789101112131415161718192021222324252627282930313233/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param head: the head node * @return: the middle node */ ListNode * middleNode(ListNode * head) &#123; if(!head || !head-&gt;next)&#123; return head; &#125; else&#123; ListNode* f=head,*s=head; while(f&amp;&amp;f-&gt;next)&#123; f = f-&gt;next-&gt;next; s=s-&gt;next; &#125; return s; &#125; &#125;&#125;; &emsp;&emsp;突然想到之前有一道题…于是复习了一下 北京北站的故事题目描述北京北站现有 n 节车厢从 A 方向驶入，并按进站顺序依次编号，站长要求这些车厢按照指定的顺序从 B 方向使出。Qingyong从《交通运输概论》课程学习到，完成站长的任务需要借助中转站（记为 C 方向）。假设 C 可以停放任意数量的车厢，但是 C 末端封闭，因此，驶入 C 站的车厢必须按照相反的顺序驶出。 Qingyong进一步限定允许的操作如下： 让 A 方向最前面的车厢从 B 方向驶出车站； 让 A 方向最前面的车厢驶入中转站 C； 让中转站 C 中最后驶入的车厢从 B 方向驶出车站。 请帮助Qingyong判断能否让车厢按照站长给定的顺序驶出北京北站。 输入数据第一行为一个正整数 n，代表车厢总数，n &lt; 100000。 第二行有 n 个正整数，代表站长要求的车厢驶出车站顺序。 输出数据Yes或者No 样例输入1254 5 3 2 1 样例输出1Yes 实际上这个题目考察如何用栈调整队列中元素的顺序。设置两个变量$in_{num}$与$out_{num}$分别代表当前处于队首的车辆编号以及当前需要出队的车辆编号。当$in_{num}==out_{num}$时，直接使$in_{num}$自加即可；当$in_{num}&gt;out_{num}$时，需要将所有在$[in_{num}, out_{num}-1]$区间范围内的车辆编号全部入栈，然后更新$in_{num}$为$out_{num}+1$；否则，需要在栈中取栈顶元素，如果栈非空且栈顶元素等于$out_{num}$，则将栈顶元素出栈；否则说明不能按要求输出。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; stack&lt;int&gt; s; int in_num = 1, out_num; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; out_num; if (in_num == out_num) &#123; in_num++; &#125; else if(out_num &gt; in_num)&#123; for(int j = in_num; j &lt; out_num; j++)&#123; s.push(j); &#125; in_num = out_num + 1; &#125; else &#123; if (!s.empty() &amp;&amp; s.top() == out_num) &#123; s.pop(); &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0;&#125; 回过头来看这个题目对于算法菜鸡的我来说确实有些细节不能立得，但是想到当时这道题直接把我搞得完全不会感觉有点可惜…如果当时能学点c++ 再来个割绳子吧 割绳子分割绳子时间限制: 1 Sec 内存限制: 128 MB 题目描述 现有N条绳子，它们的长度分别为L1，L2，„„，Ln，如果从它们中切割出K条长度相同的绳子，这K条绳子每条最长能有多长？ 输入 共有两行，第一行包含两个正整数N和K，用一个空格分隔；第二行包含N个数，依次表示N条绳子的长度，两数间用一个空格分隔。每条绳子长度的小数不超过两位。（1&lt;=N&lt;=1000，1&lt;=K&lt;=1000，1&lt;=Li&lt;=10000） 输出 仅包含一个数，表示所得K绳子的最大长度。答案四舍五入保留小数点后两位。 题目分析：主要有两点，注意精度问题；还有就是要提高搜索效率。对于前一个问题，只需在输入时转为整数；对于后一个问题则可以采取二分查找。值得注意的是，割绳子的段数可以多但不能少。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool isOk(vector&lt;int&gt;&amp;length, int mid, int k) &#123; for (int i = 0; i &lt; length.size(); i++) &#123; k -= length[i] / mid; &#125; return k &lt;= 0;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; length(n); int max_len = 0; for (int i = 0; i &lt; n; i++) &#123; double temp; cin &gt;&gt; temp; length[i] = temp * 100; max_len = max(max_len, length[i]); &#125; int l = 1, r = max_len; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (isOk(length, mid, k)) &#123; ans = max(mid, ans); l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; ans / 100.0 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"LintCode刷题日记2","slug":"LintCode刷题日记2","date":"2021-09-27T01:12:10.000Z","updated":"2022-09-13T11:55:08.403Z","comments":true,"path":"2021/09/27/LintCode刷题日记2/","link":"","permalink":"http://example.com/2021/09/27/LintCode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B02/","excerpt":"主要学习dp","text":"主要学习dp 题目167&emsp;&emsp;注意进位的问题，最后一步如果有进位需要多加一个结点，实质上考察了对有进位加法的步骤的考察 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param l1: the first list * @param l2: the second list * @return: the sum list of l1 and l2 */ ListNode * addLists(ListNode * l1, ListNode * l2) &#123; ListNode* traverse1 = l1, *traverse2 = l2; ListNode* ans = new ListNode(), *tail = ans; int c = 0; while(l1 &amp;&amp; l2)&#123; int cur = l1-&gt;val + l2-&gt;val + c; ListNode* tmp = new ListNode(cur % 10); c = cur / 10; tail-&gt;next = tmp; tail = tmp; l1=l1-&gt;next; l2=l2-&gt;next; &#125; while(l1)&#123; int cur = l1-&gt;val + c; ListNode* tmp = new ListNode(cur % 10); c = cur / 10; tail-&gt;next = tmp; tail = tmp; l1=l1-&gt;next; &#125; while(l2)&#123; int cur = l2-&gt;val + c; ListNode* tmp = new ListNode(cur % 10); c = cur / 10; tail-&gt;next = tmp; tail = tmp; l2=l2-&gt;next; &#125; if(c)&#123; ListNode* tmp = new ListNode(c); tail-&gt;next = tmp; tail = tmp; &#125; ListNode* del = ans; ans = ans-&gt;next; delete del; return ans; &#125;&#125;; 题目669动态规划题目，思考状态转移方程注意从问题的末尾开始可看b站视频 1234567891011121314151617181920212223242526class Solution &#123;public: /** * @param coins: a list of integer * @param amount: a total amount of money amount * @return: the fewest number of coins that you need to make up */ int coinChange(vector&lt;int&gt; &amp;coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, 200000000); dp[0] = 0; for(int i = 1; i &lt;= amount;i++)&#123; //求min for(int j = 0; j &lt;= coins.size(); j++)&#123; if(i - coins[j] &gt;= 0 &amp;&amp; dp[i-coins[j]] != 200000000 &amp;&amp; dp[i-coins[j]] + 1 &lt; dp[i])&#123; dp[i] = dp[i - coins[j]] + 1; &#125; &#125; &#125; if(dp[amount] &gt;= 200000000)&#123; return -1; &#125; else&#123; return dp[amount]; &#125; &#125;&#125;; 题目114&emsp;&emsp;简单的dp题目&emsp;&emsp;动态规划：确定状态、转移方程、初始条件与边界情况、计算顺序 12345678910111213141516171819202122class Solution &#123;public: /** * @param m: positive integer (1 &lt;= m &lt;= 100) * @param n: positive integer (1 &lt;= n &lt;= 100) * @return: An integer */ int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 || j == 0)&#123; dp[i][j] = 1; &#125; else&#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; 题目116判断方案是否存在类型的动态规划 1234567891011121314151617181920class Solution &#123;public: /** * @param A: A list of integers * @return: A boolean */ bool canJump(vector&lt;int&gt; &amp;A) &#123; int n = A.size(); vector&lt;bool&gt; dp(n, false); dp[0] = true; for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(dp[j] &amp;&amp; j + A[j] &gt;= i)&#123; dp[i] = true; &#125; &#125; &#125; return dp[n - 1]; &#125;&#125;; 题目115加上了更多条件的dp，注意边界条件的变化 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: /** * @param obstacleGrid: A list of lists of integers * @return: An integer */ int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt; &amp;obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1])&#123; return 0; &#125; else&#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(obstacleGrid[i][j])&#123; continue; &#125; else&#123; if(i == 0 &amp;&amp; j == 0)&#123; dp[i][j] = 1; &#125; else&#123; if(i &gt;= 1)&#123; dp[i][j] += dp[i - 1][j]; &#125; if(j &gt;= 1)&#123; dp[i][j] += dp[i][j - 1]; &#125; &#125; &#125; &#125; &#125; return dp[m-1][n-1]; &#125; &#125;&#125;; 题目 515需要分类讨论的dp 123456789101112131415161718192021222324252627class Solution &#123;public: /** * @param costs: n x 3 cost matrix * @return: An integer, the minimum cost to paint all houses */ int minCost(vector&lt;vector&lt;int&gt;&gt; &amp;costs) &#123; int n = costs.size(); if(n == 0)&#123; return 0; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(3, 0)); for(int i = 0; i &lt;n; i++)&#123; if(!i)&#123; dp[i][0]=costs[i][0]; dp[i][1]=costs[i][1]; dp[i][2]=costs[i][2]; &#125; else&#123; dp[i][0] = min(costs[i][0] + dp[i-1][1], costs[i][0]+dp[i-1][2]); dp[i][1] = min(costs[i][1] + dp[i-1][2], costs[i][1]+dp[i-1][0]); dp[i][2] = min(costs[i][2] + dp[i-1][0], costs[i][2]+dp[i-1][1]); &#125; &#125; return min(dp[n-1][0],min(dp[n-1][1],dp[n-1][2])); &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"LintCode刷题日记1","slug":"LintCode刷题日记1","date":"2021-09-26T08:00:18.000Z","updated":"2022-09-13T11:55:06.165Z","comments":true,"path":"2021/09/26/LintCode刷题日记1/","link":"","permalink":"http://example.com/2021/09/26/LintCode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B01/","excerpt":"","text":"题目1270&emsp;&emsp;实际上就是判断组成字符串ransomNote字符集合是否是组成字符串magazine字符集合的字集&emsp;&emsp;C++中可以使用includes函数进行操作，其参数为：第一个容器的起始、第一个容器的结束、第二个容器的起始、第二个容器的结束，返回值为前一个容器包含后一个容器（后是前的子集）。但是注意需要对元素进行降序排序。 1234567891011121314class Solution &#123;public: /** * @param ransomNote: a string * @param magazine: a string * @return: whether the ransom note can be constructed from the magazines */ bool canConstruct(string &amp;ransomNote, string &amp;magazine) &#123; string s1 = ransomNote, s2 = magazine; sort(s1.begin(), s1.end(), less&lt;char&gt;()); sort(s2.begin(), s2.end(), less&lt;char&gt;()); return includes(s2.begin(), s2.end(), s1.begin(), s1.end()); &#125;&#125;; &emsp;&emsp;对结构体按照某个分量进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct studentInfo &#123; int number; string name; double score; studentInfo(int ini_number = 0, string ini_name = &quot;test&quot;, double ini_score = 60.0):number(ini_number), name(ini_name), score(ini_score) &#123;&#125;&#125;;bool compScoreGreater(studentInfo&amp; s1, studentInfo&amp; s2) &#123; return s1.score &gt; s2.score;//升序排列，如果改为return 参数表前&gt;参数表后，则为降序&#125;bool compNumberGreater(studentInfo&amp; s1, studentInfo&amp; s2) &#123; return s1.number &gt; s2.number;//升序排列，如果改为return 参数表前&gt;参数表后，则为降序&#125;int main() &#123; vector&lt;studentInfo&gt; test; test.push_back(studentInfo(11111111, &quot;John&quot;, 70.5)); test.push_back(studentInfo(11111000, &quot;Alice&quot;, 60.5)); test.push_back(studentInfo(11111001, &quot;Tom&quot;, 98.5)); test.push_back(studentInfo(11111122, &quot;Sam&quot;, 100.0)); test.push_back(studentInfo(11111000, &quot;Bob&quot;, 30.0)); cout &lt;&lt; &quot;原始数据&quot; &lt;&lt; endl; for (auto info : test)&#123; cout &lt;&lt; info.name &lt;&lt; &quot; &quot; &lt;&lt; info.score &lt;&lt; &quot; &quot; &lt;&lt; info.number &lt;&lt; endl; &#125; sort(test.begin(), test.end(), compNumberGreater); cout &lt;&lt; &quot;按照学号降序排序&quot; &lt;&lt; endl; for (auto info : test) &#123; cout &lt;&lt; info.name &lt;&lt; &quot; &quot; &lt;&lt; info.score &lt;&lt; &quot; &quot; &lt;&lt; info.number &lt;&lt; endl; &#125; sort(test.begin(), test.end(), compScoreGreater); cout &lt;&lt; &quot;按照分数降序排序&quot; &lt;&lt; endl; for (auto info : test) &#123; cout &lt;&lt; info.name &lt;&lt; &quot; &quot; &lt;&lt; info.score &lt;&lt; &quot; &quot; &lt;&lt; info.number &lt;&lt; endl; &#125; return 0;&#125; 题目2719linux命令行中利用let关键字为变量赋值，用echo加上”$var”返回变量值。","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"动态规划学习笔记","slug":"动态规划学习笔记","date":"2021-09-26T07:59:21.000Z","updated":"2022-09-13T11:49:43.048Z","comments":true,"path":"2021/09/26/动态规划学习笔记/","link":"","permalink":"http://example.com/2021/09/26/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"&emsp;&emsp;本篇博客作一些动态规划学习的笔记。&emsp;&emsp;一个问题能用动态规划解决需要满足三个条件：有边界条件、有递推方程且具有最优子结构性质。","text":"&emsp;&emsp;本篇博客作一些动态规划学习的笔记。&emsp;&emsp;一个问题能用动态规划解决需要满足三个条件：有边界条件、有递推方程且具有最优子结构性质。 最大连续子序列之和123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define INF 10000009using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int tmpSum = 0, maxSum = 0; for (auto i : nums) &#123; tmpSum = max(tmpSum + i, i); maxSum = max(tmpSum, maxSum); &#125; cout &lt;&lt; maxSum &lt;&lt; endl; return 0;&#125; 矩阵连乘问题12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define INF 1000000009using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; mSize(n + 1); mSize[0] = pair&lt;int, int&gt;(-1, -1); for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; mSize[i].first &gt;&gt; mSize[i].second; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, INF)); for (int i = 1; i &lt;= n; i++) &#123; dp[i][i] = 0; &#125; for (int len = 2; len &lt;= n; len++) &#123; //计算长度为len的矩阵链最优值 for (int i = 1; i &lt;= n - len + 1; i++) &#123; //矩阵链的开始矩阵下标 int j = i + len - 1; //矩阵链的结束矩阵下标 for (int k = i; k &lt; j; k++) &#123; //枚举划分位置 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + mSize[i].first * mSize[k].second * mSize[j].second); &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl; /*测试数据 6 30 35 35 15 15 5 5 10 10 20 20 25 ans:15125 */ return 0;&#125; 集合划分123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;int main() &#123;//集合划分 int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); //dp[i][j]代表i个元素时划分为j个集合有多少种方法 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i &gt;= j) &#123; if (j == 1) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j] * j + dp[i - 1][j - 1]; &#125; &#125; &#125; &#125; ll ans = 0;//注意结果是否溢出 for (int i = 1; i &lt;= n; i++) &#123; ans += dp[n][i]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 晴天小猪历险记之Hill题目描述&emsp;&emsp;这一天，他来到了一座深山的山脚下，因为只有这座深山中的一位隐者才知道这种药草的所在。但是上山的路错综复杂，由于小小猪的病情，晴天小猪想找一条需时最少的路到达山顶，但现在它一头雾水，所以向你求助。&emsp;&emsp;山用一个三角形表示，从山顶依次向下有1段、2段、3段等山路，每一段用一个数字$T(1 \\leq T \\leq 100)$表示，代表晴天小猪在这一段山路上需要爬的时间，每一次它都可以朝左、右、左上、右上四个方向走（注意：在任意一层的第一段也可以走到本层的最后一段或上一层的最后一段）。&emsp;&emsp;晴天小猪从山的左下角出发，目的地为山顶，即隐者的小屋。 输入数据&emsp;&emsp;第一行有一个数 n (2≤n≤1000)，表示山的高度。&emsp;&emsp;从第二行至第 n+1 行，第 i+1 行有 i个数，每个数表示晴天小猪在这一段山路上需要爬的时间。 输出数据&emsp;&emsp;一个数，即晴天小猪所需要的最短时间。 样例输入123456512 34 5 610 1 7 81 1 4 5 6 样例输出110 题解（未验证）123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;//晴天小猪之hill int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; m(n, vector&lt;int&gt;(n, INF)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; cin &gt;&gt; m[i][j]; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, INF)); dp[n - 1][0] = m[n - 1][0]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= i; j++) &#123; int l, r;//i,j可以由(i,j-1) (i,j+1) (i+1,j-1) (i+1,j-1)到达 l = (j &gt; 0 ? j - 1 : i); r = (j &lt; i ? j + 1 : 0); dp[i][j] = min(dp[i][j], dp[i][l] + m[i][l]); dp[i][j] = min(dp[i][j], dp[i][r] + m[i][r]); if (i &lt; n - 1) &#123; l = (j == 0 ? i + 1 : l); dp[i][j] = min(dp[i][j], dp[i + 1][l] + m[i + 1][l]); dp[i][j] = min(dp[i][j], dp[i + 1][r] + m[i + 1][r]); &#125; &#125; &#125; cout &lt;&lt; dp[0][0] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"计网学习笔记","slug":"计网学习笔记","date":"2021-09-25T12:49:37.000Z","updated":"2022-09-13T11:51:22.988Z","comments":true,"path":"2021/09/25/计网学习笔记/","link":"","permalink":"http://example.com/2021/09/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"摸鱼怪的计网学习笔记……上课不听课，课下两行泪这课最后居然还是英文考试…麻了","text":"摸鱼怪的计网学习笔记……上课不听课，课下两行泪这课最后居然还是英文考试…麻了 第一章 计算机网络与互联网&emsp;&emsp;世界上第一个分组交换网络是ARPAnet。&emsp;&emsp;网络由网络边缘（主机和网络应用）、接入网络和物理介质（有线或无线通信链路）及网络核心（互联的路由器或分组转发设备）构成。&emsp;&emsp;所有接入互联网的设备，如传统的桌面PC、Linux工作站、服务器等及新出现的物联网设备都被称为主机（host）或是端系统（end system），值得注意的是这两个称呼在本课程中没有任何的区别，可以随时换用，例如Web服务器就是一个端系统（主机）。&emsp;&emsp;端系统通过通信链路(communication link)及分组交换机(packet switch)连接到一起。链路的传输速率单位是bps，在传输数据时，发送方将数据分段，并为每段加上首部字节，形成分组（packet）。分组交换机的类型多种多样，最著名的两种类型是路由器（router）和链路层交换机（link-layer switch）。前者常用于网络核心，后者常用于接入网。&emsp;&emsp;端系统通过ISP接入互联网。端系统、分组交换机和其他因特网部件都需要运行一系列用于控制因特网中信息的接受于发送的协议（protocol），TCP与IP是因特网中最重要的两个协议，互联网的主要协议统称为TCP/IP。对于协议很重要的一点就是标准。&emsp;&emsp;请求评论（RFC）文档定义了TCP、IP、HTTP与SMTP等协议。懒得写了…看看这个吧 第二章 应用层","categories":[{"name":"计算机专业课","slug":"计算机专业课","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"算法分析与设计第一次作业题题解","slug":"算法分析与设计第一次作业题题解","date":"2021-09-23T13:40:26.000Z","updated":"2022-09-13T11:54:10.474Z","comments":true,"path":"2021/09/23/算法分析与设计第一次作业题题解/","link":"","permalink":"http://example.com/2021/09/23/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"","text":"A - 一元三次方程求根有形如：$ax^3+bx^2+cx+d=0$这样的一个一元三次方程。给出该方程中各项的系数($a，b，c，d$均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt; =1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。提示：记方程$f(x)=0$，若存在2个数$x_1$和$x_2$，且$x_1&lt;x_2$，$f(x_1)*(x_2)&lt;0$，则在$(x_1，x_2)$之间一定有一个根。 输入数据输入该方程中各项的系数(a,b,c,d均为实数)，输出数据由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。样例输入 11 -5 -4 20 样例输出 1-2.00 2.00 5.00 题解二分法的题目。由于该一元三次方程必有三个实根，记f(x)=ax^3+bx^2+cx+d，则f’(x)必有两个相异实根x1与x2，其中x1&lt;x2，由三次函数的性质及题设可知：三个实根分别在(-100, x1)、(x1, x2)、(x2, 100)三个范围内。对三个区间运用二分法即可。注意输出时候要设置格式。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;double a, b, c, d;double f(double x) &#123; return (a * x * x * x + b * x * x + c * x + d);&#125;double find_solution(double start, double end) &#123; if (end - start &lt; 0.01) &#123; return (start + end) / 2; &#125; else &#123; double fl = f(start); double fm = f((start + end) / 2.0); if (fl * fm &lt; 0) &#123; return find_solution(start, (start + end) / 2.0 - 0.0001); &#125; else&#123; return find_solution((start + end) / 2.0 + 0.0001, end); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; double seg1 = -100, seg4 = 100; double seg2 = min((-b + sqrt(b * b - 3 * a * c)) / (3 * a), (-b - sqrt(b * b - 3 * a * c)) / (3 * a)); double seg3 = max((-b + sqrt(b * b - 3 * a * c)) / (3 * a), (-b - sqrt(b * b - 3 * a * c)) / (3 * a)); //cout &lt;&lt; seg2 &lt;&lt; &#x27; &#x27; &lt;&lt; seg3 &lt;&lt; endl; double x1, x2, x3; x1 = find_solution(seg1, seg2); x2 = find_solution(seg2, seg3); x3 = find_solution(seg3, seg4); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2); cout &lt;&lt; x1 &lt;&lt; &#x27; &#x27; &lt;&lt; x2 &lt;&lt; &#x27; &#x27; &lt;&lt; x3 &lt;&lt; endl; return 0;&#125; Problem B. 小飞侠的游园方案时间限制 1000 ms内存限制 128 MB题目描述 经过抽签选择，小智将军第一个进入考场。 菜虫：（身上散射出华贵（?）的光芒）欢迎你，第一位挑战者！！ 小智：……（走到菜虫身后，关灯）女王陛下，虽然我们国家现在很富裕，但也请您不要浪费电来用这么大功率的灯泡。 菜虫（汗）：啊啊爱卿所言甚是那么，你的题目是……我们的情报组织探听到敌人的重要将领——小飞侠星期天会邀他的灵儿妹妹到公园去玩。公园里有很多娱乐项目，可并不是每一项他们都喜欢，所以他们对每一项都进行了“喜欢度”的评分。因为小飞侠也是一个了不起的角色，所以他一定会选择在有限时间内的最好的方案。现在要你做的就是找出在规定时间内他们选择哪几项不同的活动可以使其“喜欢度”之和达到最大，据此我们就可以知道他会在哪些地方出现，从而在那里派人看守了。 小智：（灯泡一亮）每个地方都派人看守不就行了？！ “当~~~” 菜虫：（手执八公分直径炒锅，筋）……你是白痴吗？-_-## （都派人去看守的话我们会有多少桌三缺一？！）听好了，输入格式是第一行一个正整数N（1&lt; =N&lt; =100）表示总共的娱乐项目数；第二行一个正整数表示规定的时间t（0&lt; t&lt; 1000）；下面有N行，其中第i+2行有两个正整数fi（0&lt; =fi&lt; =100）和ti（0&lt; ti&lt; =100），分别表示对项目i的“喜欢度”和它所耗费的时间。输出的时候在第一行输出最大的“喜欢度”之和，下面给你一个样例：输入数据输出数据样例输入 12345351 25 54 3 样例输出 15 题解0-1背包问题，用动态规划即可求解。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int N, t; cin &gt;&gt; N &gt;&gt; t; vector&lt;int&gt; w, v; w.push_back(0); v.push_back(0); for(int i = 0; i &lt; N; i++)&#123; int like, cost; cin &gt;&gt; like &gt;&gt; cost; v.push_back(like); w.push_back(cost); &#125; vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(t + 1, 0)); int maxLike = 0; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= t; j++) &#123; if (j &lt; w[i]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; maxLike = max(maxLike, dp[i][j]); &#125; &#125; cout &lt;&lt; maxLike &lt;&lt; endl; return 0;&#125; Problem C. 课堂作业-7-1时间限制 1000 ms内存限制 64 MB题目描述 有n根小木棒，任选三根木棒组成一个三角形，问三角形周长最大是多少。（保证至少存在一种选法能组成三角形）输入数据 第一行为一个正整数n，3=&lt;n&lt;=100 第二行为n个正整数，代表小木棒长度，不超过100.输出数据 三角形周长的最大值样例输入 1251 2 3 4 5 样例输出 112 题解一看n的范围，这不暴力枚举（代码不写了… Problem D. 课堂作业-9-2时间限制 1000 ms内存限制 64 MB题目描述 在一个被分成n*n个格子的平原上，有一些格子有铁矿，两格铁矿如果相邻那么就认为他们属于同一个矿床，每个矿床都包含一个或更多个铁矿，问一共有几个矿床。两个格子只要有公共边或公共点就算相邻。输入数据 第一行为一个正整数n，n&lt;=1000 接下来有n行，每行有n个字符，表示平原的对应位置有没有铁矿，*代表没有，#代表有输出数据 矿床个数样例输入 12345676*#*## ### #*#**## ****#*******## #****** 样例输出 12 样例说明 最下面三块铁矿属于一个矿床，其他铁矿属于一个矿床，所以一共有两个矿床 题解BFS（ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int totalCount = 0;void traverseMap(vector&lt;vector&lt;char&gt;&gt;&amp; field, int row, int col);void mineCount(vector&lt;vector&lt;char&gt;&gt;&amp; field);int main() &#123; int n; cin &gt;&gt; n; if (n &gt; 0) &#123; vector&lt;vector&lt;char&gt;&gt; field(n, vector&lt;char&gt;(n)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; char temp; cin &gt;&gt; temp; field[i][j] = temp; &#125; &#125; mineCount(field); &#125; cout &lt;&lt; totalCount &lt;&lt; endl; return 0;&#125;void traverseMap(vector&lt;vector&lt;char&gt;&gt;&amp; field, int row, int col)&#123; if(row &lt; 0 || col &lt; 0 || row &gt;= field.size() || col &gt;= field.size() || field[row][col] == &#x27;*&#x27; || field[row][col] == &#x27;*&#x27;)&#123; return; &#125; field[row][col] = &#x27;*&#x27;; traverseMap(field, row + 1, col); traverseMap(field, row - 1, col); traverseMap(field, row, col + 1); traverseMap(field, row, col - 1); traverseMap(field, row + 1, col - 1); traverseMap(field, row + 1, col + 1); traverseMap(field, row - 1, col + 1); traverseMap(field, row - 1, col - 1);&#125;void mineCount(vector&lt;vector&lt;char&gt;&gt;&amp; field) &#123; for (int i = 0; i &lt; field.size(); i++) &#123; for (int j = 0; j &lt; field.size(); j++) &#123; if (field[i][j] == &#x27;#&#x27;) &#123; totalCount++; traverseMap(field, i, j); &#125; &#125; &#125;&#125; Problem E. 合并果子时间限制 1000 ms内存限制 128 MB题目描述 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。输入数据输入包括两行，第一行是一个整数 n (1&lt;＝n&lt;103)，表示果子的种类数。第二行包含 n 个整数，用空格分隔，第 i 个整数 ai (1&lt;＝ai&lt;2×103) 是第 i种果子的数目。输出数据输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 231。样例输入 123 1 2 9 样例输出 115 题解huffman树 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;priority_queue&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int N; cin &gt;&gt; N; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Q; for (int i = 0; i &lt; N; i++) &#123; int temp; cin &gt;&gt; temp; Q.push(temp); &#125; int ans = 0; for (int i = 0; i &lt; N - 1; i++) &#123; int tempSum = Q.top(); Q.pop(); tempSum += Q.top(); Q.pop(); Q.push(tempSum); ans += tempSum; &#125; cout &lt;&lt; ans &lt;&lt; endl; //priority_queue greater huffman 每次出堆的都是最小的元素 小顶堆 //想使得最小元素有最高优先级 //大顶堆出堆是最小元素与堆顶元素交换 交换后调整堆 每次出堆的都是当前最大的元素 //大顶堆 a[0]最大 //小顶堆 a[0]最小 //结论：priority_queue与vector排序方式一样 greater降序 less升序 逻辑上都是一样的 但是要看针对不同数据类型理解降序与升序 //vector的迭代顺序为0-&gt;vector.size()-1，优先队列不支持迭代 //记一下 //堆greater是小顶堆 return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"枚举算法学习","slug":"枚举算法学习","date":"2021-09-23T13:23:58.000Z","updated":"2022-09-13T11:51:36.358Z","comments":true,"path":"2021/09/23/枚举算法学习/","link":"","permalink":"http://example.com/2021/09/23/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"枚举算法是最朴素的算法之一。也称之为穷举算法，就是按照问题本身的性质，一 一列举出该问题所有可能的解，并在列举的过程中，逐一检验每个可能解是否是问题的真正解。若是则采纳这个解；否则抛弃它。其中很重要的两点是不重、不漏。其特点为解高效、全面；实现简单；效率提升空间大。例题1：设S为由所有正整数按从小到大的顺序组成的序列，即S=1234567891011….，记S中第一次出现1为位置1，求S的第n位。思路：首先确定n所在的是几位正整数的范围，随后确定在哪个数字上，最后找在哪位上即可。 123456789101112131415161718192021222324252627282930int f(int n) &#123; //1、确定n所在的位数范围 int base = 1;//位数 int l = 1, step = 9, lnum = 1; for (; base &lt;= 8; base++) &#123; if (n &gt;= l &amp;&amp; n &lt;= l + step - 1) &#123; break; &#125; else &#123; l += step; step *= (10 * (base + 1)); step /= base; lnum *= 10; &#125; &#125; if (base &gt; 9) &#123; return -1; &#125; //2、计算在哪个数 int target = (n - l) / base + lnum; //3、计算在这个数的第几位 int targetIndex = (n - l + 1) % base; targetIndex = (!targetIndex ? base : targetIndex); vector&lt;int&gt; v; while (target)&#123; v.push_back(target % 10); target /= 10; &#125; return v[v.size() - targetIndex];&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"暴力枚举","slug":"暴力枚举","permalink":"http://example.com/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"}]},{"title":"First Blog of GnafiY","slug":"post-title-with-whitespace","date":"2021-09-22T14:57:29.000Z","updated":"2022-09-14T01:43:05.156Z","comments":true,"path":"2021/09/22/post-title-with-whitespace/","link":"","permalink":"http://example.com/2021/09/22/post-title-with-whitespace/","excerpt":"","text":"尝试使用Hexo","categories":[],"tags":[]},{"title":"Images","slug":"images","date":"2013-12-26T14:46:49.000Z","updated":"2022-09-12T13:13:17.099Z","comments":true,"path":"2013/12/26/images/","link":"","permalink":"http://example.com/2013/12/26/images/","excerpt":"","text":"This is a image test post. 图床 本地资源+html","categories":[],"tags":[]}],"categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"},{"name":"网站相关","slug":"网站相关","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3/"},{"name":"算法学习","slug":"算法学习","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"算法学习/题解","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/"},{"name":"课业","slug":"算法学习/题解/课业","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%A2%98%E8%A7%A3/%E8%AF%BE%E4%B8%9A/"},{"name":"数学","slug":"算法学习/数学","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%95%B0%E5%AD%A6/"},{"name":"课业","slug":"课业","permalink":"http://example.com/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"计算机专业课","slug":"计算机专业课","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"概率论","slug":"概率论","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"计算技巧","slug":"计算技巧","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7/"},{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"},{"name":"暴力枚举","slug":"暴力枚举","permalink":"http://example.com/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"}]}